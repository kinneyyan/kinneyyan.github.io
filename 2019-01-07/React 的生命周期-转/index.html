<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="a personal blog by Kinney Yan"><title>React 的生命周期(转) | Kinney's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/rss+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=G-LRSZVEG77Q" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-LRSZVEG77Q');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React 的生命周期(转)</h1><a id="logo" href="/.">Kinney's blog</a><p class="description">stay hungry, stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/read/"><i class="fa fa-book"> 读书</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">React 的生命周期(转)</h1><div class="post-meta">2019-01-07<span> | </span><span class="category"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E8%BD%BD%E6%9C%9F%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">装载期间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor-props"><span class="toc-number">2.1.</span> <span class="toc-text">constructor(props)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-bind-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E"><span class="toc-number">2.2.</span> <span class="toc-text">关于 bind 函数的解释说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getDerivedStateFromProps"><span class="toc-number">2.3.</span> <span class="toc-text">getDerivedStateFromProps()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#render"><span class="toc-number">2.4.</span> <span class="toc-text">render()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#componentDidMount"><span class="toc-number">2.5.</span> <span class="toc-text">componentDidMount()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%9C%9F%E9%97%B4"><span class="toc-number">3.</span> <span class="toc-text">更新期间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc-number">3.1.</span> <span class="toc-text">shouldComponentUpdate(nextProps, nextState)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getSnapshotBeforeUpdate"><span class="toc-number">3.2.</span> <span class="toc-text">getSnapshotBeforeUpdate()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc-number">3.3.</span> <span class="toc-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E6%9C%9F%E9%97%B4"><span class="toc-number">4.</span> <span class="toc-text">卸载期间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#componentWillUnmount"><span class="toc-number">4.1.</span> <span class="toc-text">componentWillUnmount()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7"><span class="toc-number">5.</span> <span class="toc-text">错误捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#componentDidCatch-error-info"><span class="toc-number">5.1.</span> <span class="toc-text">componentDidCatch(error, info)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React16-%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E5%8F%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">React16 中的生命周期函数变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p>转自 Ant Design 实战教程：<a target="_blank" rel="noopener" href="https://www.yuque.com/ant-design/course/lifemethods">https://www.yuque.com/ant-design/course/lifemethods</a></p>
</blockquote>
<p>你有没有遇到过这样的问题:</p>
<ul>
<li>组件的生命周期有哪些？为什么要有生命周期函数?</li>
<li>我应该什么时候去获取后台数据? 为什么很多教程都推荐用 componentDidMount? 用 componentWillMount 会有什么问题?</li>
<li>为什么 setState 写在这里造成了重复渲染多次？</li>
<li>setState 在这里写合适吗？</li>
</ul>
<p>读完本文希望你能对 React 的组件生命周期有一定的了解，编写 React 代码的时候能够更加得心应手，注意本文的生命周期讲的主要是浏览器端渲染，这是后端和全栈的主要使用方式，服务端渲染有些不一样，请注意区分，我们会在文中进行简单说明。</p>
<blockquote>
<p>Update: 更新为 React16 版本，React16 由于异步渲染等特性会让之前的一些方法如 componentWillMount 变得不够安全高效逐步废弃，详见<a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#legacy-lifecycle-methods">Legacy Methods</a></p>
</blockquote>
<hr>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>如果你做过安卓开发方面的编程，那么你应该了解 onCreate，onResume，onDestrory 等常见生命周期方法，生命周期函数说白了就是让我们在一个组件的各个阶段都提供一些钩子函数来让开发者在合适的时间点可以介入并进行一些操作，比如初始化(onCreate)的时候我们应该初始化组件相关的状态和变量，组件要销毁(onDestrory)时，我们应该把一些数据结构销毁掉以节约内存，防止后台任务一直运行。在 java 类中也存在一个最常见的钩子函数 contructor，你可以在这里调用 super 方法初始化父类，也可以在这里初始化各种变量。</p>
<p>我们先看下下面的图建立一个 React 组件生命周期的直观认识，图为 React 16 的生命周期，总的来说 React 组件的生命周期分为三个部分: <code>装载期间(Mounting)</code> ，<code>更新期间(Updating)</code> 和<code>卸载期间(Unmounting)</code> ，React16 多出来一个<a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch()</a> 函数用于捕捉错误。知道什么时候去使用哪些生命周期函数对于掌握和理解 React 是非常重要的，你可以看到这些生命周期函数有一定的规律，比如在某件事情发生之前调用的会用 xxxWillxxx，而在这之后发生的会用 xxxDidxxx。</p>
<p>&#x2F;&#x2F; 图来源于网络（侵删)</p>
<p><img src="https://cdn.yuque.com/lark/0/2018/png/5482/1528371738002-2a20482c-f375-45d0-a7e9-3492e2496b0f.png" alt="image.png | left | 747x414"></p>
<p>接下来我们就这三个阶段分别介绍一下各个生命周期函数，详细的生命周期函数解释可以看官方文档 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html">React.Component</a>。</p>
<hr>
<h3 id="装载期间"><a href="#装载期间" class="headerlink" title="装载期间"></a>装载期间</h3><p>组件被实例化并挂载在到 DOM 树这一过程称为装载，在装载期调用的生命周期函数依次为</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#constructor">constructor()</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps</a>()</li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#render">render()</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#componentdidmount">componentDidMount()</a></li>
</ul>
<hr>
<h4 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h4><p>构造函数，用于初始化这个组件的一些状态和操作，如果你是通过继承<code>React.Component</code>子类来创建 React 的组件的，那么你应当首先调用<code>super(props)</code> 初始化父类。</p>
<p>在 contructor 函数中，你可以<strong>初始化 state</strong>，比如<code>this.state = &#123;xxx&#125;;</code>，不要在构造函数中使用 setState()函数，强行使用的话 React 会报错。其次你可以在构造函数中<strong>进行函数 bind</strong>，如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>

<p>一个示例 contructor 实现如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不需要初始化状态也不需要绑定 handle 函数的 this，那么你可以不实现 constructor 函数，由默认实现代替。</p>
<hr>
<h4 id="关于-bind-函数的解释说明"><a href="#关于-bind-函数的解释说明" class="headerlink" title="关于 bind 函数的解释说明"></a>关于 bind 函数的解释说明</h4><p>注意 js 的 this 指向比较特殊，比如以下的例子作为 onClick 回调函数由 button 组件去调用的时候不会把组件类的上下文带过去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handleClick&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line"> &lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt;click&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>这种问题推荐三种可能的解决方式，其核心均为将函数的 this 强制绑定到组件类上:<br>1. 就是上面说的在 constructor 函数中显示调用 bind。<br>2. 在 onClick 的时候进行 bind: <code>&lt;button onClick = &#123;this.handleClick.bind(this)&#125; &gt;</code>，这种方式的劣势是每次调用的时候都需要进行 bind，优势是方便传参，处理函数需要传参可以参考 React 的文档 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/handling-events.html#passing-arguments-to-event-handlers">Passing Arguments to Event Handlers</a><br>3. 声明函数时使用箭头匿名函数，箭头函数会自动设置 this 为当前类。(<strong>简洁有效，墙裂推荐</strong>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handleClick&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// Component</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps()"></a>getDerivedStateFromProps()</h4><p>这个函数会在 render 函数被调用之前调用，包括第一次的初始化组件以及后续的更新过程中，<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state。</span></span></p>
<p>该方法主要用来替代<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">componentWillReceiveProps 方法，willReceiveProps 经常被误用，导致了一些问题，因此在新版本中被标记为 unsafe。以</span></span><a target="_blank" rel="noopener" href="https://juejin.im/post/5abf4a09f265da237719899d">掘金</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">上的 🌰 为例，</span></span>componentWillReceiveProps 的常见用法如下，根据传进来的属性值判断是否要 load 新的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isScrollingDown</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">currentRow</span> !== nextProps.<span class="property">currentRow</span>) &#123;</span><br><span class="line">      <span class="comment">// 检测到变化后更新状态、并请求数据</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">isScrollingDown</span>: nextProps.<span class="property">currentRow</span> &gt; <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">currentRow</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">loadAsyncData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loadAsyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个方法的一个问题是<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">外部组件多次频繁更新传入多次不同的 props，而该组件将这些更新 batch 后仅仅触发单次自己的更新，这种写法会导致不必要的异步请求，相比下来</span></span>getDerivedStateFromProps 配合 componentDidUpdate 的写法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isScrollingDown</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">lastRow</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// 不再提供 prevProps 的获取方式</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.<span class="property">currentRow</span> !== prevState.<span class="property">lastRow</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">isScrollingDown</span>: nextProps.<span class="property">currentRow</span> &gt; prevState.<span class="property">lastRow</span>,</span><br><span class="line">        <span class="attr">lastRow</span>: nextProps.<span class="property">currentRow</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认不改动 state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 仅在更新触发后请求数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">loadAsyncData</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loadAsyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式只在更新触发后请求数据，相比下来更节省资源。</p>
<blockquote>
<p>注意<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">getDerivedStateFromProps 是一个 static 方法，意味着拿不到实例的 this</span></span></p>
</blockquote>
<hr>
<h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><blockquote>
<p>该方法在一个 React 组件中是必须实现的，你可以看成是一个 java interface 的接口</p>
</blockquote>
<p>这是 React 组件的核心方法，用于根据状态 state 和属性 props 渲染一个 React 组件。我们应该保持该方法的纯洁性，这会让我们的组件更易于理解，只要 state 和 props 不变，每次调用 render 返回的结果应当相同，所以请<strong>不要在 render 方法中改变组件状态，也不要在在这个方法中和浏览器直接交互</strong>。</p>
<p>如果你 React 如何使用 render 方法原理不太了解，可以阅读文章《<a target="_blank" rel="noopener" href="https://lark.alipay.com/afx-es/ffb/react-intro">当 React 来敲门</a>》。</p>
<hr>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h4><p>componentDidMount 方法会在 render 方法之后立即被调用，该方法在整个 React 生命周期中只会被调用一次。React 的组件树是一个树形结构，此时你可以认为这个组件以及他下面的所有子组件都已经渲染完了，所以在这个方法中你可以调用和真实 DOM 相关的操作了。</p>
<p>有些组件的启动工作是依赖 DOM 的，例如动画的启动，而  <code>componentWillMount</code>  的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在  <code>componentDidMount</code>  当中。</p>
<p>我们推荐可以在这个函数中<strong>发送异步请求</strong>，在回调函数中调用 setState()设置 state，等数据到达后触发重新渲染。但注意尽量<strong>不要</strong>在这个函数中<strong>直接调用</strong>setState()设置状态，这会触发一次额外的重新渲染，可能造成性能问题。</p>
<p>下面的代码演示了如何在 componentDidMount 加载数据并设置状态:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentDidMount&#x27;</span>);</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://api.github.com/search/repositories?q=language:java&amp;sort=stars&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="comment">// 触发render</span></span><br><span class="line">          <span class="attr">items</span>: result.<span class="property">items</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;);</span><br><span class="line">  <span class="comment">// this.setState(&#123;color: xxx&#125;) // 不要这样做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="更新期间"><a href="#更新期间" class="headerlink" title="更新期间"></a>更新期间</h3><p>当组件的状态或属性变化时会触发更新，更新过程中会依次调用以下方法:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps()</a> 上文已描述，不赘述</li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#unsafe_componentwillupdate">componentWillUpdate()</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#render">render()</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate()</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#componentdidupdate">componentDidUpdate()</a></li>
</ul>
<hr>
<h4 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h4><p>你可以用这个方法来告诉 React 是否要进行下一次 render()，默认这个函数放回 true，即每次更新状态和属性的时候都进行组件更新。注意这个函数如果返回 false 并不会导致子组件也不更新。</p>
<p>这个钩子函数**一般不需要实现, **如果你的组件性能比较差或者渲染比较耗时，你可以考虑使<a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactpurecomponent">React.PureComponent</a> 重新实现该组件，PureComponent 默认实现了一个版本的 shouldComponentUpdate 会进行 state 和 props 的比较。当然如果你有自信，可以自己实现比较 nextProps 和 nextState 是否发生了改变。</p>
<p>该函数通常是优化性能的紧急出口，是个大招，不要轻易用，如果要用可以参考<a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/3">Immutable 详解及 React 中实践</a> .</p>
<hr>
<h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a>getSnapshotBeforeUpdate()</h4><p>该方法的触发时间为<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">update 发生的时候，在 render 之后 dom 渲染之前</span></span>返回一个值，作为 componentDidUpdate 的第三个参数。<span data-type="color" style="color:rgb(26, 26, 26)"><span data-type="background" style="background-color:rgb(255, 255, 255)">该函数与 componentDidUpdate 一起使用可以取代 componentWillUpdate 的所有功能</span></span>，比如以下是官方的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollingList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.<span class="property">list</span>.<span class="property">length</span> &lt; <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      <span class="keyword">return</span> list.<span class="property">scrollHeight</span> - list.<span class="property">scrollTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, we&#x27;ve just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don&#x27;t push the old ones out of view.</span></span><br><span class="line">    <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      list.<span class="property">scrollTop</span> = list.<span class="property">scrollHeight</span> - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.listRef&#125;</span>&gt;</span>&#123;/* ...contents... */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h4><p>该方法会在更新完成后被立即调用，你可以在这个方法中进行<strong>DOM 操作</strong>，或者<strong>做一些异步调用。</strong>这个和首次装载过程后调用 componentDidMount 是类似的，不一样的是你可能需要判断下属性是否变化了再发起网络请求，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123; <span class="comment">// 来自网络</span></span><br><span class="line">  <span class="keyword">if</span>(prevProps.<span class="property">myProps</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">myProp</span>) &#123;</span><br><span class="line">    <span class="comment">// this.props.myProp has a different value</span></span><br><span class="line">    <span class="comment">// we can perform any operations that would</span></span><br><span class="line">    <span class="comment">// need the new value and/or cause side-effects</span></span><br><span class="line">    <span class="comment">// like AJAX calls with the new value - this.props.myProp</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="卸载期间"><a href="#卸载期间" class="headerlink" title="卸载期间"></a>卸载期间</h3><p>卸载期间是指组件被从 DOM 树中移除时，调用的相关方法为:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#componentwillunmount">componentWillUnmount()</a></li>
</ul>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h4><p>该方法会在组件被卸载之前被调用，你可以在这个函数中进行相关清理工作，比如删除定时器。</p>
<p>下面给个示例代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentWillUnmount&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除timer</span></span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerID1</span>);</span><br><span class="line">  <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timerID2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭socket</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">myWebsocket</span>.<span class="title function_">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消消息订阅...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h3><p>React16 中新增了一个生命周期函数:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch()</a></li>
</ul>
<h4 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a>componentDidCatch(error, info)</h4><p>在 react 组件中如果产生的错误没有被被捕获会被抛给上层组件，如果上层也不处理的话就会抛到顶层导致浏览器白屏错误，在 React16 中我们可以实现这个方法来捕获<strong>子组件</strong>产生的错误，然后在父组件中妥善处理，比如搞个弹层通知用户网页崩溃等。</p>
<p>在这个函数中请只进行错误恢复相关的处理，不要做其他流程控制方面的操作。比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123; <span class="comment">// from react.org</span></span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="React16-中的生命周期函数变化"><a href="#React16-中的生命周期函数变化" class="headerlink" title="React16 中的生命周期函数变化"></a>React16 中的生命周期函数变化</h3><p>componentWillMount，componentWillUpdate, componentWillReceiveProps 等生命周期方法在下个主版本中会被废弃?</p>
<p>根据这份<a target="_blank" rel="noopener" href="https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md">RFC</a>，是的，这些生命周期方法被认为是不安全的，在 React16 中被重命名为 UNSAFE_componentWillMount，UNSAFE_componentWillUpdate，UNSAFE_componentWillReceiveProps，而在更下个大版本中他们会被废弃。详见<a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html"> React 16.3 版本发布公告</a>。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，以上讲的这些生命周期都有自己存在的意义，但在 React 使用过程中我们最常用到的生命周期函数是如下几个:</p>
<ul>
<li><strong>constructor</strong>: 初始化状态，进行函数绑定</li>
<li><strong>componentDidMount</strong>: 进行 DOM 操作，进行异步调用初始化页面</li>
<li><strong>componentWillReceiveProps</strong>: 根据 props 更新状态</li>
<li><strong>componentWillUnmount</strong>: 清理组件定时器，网络请求或者相关订阅等</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.mrfront.com/2016/05/03/react-components-study-states/">http://www.mrfront.com/2016/05/03/react-components-study-states/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/superman66/Front-End-Blog/issues/2">https://github.com/superman66/Front-End-Blog/issues/2</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/587de1b32f301e0057a28897">https://juejin.im/entry/587de1b32f301e0057a28897</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/JasonBoy/javascript/tree/master/react">Airbnb React&#x2F;JSX 编码规范</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013354181">理解 React 组件的生命周期</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@baphemot/understanding-reactjs-component-life-cycle-823a640b3e8d">Understanding React — Component life-cycle</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26027085">React Fiber 是什么</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html">react component</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5abf4a09f265da237719899d">讲讲今后 React 异步渲染带来的生命周期变化</a></li>
</ul>
</div><div class="tags"><a href="/tags/React"><i class="fa fa-tag">React</i></a></div><div class="post-nav"><a class="pre" href="/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/">git rebase 交互模式的使用</a><a class="next" href="/2018-08-29/Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&amp;%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Class 文件结构&amp;字节码指令-《深入理解Java虚拟机》读书笔记</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '036e8d9e78210e4703b9',
  clientSecret: '467938209e5d55bcbba0ab68dc5111f38aaa6f74',
  repo: 'https://github.com/kinneyyan/kinneyyan.github.io',
  owner: 'kinneyyan',
  admin: ['kinneyyan'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/avatar.jpg"/></a><p>一个平凡的前端开发</p><a class="info-icon" href="https://twitter.com/kinney_yan" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:yanshi.ars@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/kinneyyan" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/ssh/" style="font-size: 15px;">ssh</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 15px;">树莓派</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/RSS/" style="font-size: 15px;">RSS</a> <a href="/tags/aria2/" style="font-size: 15px;">aria2</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022-09-27/%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%EF%BC%882022%EF%BC%89/">我的树莓派使用小结（2022）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-26/%E4%BD%BF%E7%94%A8%20Tiny%20Tiny%20RSS%20%E8%A6%81%E7%82%B9%E5%8F%8A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">使用 Tiny Tiny RSS 要点及踩坑记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-17/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E6%A0%91%E8%8E%93%E6%B4%BE4B%20+%20KodExplorer%EF%BC%89/">低成本搭建私有云（树莓派4B + KodExplorer）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-11/%20Linux%20%E4%B8%8B%20ZeroTier%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">Linux 下 ZeroTier 的安装和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-10/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%80%81%E6%AF%9B%E5%AD%90%20+%20KodExplorer%EF%BC%89/">低成本搭建私有云（老毛子 + KodExplorer）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-04-15/tmux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">tmux 常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-04-08/SSH%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">SSH 常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-01-29/find,%20grep%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/">find, grep 命令速查</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/">git rebase 交互模式的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-01-07/React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%BD%AC/">React 的生命周期(转)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Kinney's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div>
<!-- Cloudflare Web Analytics -->
<script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "ee133de067eb464093931c3a365a2bb5"}'></script>
<!-- End Cloudflare Web Analytics -->
</body></html>