<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的树莓派使用小结（2022）</title>
      <link href="/2022-09-27/%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%EF%BC%882022%EF%BC%89/"/>
      <url>/2022-09-27/%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%EF%BC%882022%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从两年前购置树莓派 4B 、2T 的西数红盘，前前后后尝试了不少玩法。目前部署的服务也基本趋于稳定，就是：个人网盘 + 离线下载 + 媒体库 + RSS 服务，也是我最高频使用的（<del>树莓派吃灰不存在的</del>）。在此做个小结，同时推荐一些 APP。</p><h2 id="目前部署的服务"><a href="#目前部署的服务" class="headerlink" title="目前部署的服务"></a>目前部署的服务</h2><p>首先我在树莓派上部署的服务都是基于 Docker 。用 Docker 部署真的省心，不用关心环境依赖，不想用了 <code>docker stop &lt;container id&gt;</code> 、删掉容器、镜像即可，很适合来回折腾。</p><h3 id="个人网盘"><a href="#个人网盘" class="headerlink" title="个人网盘"></a>个人网盘</h3><h4 id="Cloudreve"><a href="#Cloudreve" class="headerlink" title="Cloudreve"></a><a href="https://cloudreve.org/">Cloudreve</a></h4><p>国人开发的公私兼备的网盘系统，文档友好、部署方便。支持 WebDAV ，网页还支持 PWA 。</p><p><a href="https://imgse.com/i/xV2tiQ"><img src="https://s1.ax1x.com/2022/09/26/xV2tiQ.jpg" alt="Cloudreve"></a></p><p><em>之前用了一段时间 Nextcloud ，后来因为一次错误升级导致服务不可用，思索再三，选择了 Cloudreve 。说一下放弃 Nextcloud 的原因：(1)太重，内置的很多功能对我来说用不到；(2)部署问题不少，当初安装碰到很多坑查阅了很多论坛帖子；(3)导入已有文件的功能很不方便，需要通过特定 cli，不像 Cloudreve 直接在管理面板操作即可</em></p><h3 id="离线下载"><a href="#离线下载" class="headerlink" title="离线下载"></a>离线下载</h3><h4 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a><a href="https://aria2.github.io/">aria2</a></h4><p>强大、轻巧、全能的下载工具，但是需要自己会配置，对于非开发用户来说有一定门槛，虽然现在市面上也有很多打包自带 GUI 的软件了。</p><p><em>这里我用的 <a href="https://github.com/P3TERX">P3TERX</a> 大佬贡献的 <a href="https://github.com/P3TERX/aria2.conf">aria2 完美配置</a> 直接安装在 PI 上。然后在 Cloudreve 管理面板中配置下 aria2 RPC 地址和密码，就可以使用 Cloudreve 的离线下载功能了。</em></p><p><a href="https://imgse.com/i/xV2uRA"><img src="https://s1.ax1x.com/2022/09/26/xV2uRA.jpg" alt="Cloudreve 管理面板"></a></p><p><em>当然也可以通过 Docker 部署， Cloudreve 官网也有提供 <a href="https://docs.cloudreve.org/getting-started/install#docker-compose">Cloudreve + aria2 的 docker-compose 部署</a>的方法。</em></p><h3 id="媒体库"><a href="#媒体库" class="headerlink" title="媒体库"></a>媒体库</h3><h4 id="Emby"><a href="#Emby" class="headerlink" title="Emby"></a><a href="https://emby.media/">Emby</a></h4><p>大名鼎鼎的媒体库解决方案，颜值高，不过非开源并带付费高级版功能。</p><p><em>最初我肯定是优先选择 FOSS(free open source software) 的 Jellyfin 的，无奈使用其 arm 架构的 docker 启动后容器内一直报错，根据 log 网上搜索半天也无果。后来用 Emby 的 docker 启动一点问题都没有，果断用 Emby 了。</em></p><h3 id="RSS-服务"><a href="#RSS-服务" class="headerlink" title="RSS 服务"></a>RSS 服务</h3><h4 id="FreshRSS"><a href="#FreshRSS" class="headerlink" title="FreshRSS"></a><a href="https://freshrss.org/">FreshRSS</a></h4><p>比 Tiny Tiny RSS 配置更方便的 RSS 服务，高级功能方面内置的全文解析（需要一点动手能力，只要会检查网页元素）对我来说完全够用了。</p><p><a href="https://imgse.com/i/xV21qf"><img src="https://s1.ax1x.com/2022/09/26/xV21qf.jpg" alt="FressRSS"></a></p><p><em>之前用了很长一段时间 Tiny Tiny RSS ，又是因为自己手贱瞎升级 docker 镜像版本……然后看了下 FressRSS 提供的 docker ，只需要跑一个容器就够，简单明了。</em></p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>其实上述我使用的四个服务能构成一个完整的影视资源的发现、下载、落库的工作流 👇</p><ol><li>订阅影视资源站的 RSS</li><li>平时浏览 RSS 时发现有想看的影视资源更新了</li><li>复制对应的磁力链</li><li>打开 Cloudreve-离线下载，粘贴链接，选择下载完成后的目录</li><li>Cloudreve 借助 aria2 开始下载资源</li><li>资源下载完毕，Cloudreve 移动到对应的目录下</li><li>Emby 服务检测到监听的磁盘目录有新的文件，加入到媒体库中，同时扫描元信息，入库完成 😃</li></ol><h2 id="关于内网穿透"><a href="#关于内网穿透" class="headerlink" title="关于内网穿透"></a>关于内网穿透</h2><p>我的方案可能没有太大的参考性，因为家里的路由器装的是 H 大的老毛子固件，自带了很多内网穿透方案，我用的是 <a href="https://www.ddnsto.com/">DDNSTO</a></p><p><a href="https://imgse.com/i/xV2qWd"><img src="https://s1.ax1x.com/2022/09/26/xV2qWd.jpg" alt="路由器后台"></a></p><p><a href="https://imgse.com/i/xVRpTS"><img src="https://s1.ax1x.com/2022/09/26/xVRpTS.jpg" alt="DDNSTO 控制台"></a></p><p>可能以后会使用其他的备选方案：</p><ul><li>申请公网 IP ，配置 DDNS</li><li><a href="https://tailscale.com/">Tailscale</a></li><li><a href="https://www.zerotier.com/">ZeroTier</a></li></ul><h2 id="使用的-APP"><a href="#使用的-APP" class="headerlink" title="使用的 APP"></a>使用的 APP</h2><ul><li><a href="https://play.google.com/store/apps/details?id=pl.solidexplorer2">Solid Explorer File Manager</a>：功能强大、界面美观的 Android 文件浏览器，最重要的是支持 WebDAV，配合上面部署的 Cloudreve，访问个人网盘的文件就像访问本地文件一样简单</li><li><a href="https://emby.media/server-android.html">Emby</a>：Emby 官方的 Android 客户端</li><li><a href="https://play.google.com/store/apps/details?id=com.seazon.feedme">FeedMe</a>：用了多年的 RSS 阅读器，配置丰富。如果手机上只能选一款 RSS 阅读器，那只能是它了</li><li><a href="https://play.google.com/store/apps/details?id=allen.town.focus.reader">FocusReader </a>：新晋的 RSS 阅读器应用，界面、交互都很简约，缺点是同步时不支持显示进度，同步出错时会有些小 bug 。所以我目前会用它配置局域网的地址，在家里看；出门在外的话，就用配置好的 DDNSTO 地址的 FeedMe ，因为能显示同步进度，弱网环境下至少能知道卡在哪一步。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>絮絮叨叨了一堆东西，算是给我这个 “丐版 NAS” 的解决方案复盘了一遍。如此这般折腾肯定有人会问：为啥不买台 NAS ？我想，折腾也是一种乐趣所在吧 😆</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> RSS </tag>
            
            <tag> aria2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Tiny Tiny RSS 要点及踩坑记录</title>
      <link href="/2020-11-26/%E4%BD%BF%E7%94%A8%20Tiny%20Tiny%20RSS%20%E8%A6%81%E7%82%B9%E5%8F%8A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2020-11-26/%E4%BD%BF%E7%94%A8%20Tiny%20Tiny%20RSS%20%E8%A6%81%E7%82%B9%E5%8F%8A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言（一些碎碎念）"><a href="#前言（一些碎碎念）" class="headerlink" title="前言（一些碎碎念）"></a>前言（一些碎碎念）</h2><h3 id="什么是-RSS？RSS-能干什么？"><a href="#什么是-RSS？RSS-能干什么？" class="headerlink" title="什么是 RSS？RSS 能干什么？"></a>什么是 RSS？RSS 能干什么？</h3><p>或许在 2020 年的今天，很多人会觉得 RSS 是过时的产物，甚至我身边的一些朋友都不知道 RSS。但是我觉得 RSS 是获取信息最酷最高效的方式！</p><p>自己总结 RSS 的特点就是：</p><ul><li>自由（订阅自己想要的信息源）、统一（所有信息源一处统一阅读）、无限制（可以使用任意的 RSS 阅读器客户端）</li></ul><p>关于 RSS 更多的食用方法，可以参考<a href="https://diygod.me/ohmyrss/">我有特别的 RSS 使用技巧</a></p><h3 id="什么是-Tiny-Tiny-RSS（TTRSS）？"><a href="#什么是-Tiny-Tiny-RSS（TTRSS）？" class="headerlink" title="什么是 Tiny Tiny RSS（TTRSS）？"></a>什么是 Tiny Tiny RSS（TTRSS）？</h3><p><a href="https://tt-rss.org/">Tiny Tiny RSS</a> 是一个开源免费的 RSS 服务，必须安装在 Web 服务器上的 Web 应用</p><h3 id="为什么要自己部署-RSS-服务如-TTRSS？"><a href="#为什么要自己部署-RSS-服务如-TTRSS？" class="headerlink" title="为什么要自己部署 RSS 服务如 TTRSS？"></a>为什么要自己部署 RSS 服务如 TTRSS？</h3><p>我是在 2017 年接触并开始使用 RSS 服务。当时国内有一款叫‘一览’的产品，在 Web 端、App 端体验都十分不错，RSS 功能也很完备，包括网站的 RSS 嗅探、新订阅源的申请（包括微信公众号！我记得当时还有一个专门提供微信公众号 feed 流的项目网站，名字忘了）、OPML 文件导入导出等。当然，2020 年的现在，这款小众的 RSS 产品早已停止运营，<a href="https://www.yilan.io/">官网</a>也打不开了，我 google 了下’一览’，竟然还找到了当年开发团队在<a href="https://v2ex.com/t/282706">V2EX 上发的贴</a>，一阵唏嘘……</p><p>通过接触‘一览’体验到 RSS 的魅力后，我又先后接触了 <a href="https://feedly.com/">Feedly</a>、<a href="https://inoreader.com/">Inoreader</a>、即刻、<a href="http://kzfeed.com/">快知</a>这些个国内外的 RSS 服务。前两者都是国外做了很多年的 RSS 服务商，账户、收费体系、客户端体验都十分成熟完备，Inoreader 我也使用至今；而<strong>早期</strong>的即刻、快知这些国内的产品，在 RSS 的功能上也是受用户认可的。</p><p>那为什么还要自建 RSS 服务呢？因为，由于’不可抗力’，Feedly 和 Inoreader 在国内都无法正常访问了；即刻？整改前已经在往社区化转型，整改后的 RSS 功能都是受监管的（虽然我没用过）；快知？这款 2020 年上线被寄希望取代即刻的产品目前也已经无法访问了……</p><p>当然除了外部因素，自建 RSS 服务也有自己的优势，你能享受很多在 Feedly、Inoreader 上原本需要收费的功能，比如：全文提取、过滤器等等。</p><h2 id="开始部署-TTRSS"><a href="#开始部署-TTRSS" class="headerlink" title="开始部署 TTRSS"></a>开始部署 TTRSS</h2><h3 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h3><p>由于树莓派是 ARM 架构，只能使用 PIP 来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -U docker-compose</span><br></pre></td></tr></table></figure><h3 id="通过-docker-compose-部署-Awesome-TTRSS"><a href="#通过-docker-compose-部署-Awesome-TTRSS" class="headerlink" title="通过 docker-compose 部署 Awesome TTRSS"></a>通过 docker-compose 部署 Awesome TTRSS</h3><p>Awesome TTRSS 是国人提供的 Tiny Tiny RSS 的 Docker 容器，插件和文档都很齐全，根据<a href="http://ttrss.henry.wang/zh/">文档</a>来部署就可以了，这里我<a href="http://ttrss.henry.wang/zh/#%E9%80%9A%E8%BF%87-docker-compose-%E9%83%A8%E7%BD%B2">通过 docker-compose 部署</a>。</p><p>操作成功后，访问 <a href="http://localhost:181/">http://localhost:181</a> 就能访问新鲜出炉的 TTRSS 了 😊</p><h3 id="导入-OPML"><a href="#导入-OPML" class="headerlink" title="导入 OPML"></a>导入 OPML</h3><p>科学上网访问我的 Inoreader，找到导出 OPML 的地方，下载一个 xml 文件到桌面。打开我的 TTRSS 的偏好设置页面，导入 OPML，选择刚才的 xml 文件。好了，我的 TTRSS 订阅源搞定了。</p><h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><p>拉取 RSSHub 的 RSS 源会报一个错：</p><p><code>; 28 Operation timed out after 15000 milliseconds with 0 bytes received</code></p><p>搜索问题发现有<a href="https://community.tt-rss.org/t/28-operation-timed-out-after-15000-milliseconds-with-0-bytes-received-it-can-be-more/2118/12">社区论坛</a>上说修改 php 相关变量可以解决，遂试之，不管用。</p><p>再次搜索发现有说是 dns 问题，需要配置容器的 dns，查了下配置所有容器 dns 的方法，在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。</p><p>随后先停止 ttrss 的容器，再启动，发现问题解决了！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://yeasy.gitbook.io/docker_practice/compose/install#pip-an-zhuang">Docker Compose 安装与卸载</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/network/dns">配置 DNS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低成本搭建私有云（树莓派4B + KodExplorer）</title>
      <link href="/2020-11-17/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E6%A0%91%E8%8E%93%E6%B4%BE4B%20+%20KodExplorer%EF%BC%89/"/>
      <url>/2020-11-17/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E6%A0%91%E8%8E%93%E6%B4%BE4B%20+%20KodExplorer%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子基于老毛子路由器上搭建的 NAS 方案有几个缺陷：</p><ol><li>性能瓶颈：加载缩略图缓慢、在同时加载多张图片、上传几十个文件时，路由器的 cpu、内存都是满载的情况，更糟糕的时候会导致路由器直接宕机卡死（都是泪）</li><li>使用 ZeroTier 实现的内网穿透其实是异地组建局域网，必须要在连接的端上安装软件。<del>而且连接的稳定性挺迷的，有时候 <code>zerotier-cli info</code> 显示 ONLINE 了，ZeroTier 后台也显示两端都是 ONLINE 状态，不知道为啥还是 ping 不通</del>（2020-11-24：已解决，路由器防火墙作祟）</li></ol><p>基于以上原因，我购置了一个树莓派 4b（4g 内存），内网穿透方案采用了收费的<a href="https://natapp.cn/">NATAPP</a>。而私有云系统则使用了 <a href="https://kodcloud.com/">KodExplorer</a> 的 Docker 来镜像搭建，经过这次折腾也顺便学习了 Docker 的安装和使用，Docker 的虚拟化容器方案极大的方便了原本需要各种依赖环境的系统搭建。</p><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ol><li>树莓派 4b(4g 内存)：连同盒子、TF 卡、读卡器等套装共￥ 452.00</li><li>2T 的西数红盘 + Orico 3.5 寸硬盘盒：一共￥ 598.72</li><li>NATAPP 的 VIP_1 型隧道 9 元&#x2F;月（二级域名 3 元&#x2F;年）：共￥ 12</li></ol><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="给树莓派安装-Raspberry-Pi-OS"><a href="#给树莓派安装-Raspberry-Pi-OS" class="headerlink" title="给树莓派安装 Raspberry Pi OS"></a>给树莓派安装 Raspberry Pi OS</h3><p>将 TF 卡插到读卡器连接电脑，随后下载官方提供的<a href="https://www.raspberrypi.org/software">Raspberry Pi Imager</a>后，打开。在’Operating System’中选择’Erase’，选好 SD 卡，点击‘WRITE’，先将我们的 TF 卡格式化为 FAT32。</p><p><img src="https://www.raspberrypi.org/homepage-9df4b/static/md-67e1bf35c20ad5893450da28a449efc4.png" alt="Raspberry Pi Imager"></p><p>完成后再从 ‘Operating System’ 选择要刷入的系统镜像，这里我选择了’Raspberry Pi OS with desktop’，选好 SD 卡，点击’WRITE’，耐心等待即可。</p><h3 id="修改默认密码、开启-SSH、VNC、修改软件源"><a href="#修改默认密码、开启-SSH、VNC、修改软件源" class="headerlink" title="修改默认密码、开启 SSH、VNC、修改软件源"></a>修改默认密码、开启 SSH、VNC、修改软件源</h3><p>镜像刷入完成后，将 TF 卡插入树莓派，然后插上网线，另一端连上路由器的 LAN 口（当然如果没有网线的话等开机后连接 WIFI 也行，但是考虑到要做 NAS 用，有线连接会更稳定些，毕竟 4B 的网口也升级成了千兆）。然后通上电源，键盘、鼠标、显示器通通连上，稍等片刻就能看到系统桌面了。</p><p>首次开机会有向导设置，到软件更新那一步先点跳过，因为后续我要自己更换国内软件源再更新。向导设置结束后，需要做一些必要的系统设置：</p><ul><li><p>修改系统默认密码：左上角树莓标志–首选项–Raspberry Pi Configuration–System–Change Password<br><img src="https://qnam.smzdm.com/202010/22/5f91731e7b4de7895.png_e680.jpg" alt="Change Password"></p></li><li><p>开启 SSH、VNC：这两项功能能够方便后期在通过终端（SSH）和桌面环境（VNC）远程登录树莓派。具体步骤：左上角树莓标志–首选项–Raspberry Pi Configuration–Interfaces–SSH&#x2F;VNC–Enable<br><img src="https://qnam.smzdm.com/202010/22/5f917324ee7946396.png_e680.jpg" alt="SSH/VNC"></p></li><li><p>修改软件源（注意：不同的 Debian 版本修改的内容略有不同，具体见<a href="https://yeasy.gitbook.io/docker_practice/install/raspberry-pi">Raspberry Pi - Docker —— 从入门到实践</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br></pre></td></tr></table></figure><p>修改完成后执行以下命令更新软件源列表、更新现有的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>完成上述步骤后，就可以拔掉 HDMI 线和键鼠了。</p><h3 id="将硬盘连上树莓派"><a href="#将硬盘连上树莓派" class="headerlink" title="将硬盘连上树莓派"></a>将硬盘连上树莓派</h3><p>首先我将硬盘格式化为了 FAT32（本次方案对硬盘文件系统没有要求，所以 NTFS、EXT4 应该都可以），然后将硬盘装入 3.5 寸硬盘盒，通上电源，连上树莓派（记得连 USB3.0 的口，蓝色的）。由于我安装的是带桌面的系统，一般硬盘连接上就会被自动挂载了。</p><h3 id="SSH-登录树莓派，安装-Docker"><a href="#SSH-登录树莓派，安装-Docker" class="headerlink" title="SSH 登录树莓派，安装 Docker"></a>SSH 登录树莓派，安装 Docker</h3><p>SSH 前先要获取树莓派在局域网的 IP 地址，可以在之前的步骤中，通过在树莓派的终端输入<code>ifconfig</code>中查看，或者进入路由器后台查看树莓派的 IP。</p><p>打开我的 2015 款 MBP，启动 iterm2，输入 <code>ssh pi@192.168.123.218</code> （这里的 IP 地址是我局域网内的，请自行更改），输完密码后就进入树莓派的 shell 了。</p><p>下一步就要安装 Docker 了，可以通过 APT 安装或者脚本安装。我采用了脚本安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Docker</span></span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立 docker 用户组</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>完成后退出终端并重新登录即可。参考自<a href="https://yeasy.gitbook.io/docker_practice/install/raspberry-pi">Raspberry Pi - Docker —— 从入门到实践</a></p><h3 id="拉取-KodExplorer-的-Docker-镜像、启动"><a href="#拉取-KodExplorer-的-Docker-镜像、启动" class="headerlink" title="拉取 KodExplorer 的 Docker 镜像、启动"></a>拉取 KodExplorer 的 Docker 镜像、启动</h3><p>有幸在 Docker Hub 上找到了一个比较完美的 KodExplorer 镜像，使用方法详见<a href="https://github.com/dennischancs/KodExplorer#KodExplorer-for-all-plaTForm">dennischancs&#x2F;KodExplorer</a></p><p>由于我挂载了 3.5 寸硬盘，在端口映射的配置我做了些许修改，我输入的完整命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name kodexplorer \</span><br><span class="line">  --hostname=kodexplorer \</span><br><span class="line">  -p 5210:5210 \</span><br><span class="line">  -p 5218:5218 \</span><br><span class="line">  -v $HOME/koddata:/koddata \</span><br><span class="line">  -v /media/pi/WD/koddata/admin:/koddata/User/admin/home \</span><br><span class="line">  -v /media/pi/WD/koddata/public:/koddata/Group/public/home \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  dennischancs/kodexplorer</span><br></pre></td></tr></table></figure><p><code>/media/pi/WD/</code> 是我的硬盘挂载的目录，这里我将容器内 KodExplorer 的 admin 和公共目录分别映射到了硬盘下的 admin 和 public 目录。</p><p>容器启动成功后，浏览器访问 <code>树莓派IP:5210</code> 就可以看到 KodExplorer Web 页面了。</p><h3 id="内网穿透：NATAPP"><a href="#内网穿透：NATAPP" class="headerlink" title="内网穿透：NATAPP"></a>内网穿透：NATAPP</h3><p><a href="https://natapp.cn/article/natapp_newbie">NATAPP1 分钟快速新手图文教程</a><br><a href="https://natapp.cn/article/nohup">linux 后台运行 natapp(ngrok)教程</a><br><a href="https://natapp.cn/article/supervisor">natapp(ngrok) Linux 开机自启动</a></p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><a href="https://imgchr.com/i/DZY59J"><img src="https://s3.ax1x.com/2020/11/17/DZY59J.jpg" alt="DZY59J.jpg"></a></p><h2 id="ONE-MORE-THING-——-私有云系统踩坑经历总结"><a href="#ONE-MORE-THING-——-私有云系统踩坑经历总结" class="headerlink" title="ONE MORE THING —— 私有云系统踩坑经历总结"></a>ONE MORE THING —— 私有云系统踩坑经历总结</h2><p>最初是准备装 NextCloudPi 搭建私有云的，然后经历了 NextCloudPi 的 docker 容器版本问题、初始化 looping 等一系列问题后，最终放弃（主要是我不想按传统方式安装，只想通过 Docker 容器来跑，无奈问题一个接一个）。</p><p>期间也有使用国人开发的 <a href="https://cloudreve.org/">CloudReve</a>，相比 NextCloudPi 搭建难度异常简单，将对应架构的程序包下载下来解压、赋权执行脚本就行了：<code>./cloudreve &gt; cloudreve.log 2&gt;&amp;1 &amp;</code>。最后放弃的原因主要是因为功能相比 KodExplorer 少了些，也没有公共目录，其他其实都挺好，尤其是 UI，采用的 MD 风格还做了 PWA。所以如果是颜值党且不需要公共目录的话完全可以用 CloudReve 搭建私有云。</p><p><a href="https://imgchr.com/i/DZNywV"><img src="https://s3.ax1x.com/2020/11/17/DZNywV.png" alt="CloudReve 的 UI 是真的不错"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://post.smzdm.com/p/akmvd9rr">用树莓派搭建私人简易网盘 2&#x2F;5 树莓派 4B 初始设置</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian">Raspbian 镜像使用帮助</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/install/raspberry-pi">Raspberry Pi - Docker —— 从入门到实践</a></li></ul><h3 id="NextCloudPi-相关资料"><a href="#NextCloudPi-相关资料" class="headerlink" title="NextCloudPi 相关资料"></a>NextCloudPi 相关资料</h3><ul><li><a href="https://ownyourbits.com/2017/11/15/nextcloudpi-dockers-for-x86-and-arm">官方 Docker 镜像教程 1</a></li><li><a href="https://ownyourbits.com/2017/06/08/nextcloudpi-docker-for-raspberry-pi">官方 Docker 镜像教程 2</a></li><li><a href="https://sspai.com/post/58675">Raspberry Pi 树莓派 3B 结合 NextCloud PI 搭建皮米级 NAS 家庭储存</a></li><li><a href="https://www.hi-linux.com/posts/35330.html">手把手教会你解决 Chrome 访问非受信证书页面时，提示「您的连接不是私密连接」错误的方法</a></li></ul><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下 ZeroTier 的安装和使用</title>
      <link href="/2020-11-11/%20Linux%20%E4%B8%8B%20ZeroTier%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2020-11-11/%20Linux%20%E4%B8%8B%20ZeroTier%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>账号注册流程见官网：<a href="https://www.zerotier.com/download">https://www.zerotier.com/download</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">zerotier-one -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取地址和服务状态</span></span><br><span class="line">zerotier-cli status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入、离开、列出网络</span></span><br><span class="line">zerotier-cli join &lt;Network ID&gt;</span><br><span class="line">zerotier-cli leave &lt;Network ID&gt;</span><br><span class="line">zerotier-cli listnetworks</span><br></pre></td></tr></table></figure><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start zerotier-one.service</span><br><span class="line">sudo systemctl enable zerotier-one.service</span><br></pre></td></tr></table></figure><p>在树莓派上也可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/rc.local</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 <span class="built_in">exit</span> 0 所在行之前前添加以下代码</span></span><br><span class="line">zerotier-one -d</span><br></pre></td></tr></table></figure><h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><p>如果 ZeroTier 是安装在路由器上的，<strong>务必</strong>设置防火墙规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT  -i ztmjflx5xm -j ACCEPT</span><br><span class="line">iptables -I FORWARD -i ztmjflx5xm -j ACCEPT</span><br><span class="line">iptables -I FORWARD -o ztmjflx5xm -j ACCEPT</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用来设置转发流量到路由器下的内网设备</span></span><br><span class="line">iptables -t nat -I POSTROUTING -o ztmjflx5xm -j MASQUERADE</span><br><span class="line">zerotier-one -d</span><br></pre></td></tr></table></figure><p><code>ztmjflx5xm</code> 为我的虚拟网卡 id，可以通过 <code>ifconfig</code> 查看自己的虚拟网卡。</p><p>我已经将上述代码放到每次路由器启动后执行（老毛子后台设置在：[高级设置]-[自定义设置]-[脚本]-[在路由器启动后执行]）</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><ul><li><a href="https://blog.boxks.com/archives/zerotier-0ffsite-networking/">使用 ZeroTier 异地组网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低成本搭建私有云（老毛子 + KodExplorer）</title>
      <link href="/2020-11-10/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%80%81%E6%AF%9B%E5%AD%90%20+%20KodExplorer%EF%BC%89/"/>
      <url>/2020-11-10/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%80%81%E6%AF%9B%E5%AD%90%20+%20KodExplorer%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本准备给家里购置一台 NAS，然后上网研究了下，发现无论是群晖还是威联通，想要买一台自己满意的 NAS（4 盘位、x86 CPU），价格基本都是 2000 上下，有点小贵……后来在网上搜索之余发现有通过路由器配合 <code>KodExplorer</code> 搭建私有云的教程，想起来家里正在用的新路由 3 支持，随即开始搭（cai）建（keng）之旅。当然最后是搭建成功了，但是有必要在这里记录一下关键步骤和坑点。</p><p>期间也考虑到了内网穿透问题，最后采用了免费易上手的 <code>ZeroTier</code>。</p><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ol><li>刷了老毛子（Padavan）固件的路由器（关于路由器能否&#x2F;如何刷老毛子，本文不做介绍，因为我的新路由 3 是买来就刷好的。tb 搜索‘路由器 老毛子’即可）</li><li>一块 2T 的西数红盘</li></ol><p><em>所有成本就是路由器+硬盘+硬盘盒的价格，总共 700 出头</em></p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h3><p>将硬盘连接到新路由 3 的 USB 口后，打开路由器控制台，按下图操作：</p><p><a href="https://imgchr.com/i/Bhk9kF"><img src="https://s1.ax1x.com/2020/11/06/Bhk9kF.png" alt="Bhk9kF.png"></a></p><p>这里我遇到的问题是：虽然通过控制台这么操作了，但是实际上硬盘并没有格式化成 EXT4（从控制台 Log 中看出来），从而导致后续安装过程出错。所以最后我是通过 ssh 到路由器，通过命令行将硬盘格式化为 ext4 的。参考：<a href="https://www.jianshu.com/p/f96ca9cb89da">linux 命令行格式化 ext4</a>。</p><h3 id="USB-应用程序设置（可选）"><a href="#USB-应用程序设置（可选）" class="headerlink" title="USB 应用程序设置（可选）"></a>USB 应用程序设置（可选）</h3><p>这一步可选，主要是针对硬盘的一些配置：</p><p><a href="https://imgchr.com/i/BhEuzd"><img src="https://s1.ax1x.com/2020/11/06/BhEuzd.png" alt="BhEuzd.png"></a></p><p>参考：<a href="http://www.duomingxing.com/jiaocheng/padavan/71.php">Padavan 老毛子 U 盘硬盘共享一些细节参数设置</a></p><h3 id="将-opt-安装模式改为‘安装到-U-盘’"><a href="#将-opt-安装模式改为‘安装到-U-盘’" class="headerlink" title="将 opt 安装模式改为‘安装到 U 盘’"></a>将 opt 安装模式改为‘安装到 U 盘’</h3><p><a href="https://imgchr.com/i/BhVZmq"><img src="https://s1.ax1x.com/2020/11/06/BhVZmq.png" alt="BhVZmq.png"></a></p><p>根据上图改好后，点击最下方‘应用本页面设置‘，页面刷新后，再点击’重置 opt 文件‘，随后观察日志、等待。直到’当前 opt 文件’有显示正确的版本号就说明成功了。</p><h3 id="开启-LNMP"><a href="#开启-LNMP" class="headerlink" title="开启 LNMP"></a>开启 LNMP</h3><p><a href="https://imgchr.com/i/BhZTRe"><img src="https://s1.ax1x.com/2020/11/06/BhZTRe.png" alt="BhZTRe.png"></a></p><p>根据上图操作后，耐心等待（一定要耐心），观察日志同时红线处显示了版本号就说明安装成功了。</p><p>安装成功之后就要开始安装 KodExplorer 了，这里我没有马上打开老毛子控制台上 KodExplorer 的开关，原因有 2 个：1. 开启后，路由器会执行 lnmp 中的脚本 wget 下载 zip 包，这一步很可能因为网络原因速度很慢下载不下来；2. lnmp 脚本中指定的 KodExplorer 的 zip 包并不是最新的版本。</p><h3 id="下载-x2F-安装-KodExplorer"><a href="#下载-x2F-安装-KodExplorer" class="headerlink" title="下载&#x2F;安装 KodExplorer"></a>下载&#x2F;安装 KodExplorer</h3><p>KodExplorer 是一个国内团队开发的基于 Web 技术的私有云在线文档管理解决方案。个人用户也可以通过搭建 KodExplorer 实现自己的一套私有云。</p><p>首先我去官网下载 KodeExplorer 的<a href="http://static.kodcloud.com/update/download/kodexplorer4.40.zip">最新版本的 zip 包</a></p><p>然后通过 scp（scp 命令参考我博客中的<a href="https://kinneyyan.github.io/2019-04-08/SSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">SSH 常用命令</a>）将 zip 包传到路由器的 <code>/opt</code> 路径下，再 ssh 到路由器，将 zip 解压到 <code>/opt/wwwroot/Kodexplorer</code>（通常解压下来还有一层目录，要将那一层目录下的文件放到此目录下）。</p><p>操作完成后，再去老毛子控制台：</p><p><a href="https://imgchr.com/i/Bhm2Ax"><img src="https://s1.ax1x.com/2020/11/06/Bhm2Ax.png" alt="Bhm2Ax.png"></a></p><p>点击下方‘应用本页面设置’后，观察日志你会发现，lnmp 脚本发现我们已经有解压好的 KodeExplorer 了，就不执行下载转而进行后续配置了。</p><p>观察日志提示成功后，我们就可以访问 <code>路由器IP地址:88</code> ，首次访问创建账号密码后，就可以进入 KodExplorer 的页面啦：</p><p><a href="https://imgchr.com/i/BqSoKH"><img src="https://s1.ax1x.com/2020/11/10/BqSoKH.png" alt="BqSoKH.png"></a></p><p><a href="https://imgchr.com/i/BhnXZR"><img src="https://s1.ax1x.com/2020/11/06/BhnXZR.png" alt="BhnXZR.png"></a></p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>这里列下当初我考虑的几种方案：</p><ul><li><p>公网 IP+DDNS+端口转发（家里没有公网 IP，放弃）：<a href="https://sspai.com/post/60303">家里搭建了 NAS 需要远程访问？这几个步骤很重要</a></p></li><li><p>ddnsto（老毛子自带，配置方便，但只能通过 web 端访问并需要微信登录）：<a href="https://zhuanlan.zhihu.com/p/79778358">0 成本搭建个人私有云</a></p></li><li><p>ZeroTier（配置方便，但需要连接的两端安装客户端，最后采用此方案）：<a href="https://zhuanlan.zhihu.com/p/73552123">老毛子 Padavan 路由器安装 ZeroTier</a>、<a href="https://zhih.me/zerotier-getting-started">ZeroTier 内网穿透教程</a></p></li><li><p><a href="https://natapp.cn/">NATAPP</a>（一款基于 ngrok 的内网穿透服务，有免费有付费。表哥推荐，后续准备试用下）</p></li></ul><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux 常用命令</title>
      <link href="/2019-04-15/tmux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019-04-15/tmux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h3><ul><li><code>tmux</code>: 新建一个无名称的会话</li><li><code>tmux new -s demo</code>: 新建一个名称为 demo 的会话</li></ul><h3 id="断开当前会话"><a href="#断开当前会话" class="headerlink" title="断开当前会话"></a>断开当前会话</h3><ul><li><code>tmux detach</code>: 断开当前会话，会话在后台运行（快捷键：[prefix]+d）</li></ul><h3 id="进入之前的会话"><a href="#进入之前的会话" class="headerlink" title="进入之前的会话"></a>进入之前的会话</h3><ul><li><code>tmux a</code>: 默认进入第一个会话</li><li><code>tmux a -t demo</code>: 进入到名称为 demo 的会话</li></ul><h3 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h3><ul><li><code>tmux kill-session -t demo</code>: 关闭 demo 会话</li><li><code>tmux kill-server</code>: 关闭服务器，所有的会话都将关闭</li></ul><h3 id="查看所有的会话"><a href="#查看所有的会话" class="headerlink" title="查看所有的会话"></a>查看所有的会话</h3><ul><li>快捷键：[prefix] + s</li></ul><h3 id="常用快捷指令"><a href="#常用快捷指令" class="headerlink" title="常用快捷指令"></a>常用快捷指令</h3><p>默认 <code>[prefix]</code> 为 <code>ctrl + b</code></p><h4 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h4><ul><li><code>[prefix] + d</code>: 断开当前会话</li><li><code>[prefix] + s</code>: 显示会话列表用于选择并切换</li><li><code>[prefix] + :</code>: 进入命令行模式，此时可直接输入 ls 等命令</li></ul><h4 id="window-指令"><a href="#window-指令" class="headerlink" title="window 指令"></a>window 指令</h4><ul><li><code>[prefix] + c</code>: 新建窗口</li><li><code>[prefix] + &amp;</code>: 关闭当前窗口</li><li><code>[prefix] + 0~9</code>: 切换到指定窗口</li><li><code>[prefix] + p</code>: 切换到上一窗口</li><li><code>[prefix] + n</code>: 切换到下一窗口</li><li><code>[prefix] + w</code>: 打开窗口列表，用于切换窗口</li><li><code>[prefix] + ,</code>: 重命名当前窗口</li></ul><h4 id="pane-指令"><a href="#pane-指令" class="headerlink" title="pane 指令"></a>pane 指令</h4><ul><li><code>[prefix] + &quot;</code>: 当前面板上下一分为二</li><li><code>[prefix] + %</code>: 当前面板左右一分为二</li><li><code>[prefix] + x</code>: 关闭当前面板</li><li><code>[prefix] + z</code>: 最大化当前面板，再重复一次按键后恢复正常</li><li><code>[prefix] + &#123;</code>: 向前置换当前面板</li><li><code>[prefix] + &#125;</code>: 向后置换当前面板</li><li><code>[prefix] + o</code>: 选择下一面板</li><li><code>[prefix] + Alt+方向键</code>: 以 5 个单元格为单位调整当前面板边缘</li><li><code>[prefix] + Alt+方向键</code>: 以 5 个单元格为单位调整当前面板边缘</li></ul><hr><blockquote><p>参考自：<a href="http://louiszhai.github.io/2017/09/30/tmux">http://louiszhai.github.io/2017/09/30/tmux</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 常用命令</title>
      <link href="/2019-04-08/SSH%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019-04-08/SSH%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><ul><li>以用户名 user，登录远程主机 host</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> user<span class="variable">@host</span></span><br></pre></td></tr></table></figure><ul><li>如果本地用户名与远程用户名一致，登录时可以省略用户名</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh host</span></span><br></pre></td></tr></table></figure><h2 id="传输文件-scp"><a href="#传输文件-scp" class="headerlink" title="传输文件: scp"></a>传输文件: scp</h2><ul><li>从远程复制文件到本地目录</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user<span class="variable">@host</span><span class="symbol">:/opt/soft/nginx-</span><span class="number">0.5</span>.<span class="number">38</span>.tar.gz /opt/soft/</span><br></pre></td></tr></table></figure><ul><li>从远程复制目录到本地</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r user<span class="variable">@host</span><span class="symbol">:/opt/soft/mongodb</span> /opt/soft/</span><br></pre></td></tr></table></figure><ul><li>从本地上传文件&#x2F;目录到远程<br>同 1、2，参数顺序反过来就行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find, grep 命令速查</title>
      <link href="/2019-01-29/find,%20grep%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
      <url>/2019-01-29/find,%20grep%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>平时使用命令行要进行搜索相关的操作时，老是记不住 find 和 grep 命令的参数，这里记一下方便之后速查。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="在-x2F-home-目录下查找以-txt-结尾的文件名"><a href="#在-x2F-home-目录下查找以-txt-结尾的文件名" class="headerlink" title="在 &#x2F;home 目录下查找以 .txt 结尾的文件名"></a>在 &#x2F;home 目录下查找以 .txt 结尾的文件名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="同上，但忽略大小写"><a href="#同上，但忽略大小写" class="headerlink" title="同上，但忽略大小写"></a>同上，但忽略大小写</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -iname &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="当前目录及子目录下查找所有以-txt-和-pdf-结尾的文件"><a href="#当前目录及子目录下查找所有以-txt-和-pdf-结尾的文件" class="headerlink" title="当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件"></a>当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br></pre></td></tr></table></figure><h3 id="匹配文件路径或者文件"><a href="#匹配文件路径或者文件" class="headerlink" title="匹配文件路径或者文件"></a>匹配文件路径或者文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure><h3 id="找出-x2F-home-下不是以-txt-结尾的文件"><a href="#找出-x2F-home-下不是以-txt-结尾的文件" class="headerlink" title="找出&#x2F;home 下不是以.txt 结尾的文件"></a>找出&#x2F;home 下不是以.txt 结尾的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="根据文件类型进行搜索"><a href="#根据文件类型进行搜索" class="headerlink" title="根据文件类型进行搜索"></a>根据文件类型进行搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type 类型参数</span><br></pre></td></tr></table></figure><p>类型参数列表：</p><ul><li>f 普通文件</li><li>l 符号连接</li><li>d 目录</li><li>c 字符设备</li><li>b 块设备</li><li>s 套接字</li><li>p Fifo</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><h3 id="在文件中搜索一个单词，命令会返回一个包含-“match-pattern”-的文本行"><a href="#在文件中搜索一个单词，命令会返回一个包含-“match-pattern”-的文本行" class="headerlink" title="在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行"></a>在文件中搜索一个单词，命令会返回一个包含 <strong>“match_pattern”</strong> 的文本行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure><h3 id="统计文件或者文本中包含匹配字符串的行数-c-选项"><a href="#统计文件或者文本中包含匹配字符串的行数-c-选项" class="headerlink" title="统计文件或者文本中包含匹配字符串的行数 -c 选项"></a>统计文件或者文本中包含匹配字符串的行数 <strong>-c</strong> 选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c &quot;text&quot; file_name</span><br></pre></td></tr></table></figure><h3 id="输出包含匹配字符串的行数-n-选项"><a href="#输出包含匹配字符串的行数-n-选项" class="headerlink" title="输出包含匹配字符串的行数 -n 选项"></a>输出包含匹配字符串的行数 <strong>-n</strong> 选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;text&quot; -n file_name</span><br></pre></td></tr></table></figure><h3 id="在多级目录中对文本进行递归搜索"><a href="#在多级目录中对文本进行递归搜索" class="headerlink" title="在多级目录中对文本进行递归搜索"></a>在多级目录中对文本进行递归搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;text&quot; . -r -n</span><br></pre></td></tr></table></figure><blockquote><p>参考自：<a href="https://wangchujiang.com/linux-command">Linux 命令搜索引擎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git rebase 交互模式的使用</title>
      <link href="/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>使用 <code>git rebase -i &lt;branch&gt;</code> 可以进入交互式模式，可以对 <strong>某一范围内的提交</strong> 进行重新编辑。</p><p>默认情况下，直接使用 <code>git rebase -i</code> 命令的操作对象为自最后一次从 origin 仓库拉取或者向 origin 推送之后的所有提交。</p><h2 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h2><p>假设我要把 master 上红色区域的分支合并成一个提交</p><p><img src="https://image-static.segmentfault.com/281/046/2810467133-5a60c6023a3f0"></p><p>首先找到起始 commit 的 前一个，也就是 <code>865b2ac</code>，rebase 会显示当前分支从这个 comimt 之后的所有 commit。</p><p>执行 <code>git rebase -i 865b2ac</code>，会自动唤出编辑器，内容如下：</p><p><img src="https://image-static.segmentfault.com/375/466/3754664714-5a60c78e73aff"></p><p>这些信息表示从 <code>865b2ac</code> commit 操作后有 4 个提交。每个提交都用一行来表示，按时间顺序展示，首行是最早的提交，末行是最新的提交，行格式如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">action</span>) (<span class="name">partial-sha</span>) (<span class="name"><span class="built_in">short</span></span> commit message)</span><br></pre></td></tr></table></figure><p>当修改这个文件后，git 会依次把这些 commit 按照 action 重新执行。action 有很多种，默认都是 <code>pick</code>，即使用该 commit，不作任何修改。</p><p>我们现在想把后三个提交合并到第一个中去，这里需要用到 <code>squash</code>，该 action 表示 使用该提交，但是把它与前一提交合并，所以只需把后四个的 action 改为 squash 即可。</p><p><img src="https://image-static.segmentfault.com/342/468/342468431-5a60c67e10149"></p><p>保存之后，会唤出编辑器提示基于历史的提交信息创建一个新的提交信息，也就是需要用户编辑一下合并之后的 commit 信息，更改提示信息并保存即可。</p><p>合并完之后的历史记录：</p><p><img src="https://image-static.segmentfault.com/208/861/2088619411-5a60c69095b66"></p><h2 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h2><p>如果想把某个 commit 拆分成多个 commit，可以使用 <code>edit</code> 作为 action，edit 表示 <strong>使用该提交，但是先在这一步停一下，等我重新编辑完再进行下一步。</strong></p><p>初始状态如下：</p><p><img src="https://image-static.segmentfault.com/208/861/2088619411-5a60c69095b66"></p><p><code>just add a new line</code> 这个 commit 修改了两个文件 <code>myfile.txt</code> 和 <code>anothorfile.txt</code>，我们希望把它拆成两个 commit，每个文件的修改各提交一个 commit</p><p>执行 <code>git rebase -i 13243ea</code>，然后修改 <code>865b2ac</code> 这个 commit 的 action 为 <code>edit</code></p><p><img src="https://image-static.segmentfault.com/280/539/2805395445-5a60c6c6471a5"></p><p>保存并退出后，git 会提示在 <code>865b2ac</code> 上停止了</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  git rebase -i <span class="number">13243</span>ea</span><br><span class="line">Stopped <span class="keyword">at</span> <span class="number">865</span>b2ac... just <span class="built_in">add</span> <span class="keyword">a</span> <span class="built_in">new</span> <span class="built_in">line</span></span><br><span class="line">You can amend <span class="keyword">the</span> commit now, <span class="keyword">with</span></span><br><span class="line">    git commit <span class="comment">--amend</span></span><br><span class="line">Once you are satisfied <span class="keyword">with</span> your changes, run</span><br><span class="line">    git rebase <span class="comment">--continue</span></span><br></pre></td></tr></table></figure><p>这里可以使用 <code>git commit --amend</code> 命令对 commit 信息进行重新编辑</p><p>我们这里是要拆分 commit，所以要先对 commit 内容 reset，然后重新提交</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  git <span class="built_in">reset</span> HEAD^ # 撤销提交</span><br><span class="line">Unstaged changes after <span class="built_in">reset</span>:</span><br><span class="line">M   myfile.txt</span><br><span class="line">M   anotherfile.txt</span><br><span class="line">➜  git add myfile.txt # 拆解出第一个提交</span><br><span class="line">➜  git commit -m &#x27;<span class="built_in">first</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit&#x27;</span><br><span class="line">[detached HEAD d0727f7] <span class="built_in">first</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line">➜  git add anotherfile.txt # 拆解出第二个提交</span><br><span class="line">➜  git commit -m &#x27;<span class="built_in">second</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit&#x27;</span><br><span class="line">[detached HEAD 2302fc7] <span class="built_in">second</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> anotherfile.txt</span><br><span class="line">➜  git rebase --continue</span><br><span class="line">Successfully rebased <span class="keyword">and</span> updated refs/heads/master.</span><br></pre></td></tr></table></figure><p>拆分完成后使用 <code>git rebase --continue</code> 即结束 rebase，结果如下：</p><p><img src="https://image-static.segmentfault.com/389/902/389902978-5a60c6ecbb37d"></p><h2 id="删除提交"><a href="#删除提交" class="headerlink" title="删除提交"></a>删除提交</h2><p>如果想删除某个提交，使用 git rebase -i 后直接在编辑器中删除那一行 commit 即可</p><p><img src="https://image-static.segmentfault.com/611/432/611432141-5a60c6fd9dbe2"></p><p>假设删除的是 commit 2，那么编辑完成后 git 会比较 commit 1 与 commit 3 的差异，如果有冲突，需要手动解决冲突后 add 并 <code>git rebase --continue</code></p><p><img src="https://image-static.segmentfault.com/608/244/608244281-5a60c7117654b"></p><blockquote><p>转自：<a href="https://segmentfault.com/a/1190000012897755">https://segmentfault.com/a/1190000012897755</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 的生命周期(转)</title>
      <link href="/2019-01-07/React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%BD%AC/"/>
      <url>/2019-01-07/React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自 Ant Design 实战教程：<a href="https://www.yuque.com/ant-design/course/lifemethods">https://www.yuque.com/ant-design/course/lifemethods</a></p></blockquote><p>你有没有遇到过这样的问题:</p><ul><li>组件的生命周期有哪些？为什么要有生命周期函数?</li><li>我应该什么时候去获取后台数据? 为什么很多教程都推荐用 componentDidMount? 用 componentWillMount 会有什么问题?</li><li>为什么 setState 写在这里造成了重复渲染多次？</li><li>setState 在这里写合适吗？</li></ul><p>读完本文希望你能对 React 的组件生命周期有一定的了解，编写 React 代码的时候能够更加得心应手，注意本文的生命周期讲的主要是浏览器端渲染，这是后端和全栈的主要使用方式，服务端渲染有些不一样，请注意区分，我们会在文中进行简单说明。</p><blockquote><p>Update: 更新为 React16 版本，React16 由于异步渲染等特性会让之前的一些方法如 componentWillMount 变得不够安全高效逐步废弃，详见<a href="https://reactjs.org/docs/react-component.html#legacy-lifecycle-methods">Legacy Methods</a></p></blockquote><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>如果你做过安卓开发方面的编程，那么你应该了解 onCreate，onResume，onDestrory 等常见生命周期方法，生命周期函数说白了就是让我们在一个组件的各个阶段都提供一些钩子函数来让开发者在合适的时间点可以介入并进行一些操作，比如初始化(onCreate)的时候我们应该初始化组件相关的状态和变量，组件要销毁(onDestrory)时，我们应该把一些数据结构销毁掉以节约内存，防止后台任务一直运行。在 java 类中也存在一个最常见的钩子函数 contructor，你可以在这里调用 super 方法初始化父类，也可以在这里初始化各种变量。</p><p>我们先看下下面的图建立一个 React 组件生命周期的直观认识，图为 React 16 的生命周期，总的来说 React 组件的生命周期分为三个部分: <code>装载期间(Mounting)</code> ，<code>更新期间(Updating)</code> 和<code>卸载期间(Unmounting)</code> ，React16 多出来一个<a href="https://reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch()</a> 函数用于捕捉错误。知道什么时候去使用哪些生命周期函数对于掌握和理解 React 是非常重要的，你可以看到这些生命周期函数有一定的规律，比如在某件事情发生之前调用的会用 xxxWillxxx，而在这之后发生的会用 xxxDidxxx。</p><p>&#x2F;&#x2F; 图来源于网络（侵删)</p><p><img src="https://cdn.yuque.com/lark/0/2018/png/5482/1528371738002-2a20482c-f375-45d0-a7e9-3492e2496b0f.png" alt="image.png | left | 747x414"></p><p>接下来我们就这三个阶段分别介绍一下各个生命周期函数，详细的生命周期函数解释可以看官方文档 <a href="https://reactjs.org/docs/react-component.html">React.Component</a>。</p><hr><h3 id="装载期间"><a href="#装载期间" class="headerlink" title="装载期间"></a>装载期间</h3><p>组件被实例化并挂载在到 DOM 树这一过程称为装载，在装载期调用的生命周期函数依次为</p><ul><li><a href="https://reactjs.org/docs/react-component.html#constructor">constructor()</a></li><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps</a>()</li><li><a href="https://reactjs.org/docs/react-component.html#render">render()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidmount">componentDidMount()</a></li></ul><hr><h4 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h4><p>构造函数，用于初始化这个组件的一些状态和操作，如果你是通过继承<code>React.Component</code>子类来创建 React 的组件的，那么你应当首先调用<code>super(props)</code> 初始化父类。</p><p>在 contructor 函数中，你可以<strong>初始化 state</strong>，比如<code>this.state = &#123;xxx&#125;;</code>，不要在构造函数中使用 setState()函数，强行使用的话 React 会报错。其次你可以在构造函数中<strong>进行函数 bind</strong>，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure><p>一个示例 contructor 实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不需要初始化状态也不需要绑定 handle 函数的 this，那么你可以不实现 constructor 函数，由默认实现代替。</p><hr><h4 id="关于-bind-函数的解释说明"><a href="#关于-bind-函数的解释说明" class="headerlink" title="关于 bind 函数的解释说明"></a>关于 bind 函数的解释说明</h4><p>注意 js 的 this 指向比较特殊，比如以下的例子作为 onClick 回调函数由 button 组件去调用的时候不会把组件类的上下文带过去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handleClick&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line"> &lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt;click&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>这种问题推荐三种可能的解决方式，其核心均为将函数的 this 强制绑定到组件类上:<br>1. 就是上面说的在 constructor 函数中显示调用 bind。<br>2. 在 onClick 的时候进行 bind: <code>&lt;button onClick = &#123;this.handleClick.bind(this)&#125; &gt;</code>，这种方式的劣势是每次调用的时候都需要进行 bind，优势是方便传参，处理函数需要传参可以参考 React 的文档 <a href="https://reactjs.org/docs/handling-events.html#passing-arguments-to-event-handlers">Passing Arguments to Event Handlers</a><br>3. 声明函数时使用箭头匿名函数，箭头函数会自动设置 this 为当前类。(<strong>简洁有效，墙裂推荐</strong>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handleClick&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// Component</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps()"></a>getDerivedStateFromProps()</h4><p>这个函数会在 render 函数被调用之前调用，包括第一次的初始化组件以及后续的更新过程中，<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state。</span></span></p><p>该方法主要用来替代<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">componentWillReceiveProps 方法，willReceiveProps 经常被误用，导致了一些问题，因此在新版本中被标记为 unsafe。以</span></span><a href="https://juejin.im/post/5abf4a09f265da237719899d">掘金</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">上的 🌰 为例，</span></span>componentWillReceiveProps 的常见用法如下，根据传进来的属性值判断是否要 load 新的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isScrollingDown</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">currentRow</span> !== nextProps.<span class="property">currentRow</span>) &#123;</span><br><span class="line">      <span class="comment">// 检测到变化后更新状态、并请求数据</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">isScrollingDown</span>: nextProps.<span class="property">currentRow</span> &gt; <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">currentRow</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">loadAsyncData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loadAsyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个方法的一个问题是<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">外部组件多次频繁更新传入多次不同的 props，而该组件将这些更新 batch 后仅仅触发单次自己的更新，这种写法会导致不必要的异步请求，相比下来</span></span>getDerivedStateFromProps 配合 componentDidUpdate 的写法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isScrollingDown</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">lastRow</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// 不再提供 prevProps 的获取方式</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.<span class="property">currentRow</span> !== prevState.<span class="property">lastRow</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">isScrollingDown</span>: nextProps.<span class="property">currentRow</span> &gt; prevState.<span class="property">lastRow</span>,</span><br><span class="line">        <span class="attr">lastRow</span>: nextProps.<span class="property">currentRow</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认不改动 state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 仅在更新触发后请求数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">loadAsyncData</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loadAsyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式只在更新触发后请求数据，相比下来更节省资源。</p><blockquote><p>注意<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">getDerivedStateFromProps 是一个 static 方法，意味着拿不到实例的 this</span></span></p></blockquote><hr><h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><blockquote><p>该方法在一个 React 组件中是必须实现的，你可以看成是一个 java interface 的接口</p></blockquote><p>这是 React 组件的核心方法，用于根据状态 state 和属性 props 渲染一个 React 组件。我们应该保持该方法的纯洁性，这会让我们的组件更易于理解，只要 state 和 props 不变，每次调用 render 返回的结果应当相同，所以请<strong>不要在 render 方法中改变组件状态，也不要在在这个方法中和浏览器直接交互</strong>。</p><p>如果你 React 如何使用 render 方法原理不太了解，可以阅读文章《<a href="https://lark.alipay.com/afx-es/ffb/react-intro">当 React 来敲门</a>》。</p><hr><h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h4><p>componentDidMount 方法会在 render 方法之后立即被调用，该方法在整个 React 生命周期中只会被调用一次。React 的组件树是一个树形结构，此时你可以认为这个组件以及他下面的所有子组件都已经渲染完了，所以在这个方法中你可以调用和真实 DOM 相关的操作了。</p><p>有些组件的启动工作是依赖 DOM 的，例如动画的启动，而  <code>componentWillMount</code>  的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在  <code>componentDidMount</code>  当中。</p><p>我们推荐可以在这个函数中<strong>发送异步请求</strong>，在回调函数中调用 setState()设置 state，等数据到达后触发重新渲染。但注意尽量<strong>不要</strong>在这个函数中<strong>直接调用</strong>setState()设置状态，这会触发一次额外的重新渲染，可能造成性能问题。</p><p>下面的代码演示了如何在 componentDidMount 加载数据并设置状态:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentDidMount&#x27;</span>);</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://api.github.com/search/repositories?q=language:java&amp;sort=stars&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="comment">// 触发render</span></span><br><span class="line">          <span class="attr">items</span>: result.<span class="property">items</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;);</span><br><span class="line">  <span class="comment">// this.setState(&#123;color: xxx&#125;) // 不要这样做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="更新期间"><a href="#更新期间" class="headerlink" title="更新期间"></a>更新期间</h3><p>当组件的状态或属性变化时会触发更新，更新过程中会依次调用以下方法:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps()</a> 上文已描述，不赘述</li><li><a href="https://reactjs.org/docs/react-component.html#unsafe_componentwillupdate">componentWillUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#render">render()</a></li><li><a href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidupdate">componentDidUpdate()</a></li></ul><hr><h4 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h4><p>你可以用这个方法来告诉 React 是否要进行下一次 render()，默认这个函数放回 true，即每次更新状态和属性的时候都进行组件更新。注意这个函数如果返回 false 并不会导致子组件也不更新。</p><p>这个钩子函数**一般不需要实现, **如果你的组件性能比较差或者渲染比较耗时，你可以考虑使<a href="https://reactjs.org/docs/react-api.html#reactpurecomponent">React.PureComponent</a> 重新实现该组件，PureComponent 默认实现了一个版本的 shouldComponentUpdate 会进行 state 和 props 的比较。当然如果你有自信，可以自己实现比较 nextProps 和 nextState 是否发生了改变。</p><p>该函数通常是优化性能的紧急出口，是个大招，不要轻易用，如果要用可以参考<a href="https://github.com/camsong/blog/issues/3">Immutable 详解及 React 中实践</a> .</p><hr><h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a>getSnapshotBeforeUpdate()</h4><p>该方法的触发时间为<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">update 发生的时候，在 render 之后 dom 渲染之前</span></span>返回一个值，作为 componentDidUpdate 的第三个参数。<span data-type="color" style="color:rgb(26, 26, 26)"><span data-type="background" style="background-color:rgb(255, 255, 255)">该函数与 componentDidUpdate 一起使用可以取代 componentWillUpdate 的所有功能</span></span>，比如以下是官方的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollingList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.<span class="property">list</span>.<span class="property">length</span> &lt; <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      <span class="keyword">return</span> list.<span class="property">scrollHeight</span> - list.<span class="property">scrollTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, we&#x27;ve just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don&#x27;t push the old ones out of view.</span></span><br><span class="line">    <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      list.<span class="property">scrollTop</span> = list.<span class="property">scrollHeight</span> - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.listRef&#125;</span>&gt;</span>&#123;/* ...contents... */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h4><p>该方法会在更新完成后被立即调用，你可以在这个方法中进行<strong>DOM 操作</strong>，或者<strong>做一些异步调用。</strong>这个和首次装载过程后调用 componentDidMount 是类似的，不一样的是你可能需要判断下属性是否变化了再发起网络请求，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123; <span class="comment">// 来自网络</span></span><br><span class="line">  <span class="keyword">if</span>(prevProps.<span class="property">myProps</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">myProp</span>) &#123;</span><br><span class="line">    <span class="comment">// this.props.myProp has a different value</span></span><br><span class="line">    <span class="comment">// we can perform any operations that would</span></span><br><span class="line">    <span class="comment">// need the new value and/or cause side-effects</span></span><br><span class="line">    <span class="comment">// like AJAX calls with the new value - this.props.myProp</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="卸载期间"><a href="#卸载期间" class="headerlink" title="卸载期间"></a>卸载期间</h3><p>卸载期间是指组件被从 DOM 树中移除时，调用的相关方法为:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#componentwillunmount">componentWillUnmount()</a></li></ul><h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h4><p>该方法会在组件被卸载之前被调用，你可以在这个函数中进行相关清理工作，比如删除定时器。</p><p>下面给个示例代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentWillUnmount&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除timer</span></span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerID1</span>);</span><br><span class="line">  <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timerID2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭socket</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">myWebsocket</span>.<span class="title function_">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消消息订阅...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h3><p>React16 中新增了一个生命周期函数:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch()</a></li></ul><h4 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a>componentDidCatch(error, info)</h4><p>在 react 组件中如果产生的错误没有被被捕获会被抛给上层组件，如果上层也不处理的话就会抛到顶层导致浏览器白屏错误，在 React16 中我们可以实现这个方法来捕获<strong>子组件</strong>产生的错误，然后在父组件中妥善处理，比如搞个弹层通知用户网页崩溃等。</p><p>在这个函数中请只进行错误恢复相关的处理，不要做其他流程控制方面的操作。比如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123; <span class="comment">// from react.org</span></span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="React16-中的生命周期函数变化"><a href="#React16-中的生命周期函数变化" class="headerlink" title="React16 中的生命周期函数变化"></a>React16 中的生命周期函数变化</h3><p>componentWillMount，componentWillUpdate, componentWillReceiveProps 等生命周期方法在下个主版本中会被废弃?</p><p>根据这份<a href="https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md">RFC</a>，是的，这些生命周期方法被认为是不安全的，在 React16 中被重命名为 UNSAFE_componentWillMount，UNSAFE_componentWillUpdate，UNSAFE_componentWillReceiveProps，而在更下个大版本中他们会被废弃。详见<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html"> React 16.3 版本发布公告</a>。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，以上讲的这些生命周期都有自己存在的意义，但在 React 使用过程中我们最常用到的生命周期函数是如下几个:</p><ul><li><strong>constructor</strong>: 初始化状态，进行函数绑定</li><li><strong>componentDidMount</strong>: 进行 DOM 操作，进行异步调用初始化页面</li><li><strong>componentWillReceiveProps</strong>: 根据 props 更新状态</li><li><strong>componentWillUnmount</strong>: 清理组件定时器，网络请求或者相关订阅等</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://www.mrfront.com/2016/05/03/react-components-study-states/">http://www.mrfront.com/2016/05/03/react-components-study-states/</a></li><li><a href="https://github.com/superman66/Front-End-Blog/issues/2">https://github.com/superman66/Front-End-Blog/issues/2</a></li><li><a href="https://juejin.im/entry/587de1b32f301e0057a28897">https://juejin.im/entry/587de1b32f301e0057a28897</a></li><li><a href="https://github.com/JasonBoy/javascript/tree/master/react">Airbnb React&#x2F;JSX 编码规范</a></li><li><a href="https://segmentfault.com/a/1190000013354181">理解 React 组件的生命周期</a></li><li><a href="https://medium.com/@baphemot/understanding-reactjs-component-life-cycle-823a640b3e8d">Understanding React — Component life-cycle</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085">React Fiber 是什么</a></li><li><a href="https://reactjs.org/docs/react-component.html">react component</a></li><li><a href="https://juejin.im/post/5abf4a09f265da237719899d">讲讲今后 React 异步渲染带来的生命周期变化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class 文件结构&amp;字节码指令-《深入理解Java虚拟机》读书笔记</title>
      <link href="/2018-08-29/Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&amp;%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018-08-29/Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&amp;%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Class-类文件的结构-6-3"><a href="#Class-类文件的结构-6-3" class="headerlink" title="Class 类文件的结构 (#6.3)"></a>Class 类文件的结构 (#6.3)</h4><p>Class 文件是一组<strong>以 8 位字节为基础单位的二进制流</strong>，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个 8 位字节进行存储。</p><p>Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>，后面的解析都要以这两种数据类型为基础。</p><p><strong>无符号数</strong>属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</p><p><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。</p><p><img src="https://s1.ax1x.com/2018/08/29/PXSBVI.jpg" alt="Class文件格式"></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>魔数与 Class 文件的版本</td><td>头 4 个字节称为魔数（Magic Number），作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件；紧接着魔数的 4 个字节存储的是<strong>Class 文件的版本号</strong>：第 5 和第 6 个字节是<strong>次版本号（Minor Version）</strong>，第 7 和第 8 个字节是**主版本号（Major Version）</td></tr><tr><td>常量池</td><td>可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。</td></tr><tr><td></td><td><strong>常量池</strong>中主要存放两大类常量：<strong>字面量（Literal）</strong>和<strong>符号引用（Symbolic References）</strong>。字面量比较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符</td></tr><tr><td>访问标志</td><td>紧接着的两个字节代表<strong>访问标志（access_flags）</strong>，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等</td></tr><tr><td>类索引、父类索引与接口索引集合</td><td><strong>类索引（this_class）</strong>和<strong>父类索引（super_class）</strong>都是一个 u2 类型的数据，而<strong>接口索引集合（interfaces）</strong>是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系</td></tr><tr><td>字段表集合</td><td><strong>字段表（field_info）</strong>用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</td></tr><tr><td>方法表集合</td><td>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</td></tr><tr><td></td><td>方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</td></tr><tr><td>属性表集合</td><td>在 Class 文件、字段表、方法表都可以携带自己的<strong>属性表（attribute_info）</strong>集合，以用于描述某些场景专有的信息。</td></tr><tr><td></td><td>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。这个处理只对实例方法有效。</td></tr></tbody></table><h4 id="字节码指令简介-6-4"><a href="#字节码指令简介-6-4" class="headerlink" title="字节码指令简介 (#6.4)"></a>字节码指令简介 (#6.4)</h4><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p><p>如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效地工作：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do</span>&#123;</span><br><span class="line">自动计算<span class="built_in">PC</span>寄存器的值加<span class="number">1</span>；</span><br><span class="line">根据<span class="built_in">PC</span>寄存器的指示位置，从字节码流中取出操作码；</span><br><span class="line"><span class="symbol">if</span>（字节码存在操作数）从字节码流中取出操作数；</span><br><span class="line">执行操作码所定义的操作；</span><br><span class="line">&#125;<span class="meta">while</span>（字节码流长度＞<span class="number">0</span>）；</span><br></pre></td></tr></table></figure><h5 id="字节码与数据类型-6-4-1"><a href="#字节码与数据类型-6-4-1" class="headerlink" title="字节码与数据类型 (#6.4.1)"></a>字节码与数据类型 (#6.4.1)</h5><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long,s 代表 short,b 代表 byte,c 代表 char,f 代表 float,d 代表 double,a 代表 reference。也有一些指令的助记符中没有明确地指明操作类型的字母，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令 goto 则是与数据类型无关的。</p><p>Java 虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会故意被设计成非完全独立的（Java 虚拟机规范中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><p>表 6-31 列举了 Java 虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换 opcode 列的指令模板中的 T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。例如，load 指令有操作 int 类型的 iload，但是没有操作 byte 类型的同类指令。</p><p>从表 6-31 中可以看出，大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，<strong>实际上都是使用相应的 int 类型作为运算类型（Computational Type）</strong>。</p><p><img src="https://s1.ax1x.com/2018/08/29/PX9it0.jpg" alt="Java虚拟机指令集所支持的数据类型"><br><img src="https://s1.ax1x.com/2018/08/29/PX9FhV.jpg" alt="Java虚拟机指令集所支持的数据类型"></p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>加载和存储指令</td><td>用于将数据在栈帧中的局部变量表和操作数栈（见第 2 章关于内存区域的介绍）之间来回传输</td></tr><tr><td>运算指令</td><td>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</td></tr><tr><td>类型转换指令</td><td>可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</td></tr><tr><td>对象创建与访问指令</td><td>虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在第 7 章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素</td></tr><tr><td>操作数栈管理指令</td><td>如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令</td></tr><tr><td>控制转移指令</td><td>可以让 Java 虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改 PC 寄存器的值</td></tr><tr><td>方法调用和返回指令</td><td>invokevirtual, invokeinterface, invokespecial, invokestatic, invokedynamic</td></tr><tr><td>异常处理指令</td><td>在 Java 程序中显式抛出异常的操作（throw 语句）都由 athrow 指令来实现，除了用 throw 语句显式抛出异常情况之外，Java 虚拟机规范还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出</td></tr><tr><td>同步指令</td><td>Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存区&amp;GC_《深入理解Java虚拟机》读书笔记</title>
      <link href="/2018-08-28/Java%20%E5%86%85%E5%AD%98%E5%8C%BA&amp;GC_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018-08-28/Java%20%E5%86%85%E5%AD%98%E5%8C%BA&amp;GC_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-内存区域与内存溢出异常-2"><a href="#Java-内存区域与内存溢出异常-2" class="headerlink" title="Java 内存区域与内存溢出异常 (#2)"></a>Java 内存区域与内存溢出异常 (#2)</h3><h4 id="运行时数据区域-2-2"><a href="#运行时数据区域-2-2" class="headerlink" title="运行时数据区域 (#2.2)"></a>运行时数据区域 (#2.2)</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java 虚拟机规范（Java SE 7 版）》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示：<img src="https://guolei1130.github.io/images/jvm/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="Java内存区域"></p><h4 id="程序计数器-2-2-1"><a href="#程序计数器-2-2-1" class="headerlink" title="程序计数器 (#2.2.1)"></a>程序计数器 (#2.2.1)</h4><p><strong>程序计数器</strong>（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<strong>“线程私有”的内存</strong>。</p><h4 id="Java-虚拟机栈-2-2-2"><a href="#Java-虚拟机栈-2-2-2" class="headerlink" title="Java 虚拟机栈 (#2.2.2)"></a>Java 虚拟机栈 (#2.2.2)</h4><p><strong>Java 虚拟机栈</strong>（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p><strong>局部变量表所需的内存空间</strong>在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h4 id="Java-堆-2-2-4"><a href="#Java-堆-2-2-4" class="headerlink" title="Java 堆 (#2.2.4)"></a>Java 堆 (#2.2.4)</h4><p><strong>Java 堆</strong>（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域。</p><p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，<u>栈上分配</u>、<u>标量替换</u>优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><h4 id="方法区-2-2-5"><a href="#方法区-2-2-5" class="headerlink" title="方法区 (# 2.2.5)"></a>方法区 (# 2.2.5)</h4><p><strong>方法区</strong>（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p><h4 id="运行时常量池-2-2-6"><a href="#运行时常量池-2-2-6" class="headerlink" title="运行时常量池 (#2.2.6)"></a>运行时常量池 (#2.2.6)</h4><p><strong>运行时常量池</strong>（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h4 id="HotSpot-虚拟机对象探秘-2-3"><a href="#HotSpot-虚拟机对象探秘-2-3" class="headerlink" title="HotSpot 虚拟机对象探秘 (#2.3)"></a>HotSpot 虚拟机对象探秘 (#2.3)</h4><h4 id="对象的创建-2-3-1"><a href="#对象的创建-2-3-1" class="headerlink" title="对象的创建 (#2.3.1)"></a>对象的创建 (#2.3.1)</h4><p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。</p><p>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。</p><h4 id="对象的内存布局-2-3-2"><a href="#对象的内存布局-2-3-2" class="headerlink" title="对象的内存布局 (#2.3.2)"></a>对象的内存布局 (#2.3.2)</h4><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h4 id="对象的访问定位-2-3-3"><a href="#对象的访问定位-2-3-3" class="headerlink" title="对象的访问定位 (#2.3.3)"></a>对象的访问定位 (#2.3.3)</h4><p>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><ol><li>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li><li>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</li></ol><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><h3 id="垃圾收集器与内存分配策略-3"><a href="#垃圾收集器与内存分配策略-3" class="headerlink" title="垃圾收集器与内存分配策略 (#3)"></a>垃圾收集器与内存分配策略 (#3)</h3><h4 id="引用计数算法-3-2-1"><a href="#引用计数算法-3-2-1" class="headerlink" title="引用计数算法 (#3.2.1)"></a>引用计数算法 (#3.2.1)</h4><ul><li><p>定义：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。</p></li><li><p>缺点：很难解决对象之间相互循环引用的问题。</p></li></ul><h4 id="可达性分析算法-3-2-2"><a href="#可达性分析算法-3-2-2" class="headerlink" title="可达性分析算法 (#3.2.2)"></a>可达性分析算法 (#3.2.2)</h4><ul><li>定义：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。</li></ul><p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</p><h4 id="再谈引用-3-2-3"><a href="#再谈引用-3-2-3" class="headerlink" title="再谈引用 (#3.2.3)"></a>再谈引用 (#3.2.3)</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。</p><p><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似“Object obj&#x3D;new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。</p><p><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</p><p><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</p><h4 id="生存还是死亡-3-2-4"><a href="#生存还是死亡-3-2-4" class="headerlink" title="生存还是死亡 (#3.2.4)"></a>生存还是死亡 (#3.2.4)</h4><p>关于对象死亡时<strong>finalize（）</strong>方法建议尽量避免使用它，因为它不是 C&#x2F;C++中的析构函数，而是 Java 刚诞生时为了使 C&#x2F;C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize（）能做的所有工作，使用 try-finally 或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉 Java 语言中有这个方法的存在。</p><h4 id="回收方法区-3-2-5"><a href="#回收方法区-3-2-5" class="headerlink" title="回收方法区 (#3.2.5)"></a>回收方法区 (#3.2.5)</h4><p>很多人认为方法区（或者 HotSpot 虚拟机中的永久代）是没有垃圾收集的，Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收 70%～ 95%的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><h4 id="垃圾收集算法-3-3"><a href="#垃圾收集算法-3-3" class="headerlink" title="垃圾收集算法 (#3.3)"></a>垃圾收集算法 (#3.3)</h4><h4 id="标记-清除算法-3-3-1"><a href="#标记-清除算法-3-3-1" class="headerlink" title="标记-清除算法 (#3.3.1)"></a>标记-清除算法 (#3.3.1)</h4><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p><h4 id="复制算法-3-3-2"><a href="#复制算法-3-3-2" class="headerlink" title="复制算法 (#3.3.2)"></a>复制算法 (#3.3.2)</h4><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><h4 id="标记-整理算法-3-3-3"><a href="#标记-整理算法-3-3-3" class="headerlink" title="标记-整理算法 (#3.3.3)"></a>标记-整理算法 (#3.3.3)</h4><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h4 id="分代收集算法-3-3-4"><a href="#分代收集算法-3-3-4" class="headerlink" title="分代收集算法 (#3.3.4)"></a>分代收集算法 (#3.3.4)</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<u>复制算法</u>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“<u>标记—清理</u>”或者“<u>标记—整理</u>”算法来进行回收。</p><h4 id="内存分配与回收策略-3-6"><a href="#内存分配与回收策略-3-6" class="headerlink" title="内存分配与回收策略 (#3.6)"></a>内存分配与回收策略 (#3.6)</h4><h4 id="对象优先在-Eden-分配-3-6-1"><a href="#对象优先在-Eden-分配-3-6-1" class="headerlink" title="对象优先在 Eden 分配 (#3.6.1)"></a>对象优先在 Eden 分配 (#3.6.1)</h4><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p><em>Minor GC 和 Full GC 有什么不一样吗？</em></p><p><strong>新生代 GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p><p><strong>老年代 GC（Major GC&#x2F;Full GC）</strong>：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</p><h4 id="大对象直接进入老年代-3-6-2"><a href="#大对象直接进入老年代-3-6-2" class="headerlink" title="大对象直接进入老年代 (#3.6.2)"></a>大对象直接进入老年代 (#3.6.2)</h4><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。</p><h4 id="长期存活的对象将进入老年代-3-6-3"><a href="#长期存活的对象将进入老年代-3-6-3" class="headerlink" title="长期存活的对象将进入老年代 (#3.6.3 　)"></a>长期存活的对象将进入老年代 (#3.6.3 　)</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold 设置。</p><h4 id="动态对象年龄判定-3-6-4"><a href="#动态对象年龄判定-3-6-4" class="headerlink" title="动态对象年龄判定 (#3.6.4)"></a>动态对象年龄判定 (#3.6.4)</h4><p>虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="空间分配担保-3-6-5"><a href="#空间分配担保-3-6-5" class="headerlink" title="空间分配担保 (#3.6.5)"></a>空间分配担保 (#3.6.5)</h4><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。</p><h3 id="虚拟机性能监控与故障处理工具-4"><a href="#虚拟机性能监控与故障处理工具-4" class="headerlink" title="虚拟机性能监控与故障处理工具 (#4)"></a>虚拟机性能监控与故障处理工具 (#4)</h3><h4 id="JDK-的可视化工具-4-3"><a href="#JDK-的可视化工具-4-3" class="headerlink" title="JDK 的可视化工具 (#4.3)"></a>JDK 的可视化工具 (#4.3)</h4><p>JDK 中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole 和 VisualVM。</p><h4 id="VisualVM：多合一故障处理工具-4-3-2"><a href="#VisualVM：多合一故障处理工具-4-3-2" class="headerlink" title="VisualVM：多合一故障处理工具 (#4.3.2)"></a>VisualVM：多合一故障处理工具 (#4.3.2)</h4><p>VisualVM 可以做到： 显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。 监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。 dump 以及分析堆转储快照（jmap、jhat）。 方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。 离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。 其他 plugins 的无限的可能性……</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git submodule 学习笔记</title>
      <link href="/2017-12-26/Git%20submodule%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017-12-26/Git%20submodule%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考自 Git 官方文档：<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">7.11 Git 工具 - 子模块</a></p></blockquote><h2 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h2><p><strong>将一个已存在的 Git 仓库添加为正在工作的仓库的子模块</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add &lt;子模块仓库地址&gt;</span></span><br></pre></td></tr></table></figure><h2 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h2><p>普通的<code>git clone</code>命令默认会包含子模块的目录，但其中还没有任何文件，需要执行 2 个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化本地配置文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule init</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从该项目中抓取所有数据并检出父项目中列出的合适的提交</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update</span></span><br></pre></td></tr></table></figure><p>更简单的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会自动初始化并更新仓库中的每一个子模块</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --recursive &lt;包含子模块的仓库地址&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h2><h3 id="拉取上游修改"><a href="#拉取上游修改" class="headerlink" title="拉取上游修改"></a>拉取上游修改</h3><ol><li>进入子模块目录执行：<code>git fetch</code>与<code>git merge</code></li><li>直接在主项目目录下执行：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Git 默认会尝试更新所有子模块，所以如果有很多子模块的话，你可以传递想要更新的子模块的名字</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update --remote &lt;--rebase&gt;&lt;--merge&gt;</span></span><br></pre></td></tr></table></figure><p>如果你忘记  –rebase  或  –merge，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态<br>​<br>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基  origin&#x2F;stable（或任何一个你想要的远程分支）就行了。</p><h3 id="修改子模块的默认分支"><a href="#修改子模块的默认分支" class="headerlink" title="修改子模块的默认分支"></a>修改子模块的默认分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如要修改子模块的默认分支到develop上</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config -f .gitmodules submodule.子模块名.branch develop</span></span><br></pre></td></tr></table></figure><p>其实就是修改了<code>.gitmodule</code>这个文件。提交以后，当其他人执行<code>git submodule update --remote</code>后，就会从子模块拉取 develop 这个新分支（但是还得手动进入子模块目录后切到 develop 分支- -）</p><h3 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h3><p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。 那些改动只存在于我们本地的拷贝中。</p><p>所以我们可以：</p><p>1. 让 Git 在推送到主项目前检查所有子模块是否已推送，如果任何提交的子模块改动没有推送那么 “check” 选项会直接使  push  操作失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --recurse-submodules=check</span></span><br></pre></td></tr></table></figure><p>2. 让 Git 进入到每个子模块中然后在推送主项目前推送。如果那个子模块因为某些原因推送失败，主项目也会推送失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --recurse-submodules=on-demand</span></span><br></pre></td></tr></table></figure><h3 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h3><h2 id="子模块技巧"><a href="#子模块技巧" class="headerlink" title="子模块技巧"></a>子模块技巧</h2><h3 id="子模块遍历"><a href="#子模块遍历" class="headerlink" title="子模块遍历"></a>子模块遍历</h3><p>有一个  foreach  子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule foreach <span class="string">&#x27;git pull&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h3><ul><li>问题一</li></ul><p>在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。</p><ul><li>解决方案</li></ul><p>如果你移除它然后切换回有那个子模块的分支，需要运行  submodule update –init  来重新建立和填充。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -fdx</span></span><br><span class="line">Removing CryptoLibrary/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout add-crypto</span></span><br><span class="line">Switched to branch &#x27;add-crypto&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> CryptoLibrary/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update --init</span></span><br><span class="line">Submodule path &#x27;CryptoLibrary&#x27;: checked out &#x27;b8dda6aa182ea4464f3f3264b11e0268545172af&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> CryptoLibrary/</span></span><br><span class="line">Makefileincludesscriptssrc</span><br></pre></td></tr></table></figure><ul><li>问题二</li></ul><p>如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行  submodule add，Git 会朝你大喊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -Rf CryptoLibrary/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add https://github.com/chaconinc/CryptoLibrary</span></span><br><span class="line">&#x27;CryptoLibrary&#x27; already exists in the index</span><br></pre></td></tr></table></figure><ul><li>解决方案</li></ul><p>你必须要先取消暂存  CryptoLibrary  目录。 然后才可以添加子模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -r CryptoLibrary</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add https://github.com/chaconinc/CryptoLibrary</span></span><br><span class="line">Cloning into &#x27;CryptoLibrary&#x27;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》读书笔记</title>
      <link href="/2017-11-02/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2017-11-02/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h4><ul><li>1.2.1 更佳的查找方式<br>一般而言，对于包含 n 个元素的列表，用二分查找最多需要 log2 n 步，而简单查找最多需要 n 步。</li></ul><h4 id="1-3-大-O-表示法"><a href="#1-3-大-O-表示法" class="headerlink" title="1.3 大 O 表示法"></a>1.3 大 O 表示法</h4><ul><li>1.3.1 算法的运行时间以不同的速度增加<br>仅知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大 O 表示法的用武之地。</li></ul><h4 id="3-1-递归"><a href="#3-1-递归" class="headerlink" title="3.1 递归"></a>3.1 递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">look_for_key</span>(<span class="params">box</span>):</span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> box:</span><br><span class="line">    <span class="keyword">if</span> item.is_a_box():</span><br><span class="line">      look_for_key(item)  ←------递归！</span><br><span class="line">    <span class="keyword">elif</span> item.is_a_key():</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;found the key!&quot;</span></span><br></pre></td></tr></table></figure><p>这两种方法的作用相同，但在我看来，第二种方法更清晰。递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。我很喜欢 Leigh Caldwell 在 Stack Overflow 上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”</p><h4 id="第-4-章-快速排序"><a href="#第-4-章-快速排序" class="headerlink" title="第 4 章 快速排序"></a>第 4 章 快速排序</h4><p>分而治之 （divide and conquer，D&amp;C）——一种著名的递归式问题解决方法</p><h4 id="4-3-再谈大-O-表示法"><a href="#4-3-再谈大-O-表示法" class="headerlink" title="4.3 再谈大 O 表示法"></a>4.3 再谈大 O 表示法</h4><p>快速排序的独特之处在于，其速度取决于选择的基准值。</p><ul><li>4.3.1 比较合并排序和快速排序<br>在大 O 表示法 O (n )中，n 实际上指的是这样的。<br>c 是算法所需的固定时间量，被称为常量 。例如，print<em>items 所需的时间可能是 10 毫秒 * n ，而 print</em>items2 所需的时间为 1 秒 * n 。</li></ul><h4 id="5-1-散列函数"><a href="#5-1-散列函数" class="headerlink" title="5.1 散列函数"></a>5.1 散列函数</h4><p>散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。</p><h4 id="5-3-冲突"><a href="#5-3-冲突" class="headerlink" title="5.3 冲突"></a>5.3 冲突</h4><p>散列函数很重要 。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。</p><h4 id="7-1-使用狄克斯特拉算法"><a href="#7-1-使用狄克斯特拉算法" class="headerlink" title="7.1 使用狄克斯特拉算法"></a>7.1 使用狄克斯特拉算法</h4><p>狄克斯特拉算法找出的是总权重最小的路径</p><h4 id="7-2-术语"><a href="#7-2-术语" class="headerlink" title="7.2 术语"></a>7.2 术语</h4><p>要计算非加权图中的最短路径，可使用广度优先搜索 。要计算加权图中的最短路径，可使用狄克斯特拉算法<br>在无向图中，每条边都是一个环。狄克斯特拉算法只适用于有向无环图 （directed acyclic graph，DAG）。</p><h4 id="7-3-换钢琴"><a href="#7-3-换钢琴" class="headerlink" title="7.3 换钢琴"></a>7.3 换钢琴</h4><p>狄克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径 ！</p><h4 id="8-4-NP-完全问题"><a href="#8-4-NP-完全问题" class="headerlink" title="8.4 NP 完全问题"></a>8.4 NP 完全问题</h4><ul><li>8.4.2 如何识别 NP 完全问题<br>NP 完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。</li></ul><h4 id="10-2-创建推荐系统"><a href="#10-2-创建推荐系统" class="headerlink" title="10.2 创建推荐系统"></a>10.2 创建推荐系统</h4><ul><li>10.2.3 挑选合适的特征<br>在挑选合适的特征方面，没有放之四海皆准的法则，你必须考虑到各种需要考虑的因素。</li></ul><h4 id="11-1-树"><a href="#11-1-树" class="headerlink" title="11.1 树"></a>11.1 树</h4><p>二叉查找树类似于下面这样。对于其中的每个节点，左子节点的值都比它小 ，而右子节点的值都比它大 。<br>在二叉查找树中查找节点时，平均运行时间为 O (log n )，但在最糟的情况下所需时间为 O (n )；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有 O (log n )，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。<br>B 树是一种特殊的二叉树，数据库常用它来存储数据。</p><h4 id="11-5-MapReduce"><a href="#11-5-MapReduce" class="headerlink" title="11.5 MapReduce"></a>11.5 MapReduce</h4><ul><li>11.5.1 分布式算法为何很有用<br>MapReduce 是一种流行的分布式算法，你可通过流行的开源工具 Apache Hadoop 来使用它。</li><li>11.5.3 归并函数<br>映射是将一个数组转换为另一个数组。<br>归并是将一个数组转换为一个元素。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Data Binding学习笔记——Attribute Setters</title>
      <link href="/2017-08-24/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Attribute-Setters/"/>
      <url>/2017-08-24/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Attribute-Setters/</url>
      
        <content type="html"><![CDATA[<p>这是 Data Binding 学习笔记的最后一篇，我觉得 <code>Attribute Setters</code> 的特性大大提高了 Data Binding 库的可用性、拓展性。以下主要翻译自官方文档。</p><h2 id="Attribute-Setters（属性-Setter）"><a href="#Attribute-Setters（属性-Setter）" class="headerlink" title="Attribute Setters（属性 Setter）"></a>Attribute Setters（属性 Setter）</h2><p>当一个 View 绑定的数据发生变动时，自动生成的 binding 类其实会根据 xml 中的 binding 表达式来调用 View 对应属性的 <code>setter</code> 函数。Data binding 框架内置了几种自定义赋值的方法。</p><h3 id="Automatic-Setters"><a href="#Automatic-Setters" class="headerlink" title="Automatic Setters"></a>Automatic Setters</h3><p>如果 UI 控件内的一个 attribute 叫 xxx，data binding 会尝试寻找对应的 setXXX 函数。</p><p>比如，针对一个与 TextView 的 <code>android:text</code> 绑定的表达式，data binding 会自动寻找 <code>setText(CharSequence)</code> 函数；如果表达式返回值为 int 类型，则会寻找 <code>setText(int)</code> 函数。</p><h3 id="Renamed-Setters"><a href="#Renamed-Setters" class="headerlink" title="Renamed Setters"></a>Renamed Setters</h3><p>如果 attribute 的命名与 <code>setter</code>函数不对应，我们可以用 <code>BindingMethods</code> 注解来将 attribute 与 <code>setter</code> 绑定到一起。举个例子，<code>android:tint</code> 属性可以这样与 <code>setImageTintList(ColorStateList)</code> 绑定，而不是 <code>setTint</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingMethods(&#123;</span></span><br><span class="line"><span class="meta">       @BindingMethod(type = &quot;android.widget.ImageView&quot;,</span></span><br><span class="line"><span class="meta">                      attribute = &quot;android:tint&quot;,</span></span><br><span class="line"><span class="meta">                      method = &quot;setImageTintList&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>Android 框架中的 setter 重命名已经在库中实现了，开发者只需要专注于自己的 setter。</p><h3 id="Custom-Setters"><a href="#Custom-Setters" class="headerlink" title="Custom Setters"></a>Custom Setters</h3><p>一些属性需要自定义 setter 逻辑。例如，目前没有与 <code>android:paddingLeft</code> 对应的 setter，只有一个 <code>setPadding(left, top, right, bottom)</code> 函数。结合静态 binding adapter 函数与 <a href="http://developer.android.com/reference/android/databinding/BindingAdapter.html"><code>BindingAdapter</code></a> 注解可以让开发者自定义属性 setter。</p><p>Android 属性已经内置一些 BindingAdapter。例如，这是一个 <code>paddingLeft</code> 的自定义 setter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:paddingLeft&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setPaddingLeft</span><span class="params">(View view, <span class="type">int</span> padding)</span> &#123;</span><br><span class="line">   view.setPadding(padding,</span><br><span class="line">                   view.getPaddingTop(),</span><br><span class="line">                   view.getPaddingRight(),</span><br><span class="line">                   view.getPaddingBottom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Binding adapter 在其他自定义类型上也很好用。举个例子，一个 loader 可以在非主线程加载图片。</p><p>当存在冲突时，开发者创建的 binding adapter 会覆盖 data binding 的默认 adapter。</p><p>你也可以创建多个参数的 adapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BindingAdapter(&#123;<span class="string">&quot;bind:imageUrl&quot;</span>, <span class="string">&quot;bind:error&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> &#123;</span><br><span class="line">   Picasso.with(view.getContext()).load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">app:imageUrl</span>=<span class="string">“@&#123;venue.imageUrl&#125;”</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:error</span>=<span class="string">“@&#123;@drawable/venueError&#125;”/</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <strong>imageUrl</strong> 与 <strong>error</strong> 存在时这个 adapter 会被调用。imageUrl 是一个 String，error 是一个 Drawable。</p><ul><li>在匹配时自定义命名空间会被忽略</li><li>你可以为 android 命名空间编写 adapter</li></ul><p>Binding adapter 方法可以获取旧的赋值。只需要将旧值放置在前，新值放置在后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:paddingLeft&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setPaddingLeft</span><span class="params">(View view, <span class="type">int</span> oldPadding, <span class="type">int</span> newPadding)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (oldPadding != newPadding) &#123;</span><br><span class="line">       view.setPadding(newPadding,</span><br><span class="line">                       view.getPaddingTop(),</span><br><span class="line">                       view.getPaddingRight(),</span><br><span class="line">                       view.getPaddingBottom());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件 handler 仅可用于只拥有一个抽象方法的接口或者抽象类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:onLayoutChange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setOnLayoutChangeListener</span><span class="params">(View view, View.OnLayoutChangeListener oldValue,</span></span><br><span class="line"><span class="params">       View.OnLayoutChangeListener newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnLayoutChangeListener(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnLayoutChangeListener(newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 listener 内置多个函数时，必须分割成多个 listener。例如，<a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html"><code>View.OnAttachStateChangeListener</code></a> 内置两个函数：<a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html#onViewAttachedToWindow(android.view.View)"><code>onViewAttachedToWindow()</code></a> 与 <a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html#onViewDetachedFromWindow(android.view.View)"><code>onViewDetachedFromWindow()</code></a>。在这里必须为两个不同的属性创建不同的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnViewDetachedFromWindow</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onViewDetachedFromWindow</span><span class="params">(View v)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnViewAttachedToWindow</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onViewAttachedToWindow</span><span class="params">(View v)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为改变一个 listener 会影响到另外一个，我们必须编写三个不同的 adapter，包括修改一个属性的，和修改两个属性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:onViewAttachedToWindow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">(View view, OnViewAttachedToWindow attached)</span> &#123;</span><br><span class="line">    setListener(view, <span class="literal">null</span>, attached);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BindingAdapter(&quot;android:onViewDetachedFromWindow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">(View view, OnViewDetachedFromWindow detached)</span> &#123;</span><br><span class="line">    setListener(view, detached, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BindingAdapter(&#123;&quot;android:onViewDetachedFromWindow&quot;, &quot;android:onViewAttachedToWindow&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">(View view, <span class="keyword">final</span> OnViewDetachedFromWindow detach,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> OnViewAttachedToWindow attach)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        <span class="keyword">final</span> OnAttachStateChangeListener newListener;</span><br><span class="line">        <span class="keyword">if</span> (detach == <span class="literal">null</span> &amp;&amp; attach == <span class="literal">null</span>) &#123;</span><br><span class="line">            newListener = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newListener = <span class="keyword">new</span> <span class="title class_">OnAttachStateChangeListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewAttachedToWindow</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (attach != <span class="literal">null</span>) &#123;</span><br><span class="line">                        attach.onViewAttachedToWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewDetachedFromWindow</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (detach != <span class="literal">null</span>) &#123;</span><br><span class="line">                        detach.onViewDetachedFromWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">OnAttachStateChangeListener</span> <span class="variable">oldListener</span> <span class="operator">=</span> ListenerUtil.trackListener(view,</span><br><span class="line">                newListener, R.id.onAttachStateChangeListener);</span><br><span class="line">        <span class="keyword">if</span> (oldListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子比普通情况下复杂，因为 View 是 add&#x2F;remove <a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html"><code>View.OnAttachStateChangeListener</code></a> 而不是 set。<code>android.databinding.adapters.ListenerUtil</code> 可以用来辅助跟踪旧的 listener 并移除它。</p><p>对应 <a href="http://developer.android.com/reference/android/view/View.html#addOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener)"><code>addOnAttachStateChangeListener(View.OnAttachStateChangeListener)</code></a> 支持的 api 版本，通过向 <code>OnViewDetachedFromWindow</code> 和 <code>OnViewAttachedToWindow</code> 添加 <code>@TargetApi(VERSION_CODES.HONEYCHOMB_MR1)</code> 注解，data binding 代码生成器会知道这些 listener 只会在 Honeycomb MR1 或更新的设备上使用。</p><p>（完）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Binding学习笔记——Data Objects</title>
      <link href="/2017-08-21/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Data-Objects/"/>
      <url>/2017-08-21/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Data-Objects/</url>
      
        <content type="html"><![CDATA[<p>关于 Data Binding 的基本使用在上一篇文章中已经做了总结，接下来会着重介绍下 Data Binding 库中个人认为最重要的两个特性：<strong>Data Objects</strong>与<strong>Attribute Setters</strong>。前者是真正能让我们实现<code>数据-UI</code>双向绑定的关键；后者则为我们提供了自定义 UI 控件数据绑定的可能性。</p><p>当然，至于 Data Binding 其他的特性诸如<code>自定义Binding Class命名</code>、<code>Views with IDs</code>（此特性可以完全取代<code>Butterknife</code>啦）等，查阅<a href="https://developer.android.google.cn/topic/libraries/data-binding">官方文档</a>可以了。</p><h2 id="Data-Objects（数据对象）"><a href="#Data-Objects（数据对象）" class="headerlink" title="Data Objects（数据对象）"></a>Data Objects（数据对象）</h2><p>之前介绍的基本使用中，我们定义的 model 类对象虽然能够绑定对应的 UI 并显示数据，但是修改了对象的属性并不会更新 UI。为此，Data Binding 提供了三种不同的数据变动通知机制： <code>observable objects</code> 、<code>observable fields</code> 和 <code>observable collection</code> 。</p><p>当以上的 observable 对象绑定在 UI 上，数据发生变化时，UI 就会同步更新。</p><h3 id="1-observable-objects"><a href="#1-observable-objects" class="headerlink" title="1. observable objects"></a>1. observable objects</h3><p>此种方法其实就是让我们定义的 model 类继承一个基类 <code>BaseObservable</code> ，这个类是 <code>Observable</code> （Data Binding 中的）接口的实现类，内部也就是基于观察者模式的一套添加&#x2F;移除 listener 的机制。<code>BaseObservable</code> 帮我们实现了 listener 的注册，但是我们需要在 <code>getter</code> 使用 <code>Bindable</code> 注解，并在 <code>setter</code> 中调用方法去发通知。例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">BaseObservable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String firstName;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">   <span class="meta">@Bindable</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Bindable</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">       notifyPropertyChanged(BR.firstName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">       notifyPropertyChanged(BR.lastName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bindable</code> 注解会在编译时在 BR 类内生成一个元素（比如上面代码中的 <code>BR.firstName</code> ）。</p><p>个人总结：如果一个 model 类的属性有很多，或者是想在原有项目中引入 <code>Data Binding</code> 的话，使用此方法的编写和改动的工作量还是有点繁琐。（不知道有没有开发者已经提供了一键生成的 AS 插件 😏）</p><h3 id="2-observable-fields"><a href="#2-observable-fields" class="headerlink" title="2. observable fields"></a>2. observable fields</h3><p>我们还可以使用 <code>ObservableField</code> 及它的派生比如 <code>ObservableInt</code> 、 <code>ObservableBoolean</code> 等作为 model 的数据类型。我们只要在数据类中创建一个 public final 域即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName =</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">ObservableField</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName =</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">ObservableField</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">ObservableInt</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObservableInt</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后要存取数据的话，只需要使用 <code>ObservableField</code> 中的 <code>get</code> 、 <code>set</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> user.age.get();</span><br></pre></td></tr></table></figure><p>个人总结：相比第一种方法，代码编写更方便省时，缺点就是：1、数据类的 <code>field</code> 如果很多的话，写起来还是麻烦；2、一般我们都会用到 <code>FastJson</code> 配合 <code>Retrofit</code> 来做 API 请求，结果直接返回给我们对应直接转化好的 model 类对象，所以不太可能直接运用在原本项目中的 model 类中。参考 google 的 <code>todo-mvvm-databinding</code> 中可以发现，原本的 model 类还是不动，每个页面都有一个 <code>ViewModel</code> 类，用于存放该页面中所有的数据对象，都是 <code>ObservableField</code> 相关的类型。</p><h3 id="3-observable-collections"><a href="#3-observable-collections" class="headerlink" title="3. observable collections"></a>3. observable collections</h3><p>顾名思义，就是 observable 容器类，个人认为也算是上面一种。</p><p>比如使用 <code>ObservableArrayMap</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">ObservableArrayMap</span>&lt;&gt;();</span><br><span class="line">user.put(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Inc.&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;age&quot;</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>在 xml 中，可以用 String 类型的 key 来获取 map 中的数据：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;android.databinding.ObservableMap&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ObservableMap<span class="symbol">&amp;lt;</span>String, Object<span class="symbol">&amp;gt;</span>&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">…</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TextView</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:text</span>=<span class="string">&#x27;@</span></span></span><span class="template-variable">&#123;user[&quot;lastName&quot;]&#125;</span><span class="language-xml"><span class="tag"><span class="string">&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TextView</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:text</span>=<span class="string">&#x27;@</span></span></span><span class="template-variable">&#123;String.valueOf(1 + (Integer)user[&quot;age&quot;])&#125;</span><span class="language-xml"><span class="tag"><span class="string">&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>当 key 是 int 类型还可以使用 <code>ObservableArrayList</code>，使用的话和 <code>ArrayList</code> 没啥却别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayList&lt;Object&gt; user = <span class="keyword">new</span> <span class="title class_">ObservableArrayList</span>&lt;&gt;();</span><br><span class="line">user.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">user.add(<span class="string">&quot;Inc.&quot;</span>);</span><br><span class="line">user.add(<span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>xml 中就是通过下标来获取数据，就不贴代码了 😁。</p><hr><p>先写到这，下篇再总结<strong>Attribute Setters</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Binding学习笔记——基本使用</title>
      <link href="/2017-08-16/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2017-08-16/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Data Binding 是 google 推出的布局与数据做双向绑定的库。它是一个 support library，可以在 <strong>Android 2.1</strong> (API level 7+)以上的平台使用，同时 Android Plugin for Gradle 的版本必须是 <strong>1.5.0-alpha1</strong> 以上。</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>在<code>build.gradle</code>中添加：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">    <span class="operator">....</span></span><br><span class="line">    <span class="keyword">dataBinding</span> &#123;</span><br><span class="line">        enabled <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点要注意，如果 library 项目中使用了 data binding，app 项目必须也得在<code>build.gradle</code>中声明以上配置。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>这里分三部分来讲解：1、model 类；2、布局文件；3、activity&#x2F;fragment</p><h3 id="model-类的定义"><a href="#model-类的定义" class="headerlink" title="model 类的定义"></a>model 类的定义</h3><p>定义一个 POJO（plain-old Java object），形如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> firstName;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> lastName;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="type">String</span> firstName, <span class="type">String</span> lastName)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">       <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h3><p>使用一个名为<code>layout</code>的根节点编写我们以往的 layout 文件，在<code>data</code>节点内声明我们要绑定的数据，比如：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:text</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;user.firstName&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:text</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;user.lastName&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到，在<code>data</code>节点内的<code>&lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; </code>描述了此 layout 文件要使用的 model，在<code>TextView</code>的使用形如<code>@&#123;user.firstName&#125; </code>来设置 text。</p><h3 id="activity-x2F-fragment"><a href="#activity-x2F-fragment" class="headerlink" title="activity&#x2F;fragment"></a>activity&#x2F;fragment</h3><ul><li><strong>数据绑定</strong></li></ul><p>通常情况下，as 会根据我们刚才编写的 layout 文件自动生成一个 Binding class，如果 layout 文件为<code>activity_main.xml</code>，则生成的 class 就命名为<code>ActivityMainBinding</code>。然后我们需要在代码中使用这个类来做数据绑定：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;</span><br><span class="line">   super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;</span><br><span class="line">   MainActivityBinding binding = <span class="module-access"><span class="module"><span class="identifier">DataBindingUtil</span>.</span></span>set<span class="constructor">ContentView(<span class="params">this</span>, R.<span class="params">layout</span>.<span class="params">main_activity</span>)</span>;</span><br><span class="line">   <span class="comment">//or</span></span><br><span class="line">   <span class="comment">//MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());</span></span><br><span class="line">   User user = <span class="keyword">new</span> <span class="constructor">User(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;User&quot;</span>)</span>;</span><br><span class="line">   binding.set<span class="constructor">User(<span class="params">user</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们是在 ListView 或 RecyclerView 的 adapter 中要使用 data binding，如下使用：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding <span class="keyword">binding</span> = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">ListItemBinding <span class="keyword">binding</span> = DataBindingUtil.inflate(layoutInflater, R.<span class="keyword">layout</span>.list_item, viewGroup, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>事件处理</strong></li></ul><p>Data Binding 提供了两种方式来做事件绑定和处理：<code>Method References</code>和<code>Listener Bindings</code>。</p><p>这两种方式最主要的区别在于：<code>Method References</code>是当数据被绑定时就创建了对应的 listener，而<code>Listener Bindings</code>则是当事件发生时创建。</p><p><strong>Method References</strong></p><p>定义一个用来处理事件的类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onClickFriend</span>(<span class="params">View view</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout 文件中：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;handlers&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.MyHandlers&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:text</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;user.firstName&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:onClick</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;handlers::onClickFriend&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>此方式必须保证<strong>类中的方法签名和对应 listener 的签名保持一致</strong>，否则在编译期间会报错。</p><p><strong>Listener Bindings</strong></p><p>此种方式和<code>method references</code>类似，也是定义一个类来处理事件，区别是在 xml 中使用 lambda 表达式来声明，而且只需要类的返回类型和 listener 一致即可。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Presenter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">onSaveClick</span><span class="params">(View view, <span class="built_in">Task</span> task)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;task&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.android.example.Task&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;presenter&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.android.example.Presenter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">android:onClick</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;(v) -&gt; presenter.onSaveClick(v, task)&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果要在表达式中使用断言，我们可以使用<code>void</code>作为一个符号：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>onClick=<span class="string">&quot;@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;&quot;</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文章：<br><a href="http://yanghui.name/blog/2016/02/17/data-binding-guide/">http://yanghui.name/blog/2016/02/17/data-binding-guide/</a> &gt; <a href="https://developer.android.google.cn/topic/libraries/data-binding/index.html">https://developer.android.google.cn/topic/libraries/data-binding/index.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《穿越计算机的迷雾》读书笔记</title>
      <link href="/2017-06-22/%E3%80%8A%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2017-06-22/%E3%80%8A%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-4-电流是怎样形成的"><a href="#1-4-电流是怎样形成的" class="headerlink" title="1.4 电流是怎样形成的"></a>1.4 电流是怎样形成的</h4><p>电压的存在是导致电流产生的原因</p><p>通常，衡量一个电源的重要指标是它的电压，也就是它产生电的能力。不同的电源，所提供的电压也不相同。</p><h4 id="2-3-二进制数就是比特串"><a href="#2-3-二进制数就是比特串" class="headerlink" title="2.3 二进制数就是比特串"></a>2.3 二进制数就是比特串</h4><p>对于单个的二进制数位，它们都只有一个称呼“比特”，每个比特具有两个可能的值：0 或者 1。</p><h4 id="3-3-使用全加器来构造加法机"><a href="#3-3-使用全加器来构造加法机" class="headerlink" title="3.3 使用全加器来构造加法机"></a>3.3 使用全加器来构造加法机</h4><p>为了表明这个电路的用途，我们在图的中间加了一个符号“∑”。在数学中，这个符号用来表示“加”，它的读音是“西格马”。</p><h4 id="4-5-爱迪生大战交流电"><a href="#4-5-爱迪生大战交流电" class="headerlink" title="4.5 爱迪生大战交流电"></a>4.5 爱迪生大战交流电</h4><p>与直流电不同，交流电的方向和大小都是不断变化的。要想了解直流电和交流电之间有哪些不同，使用图形可能是最直观的方法，也是工程上常用的方法。</p><h4 id="7-2-反馈和振荡器"><a href="#7-2-反馈和振荡器" class="headerlink" title="7.2 反馈和振荡器"></a>7.2 反馈和振荡器</h4><p>把一个非门的输出取出一部分来，同时又作为它的输入，这样就形成了一个反馈。</p><p>一个非门，再加上反馈之后，就能产生一连串交替变化的输出，使得与之相连的灯泡一亮一灭，很像一把振动的直尺或一个来回游荡的秋千，在两个端点之间来回运动。作为一种类比，像这种东西，在电子技术领域里叫做振荡器。</p><p>如果每秒出现 5 个脉冲，那么频率就是 5Hz，周期为 0.2 秒。</p><h4 id="7-3-电子管时代"><a href="#7-3-电子管时代" class="headerlink" title="7.3 电子管时代"></a>7.3 电子管时代</h4><p>发明振荡器，最早的目的是为了向天空中扬撒电磁波。在 20 世纪之前人们就知道，要想产生电磁波，必须使电流以极高的速度不断变化，而要产生高速变化的电流，振荡器可以做到这一点。</p><p>电子三极管的放大效果不是无端地凭空产生的，这个放大后的能量来自于电源，它只是一个转换器。</p><h4 id="7-4-记忆力非凡的触发器"><a href="#7-4-记忆力非凡的触发器" class="headerlink" title="7.4 记忆力非凡的触发器"></a>7.4 记忆力非凡的触发器</h4><p>我做了一件事，写了一些东西，加上了读者的反馈之后，触发了一连串的事情，产生了完全不同的结果。也正是因为这样，我们刚刚讲的这个电路，称为触发器。</p><h4 id="8-1-能保存一个比特的触发器"><a href="#8-1-能保存一个比特的触发器" class="headerlink" title="8.1 能保存一个比特的触发器"></a>8.1 能保存一个比特的触发器</h4><p>普通的电路，以及常规的逻辑门都有一个共性，那就是输出直接依赖于输入，当输入消失的时候，输出也跟着不存在了。触发器不同，当它触发的时候，输出会发生变化。但是，当输入撤销之后，输出依然能够维持。</p><h4 id="8-3-揭开走马灯之谜"><a href="#8-3-揭开走马灯之谜" class="headerlink" title="8.3 揭开走马灯之谜"></a>8.3 揭开走马灯之谜</h4><p>不把振荡器和灯泡算在内，一个走马灯电路通常称为循环移位寄存器。所谓“寄存”的意思是临时存放，就像火车站旁边的物品寄存处。俗话说“铁打的营盘流水的兵”，触发器随时会根据需要而保存新的比特（如果你希望得到一个不变的 0 和 1，干吗还要使用触发器），仿佛这些比特都是临时寄存在触发器里。当若干个触发器组合在一起，可以同时保存许多比特时，就称为寄存器。</p><h4 id="9-2-晶体管时代"><a href="#9-2-晶体管时代" class="headerlink" title="9.2 晶体管时代"></a>9.2 晶体管时代</h4><p>因为硅和锗是晶体，所以这个具有单向导电性的装置就叫晶体二极管。</p><p>在发明晶体二极管没多久，人们就发现如果在半导体中掺入砷、镓等原子，制作出来的晶体二极管就会发光，称为发光二极管（LED）</p><p>也就是说，这个新的半导体材料像电子三极管一样，具有放大作用。相应的，它被称为晶体三极管。</p><h4 id="10-1-把一大堆数加起来"><a href="#10-1-把一大堆数加起来" class="headerlink" title="10.1 把一大堆数加起来"></a>10.1 把一大堆数加起来</h4><p>在逻辑电路里，大家共用的公共线路称为总线。</p><h4 id="11-1-咸鸭蛋坛子和存储器"><a href="#11-1-咸鸭蛋坛子和存储器" class="headerlink" title="11.1 咸鸭蛋坛子和存储器"></a>11.1 咸鸭蛋坛子和存储器</h4><p>我们这个存储器，你可以随机地、任意地决定访问哪个存储单元，不管访问哪个存储单元，所花的时间都一样，和地址没有关系。正是因为这样，我们通常称之为“随机访问存储器”，或者“自由存取存储器”，用英文来说就是 Random Access Memory，简称 RAM。由于组成它的细胞是触发器，而这种东西就怕断电，不管它记下的是什么，只要一断电就全完蛋了，因此属于易失性存储器。</p><h4 id="11-5-全自动计算"><a href="#11-5-全自动计算" class="headerlink" title="11.5 全自动计算"></a>11.5 全自动计算</h4><p>计算机要想可靠地工作，指令的正确性至关重要。在存储器里，指令和普通的二进制数没有区别，但它们却有着独特的含义和用途。指令的数量是有限的，所以并非任意一个二进制比特串都代表一条指令。比如，1000100100 可能是某台计算机的一条指令，但 1000011110 则可能不是。如果计算机执行了并非指令的“指令”，指令译码器将不能输出正确的信号给控制器，整个计算机也就瘫痪了。</p><h4 id="12-1-更多的计算机指令"><a href="#12-1-更多的计算机指令" class="headerlink" title="12.1 更多的计算机指令"></a>12.1 更多的计算机指令</h4><p>从程序员的角度来看，这台机器的内部构造是次要的。在他们眼里，这台机器只有三样东西有价值。第一样，是存储器，因为他们需要在这里编程；第二样，是加法器，因为它是数学计算实际进行的地方，是扑克牌里的皇后。最后一样对程序员来说尤其重要，它就是寄存器 RA。原因很简单，他们可以不知道指令是怎么执行的，但绝对要知道机器把执行的结果放到哪里了。</p><h4 id="12-3-现代计算机的大体特征"><a href="#12-3-现代计算机的大体特征" class="headerlink" title="12.3 现代计算机的大体特征"></a>12.3 现代计算机的大体特征</h4><p>字长表示一台计算机在一次操作中可以处理的二进制比特数。换句话说，就是每个寄存器可以保存的二进制数是几个比特，或者加法器每次计算的二进制数是几个比特。原则上，对计算机的字长没有任何规定和限制，4 比特、6 比特、20 比特，等等，都是可以的。</p><p>任意两个寄存器之间，或者寄存器和存储单元之间，都可以互相装载数据。</p><p>现代计算机还会根据一条指令的执行情况产生各种标志，比如我们已经熟悉的进位标志。其他的标志还包括计算结果为 0、结果中 1 的个数为奇数&#x2F;偶数，等等。这些标志可以用于跳转指令，或者其他想要参考这些标志的指令。</p><p>对于任何一种类型的计算机来说，它的指令在种类和数量上都是有限的，但是不管有多少，它所能执行的所有指令，称为这种计算机的指令集。</p><h4 id="13-3-流水线和高速缓存技术"><a href="#13-3-流水线和高速缓存技术" class="headerlink" title="13.3 流水线和高速缓存技术"></a>13.3 流水线和高速缓存技术</h4><p>为了加以区分，和中央处理器最近的存储器通常称为主存储器，或者内存储器，简称内存。</p><p>除了流水线，另一个被用来平衡处理器和内存速度的手段是使用高速缓存技术，字面上的意思是速度很快的缓冲存储器。类似于蓄水池，这种技术基于计算机运行的一个特点——局部性。通俗地说，局部性的意思是，程序在被执行的过程中常常会访问最近刚刚访问过的数据，或者该位置附近的数据。</p><h4 id="13-4-掌上游戏机和手机就是计算机"><a href="#13-4-掌上游戏机和手机就是计算机" class="headerlink" title="13.4 掌上游戏机和手机就是计算机"></a>13.4 掌上游戏机和手机就是计算机</h4><p>不管任何东西，只要稍微有一点智能的——从录音笔、微波炉调温装置、电冰箱，再到电子表、手机和游戏机，都需要用到微处理器和一小块内存储器，也需要一些编排精巧的指令。你能说，那些大家伙叫计算机，而这些东西就不叫计算机吗？</p><h4 id="14-1-计算机同外部的接口"><a href="#14-1-计算机同外部的接口" class="headerlink" title="14.1 计算机同外部的接口"></a>14.1 计算机同外部的接口</h4><p>为了在外部设备和计算机核心之间传送数据，需要在这两者之间连线，并构造逻辑电路。在逻辑电路里，有一些寄存器，通常称之为 I&#x2F;O 端口，或直接称为端口。当中央处理器有话要对外部设备说时，就把它放在端口上，由后者取走；当外部设备也有话要跟中央处理器说时，也照此办理。从形式上看，端口类似于企事业单位门口的传达室。</p><h4 id="15-1-打开电源并启动计算机"><a href="#15-1-打开电源并启动计算机" class="headerlink" title="15.1 打开电源并启动计算机"></a>15.1 打开电源并启动计算机</h4><p>除了加电自检指令，ROM 中还包含一些访问外部设备的指令，我们可以用这些指令来访问设备而不必亲自编写，因为我们可能不熟悉如何与这些设备打交道。传统上，这就是设备驱动程序。</p><p>同时，这些设备驱动程序仅仅提供最基本的功能，以保守的方式使用对应的外部设备。正因为如此，该 ROM 更多地被称为基本输入&#x2F;输出系统 BIOS（Basic Input&#x2F;Output System）。</p><h4 id="15-4-操作系统的功能"><a href="#15-4-操作系统的功能" class="headerlink" title="15.4 操作系统的功能"></a>15.4 操作系统的功能</h4><p>多用户和多任务是依靠处理器和操作系统共同完成的，前者提供像中断这样的硬件支持；后者则在软件上予以配合和扩展。</p><h4 id="16-3-图像、音乐和视频"><a href="#16-3-图像、音乐和视频" class="headerlink" title="16.3 图像、音乐和视频"></a>16.3 图像、音乐和视频</h4><p>经过 MPEG 压缩后，组成视频的帧不再是传统意义上的静止图像那么简单。事实上，这些帧分为三种。第一种是参考帧，它是独立的，理论上包含完整的画面信息；后面两种类型的帧是不完整的，不能独立存在，要依赖于前面的帧、后面的帧，或者参考帧。最后，MPEG 的压缩比可以达到 150:1。一般来说，能达到 90:1 已经算是不错。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《图解HTTP》读书笔记</title>
      <link href="/2017-04-03/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2017-04-03/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-3-网络基础-TCP-x2F-IP"><a href="#1-3-网络基础-TCP-x2F-IP" class="headerlink" title="1.3 网络基础 TCP&#x2F;IP"></a>1.3 网络基础 TCP&#x2F;IP</h4><p>通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。</p><p>TCP&#x2F;IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。</p><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装（encapsulate）。</p><h4 id="1-4-与-HTTP-关系密切的协议-IP、TCP-和-DNS"><a href="#1-4-与-HTTP-关系密切的协议-IP、TCP-和-DNS" class="headerlink" title="1.4 与 HTTP 关系密切的协议 : IP、TCP 和 DNS"></a>1.4 与 HTTP 关系密切的协议 : IP、TCP 和 DNS</h4><p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略</p><h4 id="1-7-URI-和-URL"><a href="#1-7-URI-和-URL" class="headerlink" title="1.7 URI 和 URL"></a>1.7 URI 和 URL</h4><p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。</p><h4 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2 通过请求和响应的交换达成通信"></a>2.2 通过请求和响应的交换达成通信</h4><p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p><p>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p><h4 id="2-3-HTTP-是不保存状态的协议"><a href="#2-3-HTTP-是不保存状态的协议" class="headerlink" title="2.3 HTTP 是不保存状态的协议"></a>2.3 HTTP 是不保存状态的协议</h4><p>HTTP&#x2F;1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h4 id="2-7-持久连接节省通信量"><a href="#2-7-持久连接节省通信量" class="headerlink" title="2.7 持久连接节省通信量"></a>2.7 持久连接节省通信量</h4><p>为解决上述 TCP 连接的问题，HTTP&#x2F;1.1 和一部分的 HTTP&#x2F;1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><h4 id="2-8-使用-Cookie-的状态管理"><a href="#2-8-使用-Cookie-的状态管理" class="headerlink" title="2.8 使用 Cookie 的状态管理"></a>2.8 使用 Cookie 的状态管理</h4><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><h4 id="5-2-通信数据转发程序-：代理、网关、隧道"><a href="#5-2-通信数据转发程序-：代理、网关、隧道" class="headerlink" title="5.2 通信数据转发程序 ：代理、网关、隧道"></a>5.2 通信数据转发程序 ：代理、网关、隧道</h4><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</p><p>隧道的目的是确保客户端能与服务器进行安全的通信。</p><h4 id="6-2-HTTP-首部字段"><a href="#6-2-HTTP-首部字段" class="headerlink" title="6.2 HTTP 首部字段"></a>6.2 HTTP 首部字段</h4><p>若 HTTP 首部字段重复了会如何<br>当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。</p><h4 id="6-3-HTTP-x2F-1-1-通用首部字段"><a href="#6-3-HTTP-x2F-1-1-通用首部字段" class="headerlink" title="6.3 HTTP&#x2F;1.1 通用首部字段"></a>6.3 HTTP&#x2F;1.1 通用首部字段</h4><p>应用 HTTP&#x2F;1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP&#x2F;1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。</p><p>Connection 首部字段具备如下两个作用。<br>控制不再转发给代理的首部字段<br>管理持久连接</p><p>控制不再转发给代理的首部字段</p><p>所有的中间服务器如果都能以 HTTP&#x2F;1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段</p><p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP&#x2F;1.1 版本分块传输编码时。</p><h4 id="6-4-请求首部字段"><a href="#6-4-请求首部字段" class="headerlink" title="6.4 请求首部字段"></a>6.4 请求首部字段</h4><p>Host 首部字段在 HTTP&#x2F;1.1 规范内是唯一一个必须被包含在请求内的首部字段。</p><h4 id="6-6-实体首部字段"><a href="#6-6-实体首部字段" class="headerlink" title="6.6 实体首部字段"></a>6.6 实体首部字段</h4><p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段</p><p>当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。</p><h4 id="7-1-HTTP-的缺点"><a href="#7-1-HTTP-的缺点" class="headerlink" title="7.1 HTTP 的缺点"></a>7.1 HTTP 的缺点</h4><p>一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。<br>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p><h4 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP+ 加密 + 认证 + 完整性保护 &#x3D;HTTPS"></a>7.2 HTTP+ 加密 + 认证 + 完整性保护 &#x3D;HTTPS</h4><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p><h4 id="8-3-DIGEST-认证"><a href="#8-3-DIGEST-认证" class="headerlink" title="8.3 DIGEST 认证"></a>8.3 DIGEST 认证</h4><p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p><h4 id="8-4-SSL-客户端认证"><a href="#8-4-SSL-客户端认证" class="headerlink" title="8.4 SSL 客户端认证"></a>8.4 SSL 客户端认证</h4><p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p><h4 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h4><p>基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话）。</p><h4 id="9-2-消除-HTTP-瓶颈的-SPDY"><a href="#9-2-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="9.2 消除 HTTP 瓶颈的 SPDY"></a>9.2 消除 HTTP 瓶颈的 SPDY</h4><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><h4 id="9-3-使用浏览器进行全双工通信的-WebSocket"><a href="#9-3-使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="9.3 使用浏览器进行全双工通信的 WebSocket"></a>9.3 使用浏览器进行全双工通信的 WebSocket</h4><p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。</p><h4 id="10-2-动态-HTML"><a href="#10-2-动态-HTML" class="headerlink" title="10.2 动态 HTML"></a>10.2 动态 HTML</h4><p>动态 HTML 技术是通过调用客户端脚本语言 JavaScript，实现对 HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。</p><p>DOM 是用以操作 HTML 文档和 XML 文档的 API（Application Programming Interface，应用编程接口）。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。</p><h4 id="11-1-针对-Web-的攻击技术"><a href="#11-1-针对-Web-的攻击技术" class="headerlink" title="11.1 针对 Web 的攻击技术"></a>11.1 针对 Web 的攻击技术</h4><p>主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。</p><p>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p><h4 id="11-2-因输出值转义不完全引发的安全漏洞"><a href="#11-2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="11.2 因输出值转义不完全引发的安全漏洞"></a>11.2 因输出值转义不完全引发的安全漏洞</h4><p>跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。</p><p>OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。</p><p>HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p><h4 id="11-5-其他安全漏洞"><a href="#11-5-其他安全漏洞" class="headerlink" title="11.5 其他安全漏洞"></a>11.5 其他安全漏洞</h4><p>彩虹表（Rainbow Table）是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法 • 字典攻击等实际破解过程中缩短消耗时间的技巧。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Android Library需要注意的细节</title>
      <link href="/2016-11-07/%E5%85%B3%E4%BA%8EAndroid%20Library%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>/2016-11-07/%E5%85%B3%E4%BA%8EAndroid%20Library%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设置库的资源为私有"><a href="#1-设置库的资源为私有" class="headerlink" title="1. 设置库的资源为私有"></a>1. 设置库的资源为私有</h2><p>我们都知道，库中的所有资源（res&#x2F;目录的所有文件）在默认情况下均处于公开状态。如果不希望库的使用者访问这些资源，我们必须通过<strong>声明一个或多个公开资源的方式来</strong>使用这种自动私有标识机制。</p><p>具体做法：</p><p>在库的 <code>res/value/</code> 目录下创建 <code>public.xml</code> 文件，添加 <code>mylib_app_name</code> 和 <code>mylib_public_string</code> 为公开字符串资源。使用库的模块如果尝试引用库中的其他资源时，Lint 会显示警告信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">&quot;mylib_app_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">&quot;mylib_public_string&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时，我们可以参考 v7 appcompat 库中的 <code>res-public/values/public_layouts.xml</code> ，就声明了 <code>support_simple_spinner_dropdown_item.layout</code> 是允许库使用者去访问的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Definitions of layouts to be exposed as public --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">type</span>=<span class="string">&quot;layout&quot;</span> <span class="attr">name</span>=<span class="string">&quot;support_simple_spinner_dropdown_item&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-app-模块的-minSdkVersion-必须大于或等于库定义的版本"><a href="#2-app-模块的-minSdkVersion-必须大于或等于库定义的版本" class="headerlink" title="2. app 模块的 minSdkVersion 必须大于或等于库定义的版本"></a>2. app 模块的 <code>minSdkVersion</code> 必须大于或等于库定义的版本</h2><p>库作为相关应用模块的一部分编译，因此，库模块中使用的 API 必须与应用模块支持的平台版本兼容。</p><h2 id="3-库模块如何使用自己的混淆配置文件"><a href="#3-库模块如何使用自己的混淆配置文件" class="headerlink" title="3. 库模块如何使用自己的混淆配置文件"></a>3. 库模块如何使用自己的混淆配置文件</h2><p>这个也算是我们平时开发过程当中的一直没搞明白的问题。因为之前库模块的混淆配置想当然的以为和 app 模块相同，实则不然，当时也没有找到解决办法，导致目前我们项目所有的混淆配置都写在 app 模块下的 <code>proguard-rules.pro</code> 。</p><p>其实我们是可以分别针对库做混淆配置的，在将库添加到 app 模块时，库的 ProGuard 文件是会附加至 app 模块的 ProGuard 配置文件 (proguard.txt)。</p><p>首先，以下配置<strong>只在 app 模块下有效</strong>，在库模块中是<strong>没有用的</strong>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="literal">true</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要指定库的混淆配置文件名称，例如，以下代码段会将 <code>lib-proguard-rules.txt</code> 设置为库的 ProGuard 配置文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        consumerProguardFiles <span class="string">&#x27;lib-proguard-rules.txt&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此这般，我们就不需要再将库中的混淆配置写到 app 模块的 <code>proguard-rules.pro</code> 了！</p><h2 id="4-app-模块无论-debug、release-构建下，默认都是使用库的-release-构建类型"><a href="#4-app-模块无论-debug、release-构建下，默认都是使用库的-release-构建类型" class="headerlink" title="4. app 模块无论 debug、release 构建下，默认都是使用库的 release 构建类型"></a>4. app 模块无论 debug、release 构建下，默认都是使用库的 release 构建类型</h2><p>如果要让 app 模块使用库中不同的构建类型咋办？</p><p>1）首先在库的<code>build.gradle</code>的<code>android</code>块内添加以下代码，将此库的非发布配置展示给使用它的项目：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    publishNonDefault <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在 app 模块的<code>build.gradle</code>中添加以下代码段使应用在 debug 构建时使用库的 debug 构建类型，release 构建时使用库的 release 构建类型：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    debugCompile project(<span class="attr">path:</span> <span class="string">&#x27;:library&#x27;</span>, <span class="attr">configuration:</span> <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    releaseCompile project(<span class="attr">path:</span> <span class="string">&#x27;:library&#x27;</span>, <span class="attr">configuration:</span> <span class="string">&#x27;release&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文章<br><a href="https://developer.android.google.cn/studio/projects/android-library.html">https://developer.android.google.cn/studio/projects/android-library.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android性能优化中的16ms问题(转)</title>
      <link href="/2016-10-26/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%AD%E7%9A%8416ms%E9%97%AE%E9%A2%98(%E8%BD%AC)/"/>
      <url>/2016-10-26/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%AD%E7%9A%8416ms%E9%97%AE%E9%A2%98(%E8%BD%AC)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：<a href="http://www.jianshu.com/p/a769a6028e51">http://www.jianshu.com/p/a769a6028e51</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android 应用有一个明显的趋势—越来越多地使用动画效果来提升用户体验。但任何事情都是有代价的，丰富复杂的动画提升用户体验的同时，性能问题像隐形的恶魔一样，逐渐地侵蚀着你的应用。动画不流畅、界面卡顿开始困扰着你，逼着你进行性能优化。在这个优化过程中，最理想的标准就是绘制一帧的时间不要超过 16ms。这是什么意思？让我们一探究竟。</p><h3 id="屏幕刷新频率"><a href="#屏幕刷新频率" class="headerlink" title="屏幕刷新频率"></a>屏幕刷新频率</h3><p>我们知道，手机屏幕是由许多的像素点组成的，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1371984-728f8eb8a3d92a60.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>通过让每一个像素点显示不同的颜色，可以组合成各种各样的图像。这些像素点的颜色数据从哪里来？</p><p>答案是：在 GPU 控制的一块缓冲区中，这块缓冲区叫做 <strong>Frame Buffer</strong>（也就是帧缓冲区）。你可以把它简单理解成一个二维数组，数组中的每一个元素对应着手机屏幕上的一个像素点，元素的值代表着屏幕上对应的像素点要显示的颜色。</p><p><strong>Frame Buffer 中的数据是不断变化的</strong>，为了应对这种变化，手机屏幕的逻辑电路会<strong>定期用 Frame Buffer 中的数据刷新屏幕上的像素点</strong>。目前，主流的刷新频率是 60 次&#x2F;秒，折算出来就是 16ms 刷新一次。</p><h3 id="Frame-Buffer-中的数据怎么来"><a href="#Frame-Buffer-中的数据怎么来" class="headerlink" title="Frame Buffer 中的数据怎么来"></a>Frame Buffer 中的数据怎么来</h3><p>GPU 除了 Frame Buffer，用以交给手机屏幕进行绘制外，还有一个缓冲区，叫 <strong>Back Buffer</strong>，这个 Back Buffer 用以<strong>交给你的应用</strong>，让你往里面填充数据。<strong>GPU 会定期交换 Back Buffer 和 Frame Buffer</strong>，也就是让 Back Buffer 变成 Frame Buffer 交给屏幕进行绘制，让原先的 Frame Buffer 变成 Back Buffer 交给你的应用进行绘制。交换的频率也是 60 次&#x2F;秒，这就与屏幕硬件电路的刷新频率保持了同步。如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1371984-711eab01ad62cb5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="丢帧是怎么发生的"><a href="#丢帧是怎么发生的" class="headerlink" title="丢帧是怎么发生的"></a>丢帧是怎么发生的</h3><p>上面说 GPU 会定期交换 Back Buffer 和 Frame Buffer，但有一个例外情况，当你的应用正在往 Back Buffer 中填充数据时，系统会将 Back Buffer 锁定。如果到了 GPU 交换两个 Buffer 的时间点，你的应用还在往 Back Buffer 中填充数据，GPU 会发现 Back Buffer 被锁定了，它会放弃这次交换，后果就是手机屏幕仍然显示原先的图像。</p><p>最不幸的情况是，GPU 刚刚放弃这次交换，你的应用就完成了对 Back Buffer 的数据填充。可怜的你必须等待下一个 16ms 时间，才能看到这次数据填充的效果。</p><p>在这种情况下，从 Back Buffer 锁定开始，也就是你的应用开始往 Back Buffer 中填充数据，到填充后的数据展示到屏幕上，需要的时间是 32ms。</p><p>我们知道，所谓的应用往 Back Buffer 中填充数据，其实就是更新你的应用的 Activity 的界面。我们假设更新前后的界面是这样的：</p><p><img src="http://upload-images.jianshu.io/upload_images/1371984-94e8a090b86faa44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>很简单，也就是让红色的小球向上移动了一段距离。但由于你的应用没能在 16ms 内完成界面更新，导致你的用户盯着第一个屏幕看了 32ms，然后发现小球“跳”到了一个新的高度，而不是平滑地移动到了新的高度。</p><p>上面所说的情况称作“丢帧”。</p><h3 id="怎样优化应用避免丢帧"><a href="#怎样优化应用避免丢帧" class="headerlink" title="怎样优化应用避免丢帧"></a>怎样优化应用避免丢帧</h3><p>作为应用开发者，为了让用户有流畅的动画体验，我们优化的目标就是不要丢帧，也就是在动画进行的过程中，我们要确保更新一帧的时间不要超过 16ms。那么，怎样做才能尽可能接近这个目标呢？有如下几个 tips：</p><ul><li><p>减少视图层次，尽量使用扁平化的视图布局，如使用 RelativeLayout 代替多层嵌套的 LinearLayout。</p></li><li><p>减少不必要的 View 的 invalidate 调用。</p></li><li><p>去除 View 中不必要的 background，因为许多 background 并不会显示在最终的屏幕上。比如 ImageView， 假如它显示的图片填满了它的空间，你就没有必要给它设置一个背景色。</p></li></ul><p>以上是三个操作性很强的建议。好奇的你可能会问，这样做的理由是什么？</p><p>前面说过，系统将 Back Buffer 交给你的应用填充数据，实际过程是将 Back Buffer 锁定后，将一个指向它的引用交给你的应用，这个引用就是一个 Canvas 对象。你的应用获取这个 Canvas 对象 后，会按照视图层次从上往下遍历传给每一个 View，View 在 onDraw 方法 中接收到的 canvas 对象 就是它，如下：</p><pre><code>proteced void onDraw(Canvas canvas)</code></pre><p>View 用这个 canvas 对象 完成自己的绘制。每个 View 都完成自己的绘制后，才算完成了一帧的绘制。</p><p><strong>减少视图层次，可以减少传递 canvas 对象时间。</strong></p><p>同时，Android 提供的所有控件以及你自定义的控件，在 onDraw 方法 中都会调用 super.onDraw 方法，而在这个方法中会执行绘制 background 的操作，如果这个 background 最终不会显示，绘制它显然是在浪费时间。</p><p>关于第二点，减少不必要的 invalidate 调用，一方面是为了减少重绘，同时，也是为了配合 GPU，最大限度地利用好缓存，这里涉及到 GPU 的工作细节，不展开了。</p><p>明白了原理，该怎么做你心里就会有数，比如 <strong>在 onDraw 方法 中，减少创建对象，尤其是复杂的对象等，都是为了缩短绘制的时间。</strong></p><p>最后，你还应当明白，<strong>这 16ms 不是全给你绘制界面的</strong>，还有 layout、measure 呢，Android 的一些子系统也要占用这宝贵的 16ms 完成一些自己的任务，真正留给你绘制自己的界面的时间肯定是少于 16ms，你能做的就是尽可能减少自己的绘制时间。</p><p>好了，这篇文章中，我没有涉及 GPU 工作的细节，目的是在屏蔽底层技术实现的同时让每一个层次的 Android 开发者都能从整体上理解把握所谓的 16ms。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub的pull request相关要点</title>
      <link href="/2016-10-14/GitHub%E7%9A%84pull%20request%E7%9B%B8%E5%85%B3%E8%A6%81%E7%82%B9/"/>
      <url>/2016-10-14/GitHub%E7%9A%84pull%20request%E7%9B%B8%E5%85%B3%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ol><li><p>fork 原项目到自己仓库</p></li><li><p>拉取自己仓库中 fork 的项目</p><p><code>git clone 自己仓库地址</code></p></li><li><p>添加上游远程库的地址，否则无法追踪上游库的更新。这里指定上游库名为 upstream</p><p><code>git remote add upstream 远程库的地址</code></p></li><li><p>如果上游库有新的分支创建，自己仓库需要创建并切换到对应的分支。进行如下操作：</p><p><code>git fetch upstream</code> 下载上游库的所有变动</p><p><code>git checkout 远程仓库新创建的分支名</code> 此时分支对应的 remote 是上游库的</p><p><code>git push --set-upstream origin 分支名（可以保持和上游仓库一致）</code></p><p>此时你所在的分支的 remote 就是自己仓库的了。</p></li><li><p>开发，add，commit</p></li><li><p>拉取上游远程库的更新。可以参考<a href="http://blog.csdn.net/zhangdaiscott/article/details/17438153">http://blog.csdn.net/zhangdaiscott/article/details/17438153</a></p><p><code>git pull upstream 远程库的分支名</code></p></li><li><p>push 到自己仓库</p></li><li><p>发送 pull request</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-《Android开发进阶从小工到专家》读书笔记</title>
      <link href="/2016-09-25/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2016-09-25/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="3-1-Android-中的消息机制"><a href="#3-1-Android-中的消息机制" class="headerlink" title="3.1 Android 中的消息机制"></a>3.1 Android 中的消息机制</h4><ul><li>3.1.1 处理消息的手段——Handler、Looper 与 MessageQueue<br>在 Android 应用启动时，会默认有一个主线程（UI 线程），在这个线程中会关联一个消息队列，所有的操作都会被封装成消息然后交给主线程来处理。为了<strong>保证主线程不会主动退出</strong>，会将获取消息的操作放在一个死循环中，这样程序就相当于一直在执行死循环，因此不会退出。</li></ul><h4 id="3-2-Android-中的多线程"><a href="#3-2-Android-中的多线程" class="headerlink" title="3.2 Android 中的多线程"></a>3.2 Android 中的多线程</h4><ul><li><p>3.2.1 多线程的实现——Thread 和 Runnable<br>Thread 也是一个 Runnable，它实现了 Runnable 接口，在 Thread 类中有一个 Runnable 类型的 target 字段，代表要被执行在这个子线程中的任务。</p></li><li><p>3.2.3 与多线程相关的方法——Callable、Future 和 FutureTask</p><ol><li>**Callable<V>**：与 Runnable 的功能大致相似，不过它有一个泛型参数 V，该接口有一个返回值（V）的 call()函数。</li><li>**Future<V>**：为线程池制定了一个可管理的任务标准。提供了对 Runnable 或 Callable 任务的执行结果进行取消（cancel）、查询是否完成（isDone）、获取结果（get）、设置结果操作（set）。get 方法会阻塞，直到任务返回结果。</li><li><strong>FutureTask</strong>：是 Future<V>的实现类。实现了 RunnableFuture<V>，而 RunnableFuture<V>实现了 Runnable、Future<V>这两个接口。FutureTask 会像 Thread 包装 Runnable 那样对 Runnable 和 Callable<V>进行包装，Runnable 与 Callable 由构造函数注入。总的来说，FutureTask 既是 Future、Runnable，又包装了 Callable（如果是 Runnable 最终也会被转换为 Callable），它是两者的合体。</li></ol></li><li><p>3.2.4 构建服务器应用程序的有效方法——线程池<br><strong>线程池的使用准则</strong>：<br>线程池的最佳大小取决于可用<strong>处理器的数目</strong>以及<strong>工作队列中的任务的性质</strong>。若在一个具有 N 个处理器的系统上只有一个工作队列，其中全部是计算性质的任务，在线程池具有 N 或 N+1 个线程时一般会获得最大的 CPU 利用率；对于那些可能需要等待 I&#x2F;O 完成的任务（例如，从套接字读取 HTTP 请求的任务），需要让线程池的大小超过可用处理器的数目，因为并不是所有线程都一直在工作。</p></li><li><p>3.2.5 同步集合</p><ol><li><p>程序中的优化策略——CopyOnWriteArrayList<br>Copy-On-Write 是一种用于程序设计中的优化策略，基本思路：从多个线程共享一个列表，当某个线程想要修改这个列表的元素时，会把列表中的元素 Copy 一份，然后进行修改，修改完成后再将新的元素设置给这个列表。</p><ul><li>优点：可以对 CopyOnWrite 容器进行<strong>并发读，不需要加锁</strong>。</li><li>缺点：在添加、移除元素时占用的内存空间翻了一倍，以空间换时间。</li></ul></li></ol><p>从 JDK1.5 开始提供了两个使用 CopyOnWrite 机制实现的并发容器：CopyOnWriteArrayList，CopyOnWriteArraySet。</p><ol start="2"><li><p>提高并发效率——ConcurrentHashMap<br>HashTable 在竞争激烈的环境下效率低下的原因是：所有访问 HashTable 的线程都必须竞争同一把锁。假如<strong>容器里有多把锁</strong>，<strong>每一把锁用于锁容器其中一部分数据</strong>，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，这就是 ConcurrentHashMap 所使用的锁分段技术。当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p></li><li><p>有效的方法——BlockingQueue<br>BlockingQueue 在 JDK 中有多个实现：</p></li><li><p>ArrayBlockingQueue：数组实现的、线程安全的、有界的阻塞队列。按 FIFO 原则对元素进行排序。</p></li><li><p>LinkedBlockingQueue：单向链表实现的阻塞队列。FIFO。吞吐量通常高于基于数组的队列。</p></li><li><p>LinkedBlockingDeque：双向链表实现的双向并发阻塞队列。支持 FIFO、FILO。可以指定队列的容量，若不指定，默认容量大小为 Integer.MAX_VALUE。</p></li></ol></li><li><p>3.2.6 同步锁</p><ul><li>3.2.6.1 同步机制关键字——synchronized<br>同步方法：<code>public synchronized void method() &#123;...&#125;</code><br>同步块：<code>public void method() &#123; synchronized(this) &#123;...&#125; &#125;</code><br>同步 class 对象：<code>public void method() &#123; synchronized(Demo.class) &#123;...&#125; &#125;</code><br>同步静态方法：<code>public synchronized static void method() &#123;...&#125;</code></li></ul><p>前两种锁的是<strong>对象</strong>，后两种锁的是<strong>class 对象</strong>。对于锁 class 对象，它的作用是防止多个线程同时访问添加了 synchronized 锁的代码块；对于锁对象，作用是防止其他线程访问同一个对象中的 synchronized 代码块或函数。</p><ul><li>3.2.6.2 显示锁——ReetrantLock 与 Condition<br>与内置锁 synchronized 相比，（1）获取和释放的灵活性（2）轮循锁和定时锁（3）公平性</li></ul><p>常用形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReetrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock 必须在 finally 块中释放。而 synchronized，JVM 将确保锁会获得自动释放。</p><p>在 ReetrantLock 类中还有一个函数 newCondition()，该函数用于获取 Lock 上的一个条件，也就是说 Condition 是和 Lock 绑定的。<strong>Condition 用于实现线程间的通信，它是为了解决 Object.wait()、notify()、notifyAll()难以使用的问题。</strong></p><ul><li><p>通过 ReetrantLock 与 Condition 来实现一个简单的阻塞队列：p91</p></li><li><p>3.2.6.3 信号量 Semaphore<br>semaphore 是一个计数信号量，它的本质是一个“<strong>共享锁</strong>”。信号量维护了一个信号量许可集，线程可以通过调用 aquire()来获取信号量的许可。当信号量中有可用的许可时，线程能获取该许可（semaphore.acquire()）；否则线程必须等待，直到有可用的许可为止。线程可以通过 release()来释放它所持有的信号量许可。<br>示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">semaphore.acquire();</span><br><span class="line">System.out.println(<span class="string">&quot;剩余许可：&quot;</span> + semaphore.availablePermits());</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">剩余许可：1</span><br><span class="line">剩余许可：1</span><br><span class="line">剩余许可：0</span><br><span class="line">剩余许可：2</span><br><span class="line">剩余许可：1</span><br></pre></td></tr></table></figure><ul><li>3.2.6.4 循环栅栏 CyclicBarrier<br>CyclicBarrier 是一个同步辅助类，允许<strong>一组线程互相等待</strong>，直到到达某个公共屏障点。因为该 barrier<strong>在释放等待线程后可以重用</strong>，所以称它为循环的 barrier。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier mCyclicBarrier;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      mCyclicBarrier = <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(SIZE, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot; ---&gt;满足条件，执行特定操作。参与者：&quot;</span> + mCyclicBarrier.getParties());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//新建5个任务</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">WorkerThread</span>().start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">&quot;等待CyclicBarrier&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//将mCyclicBarrier的参与者数量加1</span></span><br><span class="line">              mCyclicBarrier.await();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (BrokenBarrierException | InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//mCyclicBarrier的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">0</span>等待<span class="variable">CyclicBarrier</span></span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">1</span>等待<span class="variable">CyclicBarrier</span></span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">2</span>等待<span class="variable">CyclicBarrier</span></span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">3</span>等待<span class="variable">CyclicBarrier</span></span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">4</span>等待<span class="variable">CyclicBarrier</span></span><br><span class="line"> <span class="operator">---&gt;</span>满足条件，执行特定操作。参与者：<span class="number">5</span></span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">4</span>继续执行</span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">0</span>继续执行</span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">1</span>继续执行</span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">2</span>继续执行</span><br><span class="line"><span class="built_in">Thread</span><span class="operator">-</span><span class="number">3</span>继续执行</span><br></pre></td></tr></table></figure><p>只有当 5 个线程都调用了 mCyclicBarrier 函数之后，后续的代码才会执行。例子中在 5 个函数都就位后首先会执行一个 Runnable，也就是 CyclicBarrier 构造函数的第二个参数。<br>由此可知，CyclicBarrier 实际上相当于可以用于多个线程等待，直到某个条件被满足。对于上述示例来说，这里的条件就是有指定个数的线程调用了 mCyclicBarrier.await()函数。</p><ul><li>3.2.6.5 闭锁 CountDownLatch<br>CountDownLatch 也是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待，直到条件被满足。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">LATCH_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(LATCH_SIZE);</span><br><span class="line">          <span class="comment">//新建5个任务</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; LATCH_SIZE; i++) &#123;</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">WorkerThread</span>(latch).start();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;主线程等待&quot;</span>);</span><br><span class="line">          <span class="comment">//主线程等待线程池中5个任务完成</span></span><br><span class="line">          latch.await();</span><br><span class="line">          System.out.println(<span class="string">&quot;主线程继续执行&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    CountDownLatch mLatch;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkerThread</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">        mLatch = latch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行操作&quot;</span>);</span><br><span class="line">            <span class="comment">//将CountDownLatch的数值减1</span></span><br><span class="line">            mLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主线程等待</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span>执行操作</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span>执行操作</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">2</span>执行操作</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">3</span>执行操作</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">4</span>执行操作</span><br><span class="line">主线程继续执行</span><br></pre></td></tr></table></figure><p>main 函数中创建了一个数量为 5 的 CountDownLatch 对象，任务创建、启动 5 个 WorkerThread 对象，然后调用 CountDownLactch 对象的 await 函数使主线程进入等待状态。当 5 个 WorkerThread 都调用了 CountDownLactch 对象的 countDown()后，主线程就会被唤醒。</p><p><strong>CountDownLatch 和 CyclicBarrier 的不同点</strong></p></li></ul><ol><li>CountDownLatch 的作用是允许 1 个或 N 个线程等待其他线程完成执行，而 CyclicBarrier 则是允许 N 个线程相互等待。</li><li>CountDownLatch 的计数器无法被重置，CyclicBarrier 的计数器可以被重置后使用，因此称为是循环的 barrier。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中如何将中文目录名改成英文</title>
      <link href="/2016-07-23/Linux%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%AD%E6%96%87%E7%9B%AE%E5%BD%95%E5%90%8D%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87/"/>
      <url>/2016-07-23/Linux%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%AD%E6%96%87%E7%9B%AE%E5%BD%95%E5%90%8D%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>为了使用起来方便，装了 ubuntu 中文版，自然在 home 文件里用户目录的“桌面”、“图片”、“视频”、“音乐”……都是中文的。</p><p>很多时候都喜欢在桌面上放一些要操作的文件，linux 里命令行操作又多，难免会用命令行操作桌面上的东西，那么就要 “cd 桌面”，打“桌面”的时候要输入法切换，麻烦……所以就想办法把用户目录下的路径改成英文，而其他的中文不变，方法如下：</p><p>打开终端，在终端中输入命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LANG=en_US</span><br><span class="line">xdg-user-dirs-gtk-update</span><br></pre></td></tr></table></figure><p>跳出对话框询问是否将目录转化为英文路径,同意并关闭.<br>在终端中输入命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LANG=zh_CN</span><br></pre></td></tr></table></figure><p>关闭终端，账号登出或重启，系统会提示是否把转化好的目录改回中文。选择不再提示，并取消修改。主目录的中文转英文就完成了~</p><hr><blockquote><p>参考自：<a href="http://www.cnblogs.com/belinda/p/4056042.html">http://www.cnblogs.com/belinda/p/4056042.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android应用监听前后台切换、熄屏</title>
      <link href="/2016-07-10/Android%E5%BA%94%E7%94%A8%E7%9B%91%E5%90%AC%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2%E3%80%81%E7%86%84%E5%B1%8F/"/>
      <url>/2016-07-10/Android%E5%BA%94%E7%94%A8%E7%9B%91%E5%90%AC%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2%E3%80%81%E7%86%84%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<p><em>首先确保你的应用最低支持的 API 版本为 14(Android 4.0 ICS)以上。</em></p><h2 id="应用切换至后台"><a href="#应用切换至后台" class="headerlink" title="应用切换至后台"></a>应用切换至后台</h2><p>调用<code>Application.onTrimMemory(int level)</code>，这个方法包含了一个等级叫<code>TRIM_MEMORY_UI_HIDDEN</code>，用于记录应用即将进入后台运行。</p><p>sample:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTrimMemory</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.onTrimMemory(level);</span><br><span class="line">          <span class="keyword">if</span> (level == TRIM_MEMORY_UI_HIDDEN) &#123;</span><br><span class="line">              isBackground = <span class="literal">true</span>;</span><br><span class="line">              notifyBackground();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用切换至前台"><a href="#应用切换至前台" class="headerlink" title="应用切换至前台"></a>应用切换至前台</h2><p>利用<code>Application.registerActivityLifeStyleCallbacks()</code>，如名字描述一样，可以覆写每一个生命周期函数。在这个例子中，在不侵入式改动每个 Activity 的代码的前提下，在<code>Activity.onResume()</code>中执行了代码。</p><p>sample:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">           registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">Application</span>.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResumed</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (isBackground) &#123;</span><br><span class="line">                     isBackground = <span class="literal">false</span>;</span><br><span class="line">                     notifyForeground();</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手机熄屏"><a href="#手机熄屏" class="headerlink" title="手机熄屏"></a>手机熄屏</h2><p><code>Application.onTrimMemory(int level)</code>在手机熄屏时不回调怎么办？用<code>Intent.ACTION_SCREEN_OFF</code>注册 BroadcastReceiver</p><p>sample:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">IntentFilter</span> <span class="variable">screenOffFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        registerReceiver(<span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (isBackground) &#123;</span><br><span class="line">                  isBackground = <span class="literal">false</span>;</span><br><span class="line">                  notifyForeground();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, screenOffFilter);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文章<br><a href="http://www.jianshu.com/p/11654f7f0c4a">[译]玩转 Android Application 的生命周期(不，不许覆盖那个 Home 键)</a> &gt; <a href="http://www.developerphil.com/no-you-can-not-override-the-home-button-but-you-dont-have-to/">No, You Can Not Override the Home Button… But You Don’t Have To!</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《疯狂Java程序员的基本修养》读书笔记</title>
      <link href="/2016-06-07/%E3%80%8A%E7%96%AF%E7%8B%82Java%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2016-06-07/%E3%80%8A%E7%96%AF%E7%8B%82Java%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><em>去年读的电子版写的读书笔记兼目录，放出来温习一下</em>😊</p><h2 id="第-1-章-数组及其内存管理"><a href="#第-1-章-数组及其内存管理" class="headerlink" title="第 1 章 数组及其内存管理"></a>第 1 章 数组及其内存管理</h2><h3 id="1-1-数组初始化-p11"><a href="#1-1-数组初始化-p11" class="headerlink" title="1.1 数组初始化 p11"></a>1.1 数组初始化 p11</h3><h4 id="1-1-1-Java-数组是静态的-p11"><a href="#1-1-1-Java-数组是静态的-p11" class="headerlink" title="1.1.1 Java 数组是静态的 p11"></a>1.1.1 Java 数组是静态的 p11</h4><ul><li><p>数组静态初始化、动态初始化的 sample p11</p></li><li><p>Java 数组是静态的，一旦数组初始化完成，数组元素的内存空间分配即结束，程序只能改变数组元素的值，而无法改变数组的长度。</p></li><li><p>数组变量也是一种引用类型的变量，指向堆内存的数组对象。</p></li><li><p>JS 的数组可动态改变。</p></li></ul><h4 id="1-1-2-数组一定要初始化吗-p14"><a href="#1-1-2-数组一定要初始化吗-p14" class="headerlink" title="1.1.2 数组一定要初始化吗 p14"></a>1.1.2 数组一定要初始化吗 p14</h4><ul><li>只要让数组变量指向有效的数组对象即可。</li></ul><h4 id="1-1-3-基本类型数组的初始化-p16"><a href="#1-1-3-基本类型数组的初始化-p16" class="headerlink" title="1.1.3 基本类型数组的初始化 p16"></a>1.1.3 基本类型数组的初始化 p16</h4><ul><li>引用变量本质上只是一个指针，只要程序通过引用变量访问属性，或者通过引用变量来调用方法，该引用变量就会由它所引用的对象代替。</li></ul><h4 id="1-1-4-引用类型数组的初始化-p18"><a href="#1-1-4-引用类型数组的初始化-p18" class="headerlink" title="1.1.4 引用类型数组的初始化 p18"></a>1.1.4 引用类型数组的初始化 p18</h4><ul><li>sample p18</li></ul><h3 id="1-2-使用数组-p21"><a href="#1-2-使用数组-p21" class="headerlink" title="1.2 使用数组 p21"></a>1.2 使用数组 p21</h3><h4 id="1-2-1-数组元素就是变量-p21"><a href="#1-2-1-数组元素就是变量-p21" class="headerlink" title="1.2.1 数组元素就是变量 p21"></a>1.2.1 数组元素就是变量 p21</h4><h4 id="1-2-2-没有多维数组-p23"><a href="#1-2-2-没有多维数组-p23" class="headerlink" title="1.2.2 没有多维数组 p23"></a>1.2.2 没有多维数组 p23</h4><h2 id="第-2-章-对象及其内存管理"><a href="#第-2-章-对象及其内存管理" class="headerlink" title="第 2 章 对象及其内存管理"></a>第 2 章 对象及其内存管理</h2><ul><li><p>Java 内存管理分为两个方面：内存分配和内存回收。</p></li><li><p>内存分配指创建 Java 对象时 JVM 为该对象在堆内存中所分配的内存空间；</p></li><li><p>内存回收指当该 Java 对象失去引用变成垃圾时，JVM 的 GC 自动清理该对象，并回收该对象所占用的内存。</p></li></ul><h3 id="2-1-实例变量（非静态变量）和类变量（静态变量）-p31"><a href="#2-1-实例变量（非静态变量）和类变量（静态变量）-p31" class="headerlink" title="2.1 实例变量（非静态变量）和类变量（静态变量） p31"></a>2.1 实例变量（非静态变量）和类变量（静态变量） p31</h3><h4 id="2-1-1-实例变量和类变量的属性-p32"><a href="#2-1-1-实例变量和类变量的属性-p32" class="headerlink" title="2.1.1 实例变量和类变量的属性 p32"></a>2.1.1 实例变量和类变量的属性 p32</h4><ul><li><p>在同一个 JVM 内，每个类只对应一个 Class 对象。因此同一个 JVM 内的一个类的类变量只需一块内存空间；但实例变量有几个就需要几块内存空间。</p></li><li><p>sample p33</p></li></ul><h4 id="2-1-2-实例变量的初始化时机-p35"><a href="#2-1-2-实例变量的初始化时机-p35" class="headerlink" title="2.1.2 实例变量的初始化时机 p35"></a>2.1.2 实例变量的初始化时机 p35</h4><ul><li><p>非静态初始化块总是在构造器执行之前获得执行。</p></li><li><p>JDK 提供的 javap 工具，主要用于帮助开发者深入了解 Java 编译器的机制。 用法见 p38</p></li></ul><h4 id="2-1-3-类变量的初始化时机-p39"><a href="#2-1-3-类变量的初始化时机-p39" class="headerlink" title="2.1.3 类变量的初始化时机 p39"></a>2.1.3 类变量的初始化时机 p39</h4><ul><li>sample p39</li></ul><h3 id="2-2-父类构造器-p41"><a href="#2-2-父类构造器-p41" class="headerlink" title="2.2 父类构造器 p41"></a>2.2 父类构造器 p41</h3><h4 id="2-2-1-隐式调用和显式调用-p41"><a href="#2-2-1-隐式调用和显式调用-p41" class="headerlink" title="2.2.1 隐式调用和显式调用 p41"></a>2.2.1 隐式调用和显式调用 p41</h4><ul><li>Java 对象时的初始化过程 sample p41</li></ul><h4 id="2-2-2-访问子类对象的实例变量-p43"><a href="#2-2-2-访问子类对象的实例变量-p43" class="headerlink" title="2.2.2 访问子类对象的实例变量 p43"></a>2.2.2 访问子类对象的实例变量 p43</h4><ul><li>构造器只是负责对 Java 对象实例变量执行初始化（也就是赋初始值），在执行构造器代码之前，该对象所占的内存已经被分配出来了。</li></ul><h4 id="2-2-3-调用被子类重写的方法-p46"><a href="#2-2-3-调用被子类重写的方法-p46" class="headerlink" title="2.2.3 调用被子类重写的方法 p46"></a>2.2.3 调用被子类重写的方法 p46</h4><ul><li>sample p46</li></ul><h3 id="2-3-父子实例的内存控制-p48"><a href="#2-3-父子实例的内存控制-p48" class="headerlink" title="2.3 父子实例的内存控制 p48"></a>2.3 父子实例的内存控制 p48</h3><h4 id="2-3-1-继承成员变量和继承方法的区别-p48"><a href="#2-3-1-继承成员变量和继承方法的区别-p48" class="headerlink" title="2.3.1 继承成员变量和继承方法的区别 p48"></a>2.3.1 继承成员变量和继承方法的区别 p48</h4><ul><li>对于一个引用类型的变量而言，当通过该变量访问它所引用的对象的实例变量时，该实例变量的值取决于声明该变量时的类型；当通过该变量来调用它所引用的对象的方法时，该方法行为取决于它所实际引用的对象的类型。</li></ul><h4 id="2-3-2-内存中子类实例-p51"><a href="#2-3-2-内存中子类实例-p51" class="headerlink" title="2.3.2 内存中子类实例 p51"></a>2.3.2 内存中子类实例 p51</h4><ul><li>当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为其父类中定义的所有实例变量分配内存，即使子类定义了与父类同名的实例变量。</li></ul><h4 id="2-3-3-父、子类的类变量-p56"><a href="#2-3-3-父、子类的类变量-p56" class="headerlink" title="2.3.3 父、子类的类变量 p56"></a>2.3.3 父、子类的类变量 p56</h4><h3 id="2-4-final-修饰符-p57"><a href="#2-4-final-修饰符-p57" class="headerlink" title="2.4 final 修饰符 p57"></a>2.4 final 修饰符 p57</h3><h4 id="2-4-1-final-修饰的变量-p57"><a href="#2-4-1-final-修饰的变量-p57" class="headerlink" title="2.4.1 final 修饰的变量 p57"></a>2.4.1 final 修饰的变量 p57</h4><ul><li><p>三个地方对 final 实例变量进行初始化 sample p58</p></li><li><p>对于一个使用 final 修饰的变量而言，如果定义该 final 变量时就指定初始值，而且这个初始值可以在编译时就确定下来，那么这个 final 变量将不再是一个变量，系统会将其当成“宏变量”处理。</p></li></ul><h4 id="2-4-2-执行“宏替换”的变量-p62"><a href="#2-4-2-执行“宏替换”的变量-p62" class="headerlink" title="2.4.2 执行“宏替换”的变量 p62"></a>2.4.2 执行“宏替换”的变量 p62</h4><ul><li>对于 final 实例变量而言，只有在定义该变量指定初始值才会有“宏变量”的效果。</li></ul><h4 id="2-4-3-final-方法不能被重写-p66"><a href="#2-4-3-final-方法不能被重写-p66" class="headerlink" title="2.4.3 final 方法不能被重写 p66"></a>2.4.3 final 方法不能被重写 p66</h4><h4 id="2-4-4-内部类中的局部变量-p68"><a href="#2-4-4-内部类中的局部变量-p68" class="headerlink" title="2.4.4 内部类中的局部变量 p68"></a>2.4.4 内部类中的局部变量 p68</h4><ul><li>Java 编译器要求被内部类访问的局部变量必须使用 final 修饰符修饰。</li></ul><h2 id="第-3-章-常见-Java-集合的实现细节-p72"><a href="#第-3-章-常见-Java-集合的实现细节-p72" class="headerlink" title="第 3 章 常见 Java 集合的实现细节 p72"></a>第 3 章 常见 Java 集合的实现细节 p72</h2><h3 id="3-1-Set-和-Map-p73"><a href="#3-1-Set-和-Map-p73" class="headerlink" title="3.1 Set 和 Map p73"></a>3.1 Set 和 Map p73</h3><ul><li>可以说，Map 集合是 Set 集合的扩展。</li></ul><h4 id="3-1-1-Set-和-Map-的关系-p73"><a href="#3-1-1-Set-和-Map-的关系-p73" class="headerlink" title="3.1.1 Set 和 Map 的关系 p73"></a>3.1.1 Set 和 Map 的关系 p73</h4><ul><li>Map 集合的所有 key 都具有 Set 集合的特征。</li></ul><h4 id="3-1-2-HashMap-和-HashSet-p78"><a href="#3-1-2-HashMap-和-HashSet-p78" class="headerlink" title="3.1.2 HashMap 和 HashSet p78"></a>3.1.2 HashMap 和 HashSet p78</h4><ul><li><p>Java 集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的 Java 对象。</p></li><li><p>通常来说，HashMap 的实际容量总比 initialCapacity 大一些，除非指定的 initialCapacity 参数值恰好是 2 的 n 次方。所以在创建 HashMap 时将 initialCapacity 参数值指定为 2 的 n 次方，这样可以减少系统的计算开销。</p></li><li><p>HashMap 在底层将 key-value 对当成一个整体进行处理，这个整体就是一个 Entry 对象。</p></li><li><p>HashSet 只是封装了一个 HashMap 对象来存储所有的集合元素。所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p></li><li><p>测试掌握 HashMap 和 HashSet 集合的功能 sample p86</p></li></ul><h4 id="3-1-3-TreeMap-和-TreeSet-p88"><a href="#3-1-3-TreeMap-和-TreeSet-p88" class="headerlink" title="3.1.3 TreeMap 和 TreeSet p88"></a>3.1.3 TreeMap 和 TreeSet p88</h4><ul><li><p>TreeSet 底层实际使用的存储容器就是 TreeMap。</p></li><li><p>TreeMap 采用一种“红黑树”的排序二叉树来保存 Map 中的每个 Entry——每个 Entry 都被当成红黑树的一个节点来对待。</p></li><li><p>TreeMap 中所有的 key 总是由小到大排列。</p></li></ul><h3 id="3-2-Map-和-List-p94"><a href="#3-2-Map-和-List-p94" class="headerlink" title="3.2 Map 和 List p94"></a>3.2 Map 和 List p94</h3><h4 id="3-2-1-Map-的-values-方法-p94"><a href="#3-2-1-Map-的-values-方法-p94" class="headerlink" title="3.2.1 Map 的 values()方法 p94"></a>3.2.1 Map 的 values()方法 p94</h4><ul><li>Map 的 values 方法并未返回一个 List 集合。返回的都是内部类的 Values 对象。</li></ul><h4 id="3-2-2-Map-和-List-的关系-p100"><a href="#3-2-2-Map-和-List-的关系-p100" class="headerlink" title="3.2.2 Map 和 List 的关系 p100"></a>3.2.2 Map 和 List 的关系 p100</h4><ul><li><p>JavaScript 的对象有点类似于 Java 的 Map 的结构，也是由多个 key-value 对组成的。</p></li><li><p>JS 的 sample p101</p></li></ul><h3 id="3-3-ArrayList-和-LinkedList-p101"><a href="#3-3-ArrayList-和-LinkedList-p101" class="headerlink" title="3.3 ArrayList 和 LinkedList p101"></a>3.3 ArrayList 和 LinkedList p101</h3><ul><li><p>List 集合主要有三个实现类：ArrayList、Vector、LinkedList</p></li><li><p>程序中如果需要栈这种数据结构，推荐使用 Deque 实现类。从 JDK1.6 开始，Java 提供了一个 Deque 接口，并为该接口提供了一个 ArrayDeque 实现类。在无须线程安全的情况下，程序完全可以使用 ArrayDeque 来代替 Stack 类。</p></li><li><p>Deque 接口代表双端队列这种数据结构，双端队列既是队列也是栈。</p></li></ul><h4 id="3-3-1-Vector-和-ArrayList-的区别-p103"><a href="#3-3-1-Vector-和-ArrayList-的区别-p103" class="headerlink" title="3.3.1 Vector 和 ArrayList 的区别 p103"></a>3.3.1 Vector 和 ArrayList 的区别 p103</h4><ul><li><p>Vector 其实就是 ArrayList 的线程安全版本。</p></li><li><p>Vector 基本上已经被 ArrayList 所代替。</p></li></ul><h4 id="3-3-2-ArrayList-和-LinkedList-的实现差异-p106"><a href="#3-3-2-ArrayList-和-LinkedList-的实现差异-p106" class="headerlink" title="3.3.2 ArrayList 和 LinkedList 的实现差异 p106"></a>3.3.2 ArrayList 和 LinkedList 的实现差异 p106</h4><ul><li><p>LinkedList 本质上就是一个双向链表，但它不仅实现了 List 接口，还实现了 Deque 接口。</p></li><li><p>ArrayList、LinkedList 的一些源码。p106</p></li></ul><h4 id="3-3-3-ArrayList-和-LinkedList-的性能分析及适用场景-p110"><a href="#3-3-3-ArrayList-和-LinkedList-的性能分析及适用场景-p110" class="headerlink" title="3.3.3 ArrayList 和 LinkedList 的性能分析及适用场景 p110"></a>3.3.3 ArrayList 和 LinkedList 的性能分析及适用场景 p110</h4><h3 id="3-4-Iterator-迭代器-p110"><a href="#3-4-Iterator-迭代器-p110" class="headerlink" title="3.4 Iterator 迭代器 p110"></a>3.4 Iterator 迭代器 p110</h3><h4 id="3-4-1-Iterator-实现类与迭代器模式-p111"><a href="#3-4-1-Iterator-实现类与迭代器模式-p111" class="headerlink" title="3.4.1 Iterator 实现类与迭代器模式 p111"></a>3.4.1 Iterator 实现类与迭代器模式 p111</h4><ul><li>对于 Iterator 迭代器而言，它只是一个接口。Java 要求各种集合都提供一个 Iterator()方法，该方法可以返回一个 Iterator 用于遍历该集合中的元素，至于返回的 Iterator 到底是哪种实现类，程序并不关心，这就是典型的“<strong>迭代器模式</strong>”。</li></ul><h4 id="3-4-2-迭代时删除指定元素-p112"><a href="#3-4-2-迭代时删除指定元素-p112" class="headerlink" title="3.4.2 迭代时删除指定元素 p112"></a>3.4.2 迭代时删除指定元素 p112</h4><h2 id="第-4-章-Java-的内存回收-p116"><a href="#第-4-章-Java-的内存回收-p116" class="headerlink" title="第 4 章 Java 的内存回收 p116"></a>第 4 章 Java 的内存回收 p116</h2><h3 id="4-1-Java-引用的种类-p117"><a href="#4-1-Java-引用的种类-p117" class="headerlink" title="4.1 Java 引用的种类 p117"></a>4.1 Java 引用的种类 p117</h3><ul><li>Java 内存管理包括内存分配和内存回收两个方面。</li></ul><h4 id="4-1-1-对象在内存中的状态-p117"><a href="#4-1-1-对象在内存中的状态-p117" class="headerlink" title="4.1.1 对象在内存中的状态 p117"></a>4.1.1 对象在内存中的状态 p117</h4><ul><li><p>对象的三种状态：可达状态、可恢复状态、不可达状态。</p></li><li><p>只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</p></li></ul><h4 id="4-1-2-强引用-p120"><a href="#4-1-2-强引用-p120" class="headerlink" title="4.1.2 强引用 p120"></a>4.1.2 强引用 p120</h4><ul><li>强引用是造成 Java 内存泄漏的主要原因之一。</li></ul><h4 id="4-1-3-软引用-p120"><a href="#4-1-3-软引用-p120" class="headerlink" title="4.1.3 软引用 p120"></a>4.1.3 软引用 p120</h4><ul><li>通过 SoftReference 类来实现。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；当系统内存空间不足时，系统将会回收它。</li></ul><h4 id="4-1-4-弱引用-p123"><a href="#4-1-4-弱引用-p123" class="headerlink" title="4.1.4 弱引用 p123"></a>4.1.4 弱引用 p123</h4><ul><li><p>通过 WeakReference 类来实现。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。</p></li><li><p>当程序有大量的 Java 对象需要使用弱引用来引用时，可以考虑使用 WeakHashMap 来保存它们。</p></li></ul><h4 id="4-1-5-虚引用-p127"><a href="#4-1-5-虚引用-p127" class="headerlink" title="4.1.5 虚引用 p127"></a>4.1.5 虚引用 p127</h4><ul><li>虚引用的主要作用就是跟踪对象被垃圾回收的状态。不能单独使用，必须和引用队列（ReferenceQueue）联合使用。</li></ul><h3 id="4-2-Java-的内存泄漏-p128"><a href="#4-2-Java-的内存泄漏-p128" class="headerlink" title="4.2 Java 的内存泄漏 p128"></a>4.2 Java 的内存泄漏 p128</h3><h3 id="4-3-垃圾回收机制-p132"><a href="#4-3-垃圾回收机制-p132" class="headerlink" title="4.3 垃圾回收机制 p132"></a>4.3 垃圾回收机制 p132</h3><h4 id="4-3-1-垃圾回收的基本算法-p132"><a href="#4-3-1-垃圾回收的基本算法-p132" class="headerlink" title="4.3.1 垃圾回收的基本算法 p132"></a>4.3.1 垃圾回收的基本算法 p132</h4><ul><li><p>对于一个垃圾回收器的设计算法来说，大致有如下可供选择的设计：串行回收和并行回收；并发执行和应用程序停止；压缩&#x2F;不压缩和复制。</p></li><li><p>现行的垃圾回收器用分代的方式来采用不同的回收设计。分代的基本思路是根据对象生存时间的长短，把堆内存分成三代：Young,Old,Permanent。</p></li></ul><h4 id="4-3-2-堆内存的分代回收-p134"><a href="#4-3-2-堆内存的分代回收-p134" class="headerlink" title="4.3.2 堆内存的分代回收 p134"></a>4.3.2 堆内存的分代回收 p134</h4><h4 id="4-3-3-与垃圾回收相关的附加选项-p136"><a href="#4-3-3-与垃圾回收相关的附加选项-p136" class="headerlink" title="4.3.3 与垃圾回收相关的附加选项 p136"></a>4.3.3 与垃圾回收相关的附加选项 p136</h4><h4 id="4-3-4-常见的垃圾回收器-p136"><a href="#4-3-4-常见的垃圾回收器-p136" class="headerlink" title="* 4.3.4 常见的垃圾回收器 p136"></a>* 4.3.4 常见的垃圾回收器 p136</h4><ul><li>1、串行回收器；2、并行回收器；3、并行压缩回收器；4、并发标识-清理回收器（CMS）</li></ul><h3 id="4-4-内存管理小技巧-p140"><a href="#4-4-内存管理小技巧-p140" class="headerlink" title="4.4 内存管理小技巧 p140"></a>4.4 内存管理小技巧 p140</h3><h4 id="4-4-1-尽量使用直接量-p141"><a href="#4-4-1-尽量使用直接量-p141" class="headerlink" title="4.4.1 尽量使用直接量 p141"></a>4.4.1 尽量使用直接量 p141</h4><h4 id="4-4-2-使用-StringBuilder-和-StringBuffer-进行字符串连接-p141"><a href="#4-4-2-使用-StringBuilder-和-StringBuffer-进行字符串连接-p141" class="headerlink" title="4.4.2 使用 StringBuilder 和 StringBuffer 进行字符串连接 p141"></a>4.4.2 使用 StringBuilder 和 StringBuffer 进行字符串连接 p141</h4><h4 id="4-4-3-尽早释放无用对象引用-p141"><a href="#4-4-3-尽早释放无用对象引用-p141" class="headerlink" title="4.4.3 尽早释放无用对象引用 p141"></a>4.4.3 尽早释放无用对象引用 p141</h4><ul><li>大部分时候程序无须将局部引用变量显式设为 null。</li></ul><h4 id="4-4-4-尽量少用静态变量-p142"><a href="#4-4-4-尽量少用静态变量-p142" class="headerlink" title="4.4.4 尽量少用静态变量 p142"></a>4.4.4 尽量少用静态变量 p142</h4><h4 id="4-4-5-避免在经常调用的方法、循环中创建-Java-对象-p142"><a href="#4-4-5-避免在经常调用的方法、循环中创建-Java-对象-p142" class="headerlink" title="4.4.5 避免在经常调用的方法、循环中创建 Java 对象 p142"></a>4.4.5 避免在经常调用的方法、循环中创建 Java 对象 p142</h4><h4 id="4-4-6-缓存经常使用的对象-p143"><a href="#4-4-6-缓存经常使用的对象-p143" class="headerlink" title="4.4.6 缓存经常使用的对象 p143"></a>4.4.6 缓存经常使用的对象 p143</h4><ul><li>开源的缓存实现有 OSCache、Ehcache，它们大都实现了 FIFO、MRU 等常见的缓存算法。</li></ul><h4 id="4-4-7-尽量不要使用-finalize-方法-p143"><a href="#4-4-7-尽量不要使用-finalize-方法-p143" class="headerlink" title="4.4.7 尽量不要使用 finalize 方法 p143"></a>4.4.7 尽量不要使用 finalize 方法 p143</h4><h4 id="4-4-8-考虑使用-SoftReference-p144"><a href="#4-4-8-考虑使用-SoftReference-p144" class="headerlink" title="4.4.8 考虑使用 SoftReference p144"></a>4.4.8 考虑使用 SoftReference p144</h4><h2 id="第-5-章-表达式中的陷阱-p145"><a href="#第-5-章-表达式中的陷阱-p145" class="headerlink" title="第 5 章 表达式中的陷阱 p145"></a>第 5 章 表达式中的陷阱 p145</h2><h3 id="5-1-关于字符串的陷阱-p146"><a href="#5-1-关于字符串的陷阱-p146" class="headerlink" title="5.1 关于字符串的陷阱 p146"></a>5.1 关于字符串的陷阱 p146</h3><h4 id="5-1-1-JVM-对字符串的处理-p146"><a href="#5-1-1-JVM-对字符串的处理-p146" class="headerlink" title="5.1.1 JVM 对字符串的处理 p146"></a>5.1.1 JVM 对字符串的处理 p146</h4><ul><li><p>对于 Java 程序中的字符串直接量，JVM 会使用一个字符串池来保存它们。</p></li><li><p>当程序中需要使用字符串、基本类型包装类实例时，应该尽量使用字符串直接量、基本类型值的直接量，这样能保证较好的性能。</p></li></ul><h4 id="5-1-2-不可变的字符串-p149"><a href="#5-1-2-不可变的字符串-p149" class="headerlink" title="5.1.2 不可变的字符串 p149"></a>5.1.2 不可变的字符串 p149</h4><ul><li><p>当一个 String 对象创建完成后，该 String 类里包含的字符序列就被固定下来，以后永远都不能改变。</p></li><li><p>System 提供的 identifyHashCode()静态方法用于获取某个对象唯一的 hashCode 值，这个方法的返回值与该类是否重写了 hashCode()方法无关。</p></li></ul><h4 id="5-1-3-字符串比较-p151"><a href="#5-1-3-字符串比较-p151" class="headerlink" title="5.1.3 字符串比较 p151"></a>5.1.3 字符串比较 p151</h4><h3 id="5-2-表达式类型的陷阱-p153"><a href="#5-2-表达式类型的陷阱-p153" class="headerlink" title="5.2 表达式类型的陷阱 p153"></a>5.2 表达式类型的陷阱 p153</h3><h4 id="5-2-1-表达式类型的自动提升-p153"><a href="#5-2-1-表达式类型的自动提升-p153" class="headerlink" title="5.2.1 表达式类型的自动提升 p153"></a>5.2.1 表达式类型的自动提升 p153</h4><ul><li>当一个算术表达式包含多个基本类型的值时，整个算术表达式的数据类型将自动提升。</li></ul><h4 id="5-2-2-复合赋值运算符的陷阱-p154"><a href="#5-2-2-复合赋值运算符的陷阱-p154" class="headerlink" title="5.2.2 复合赋值运算符的陷阱 p154"></a>5.2.2 复合赋值运算符的陷阱 p154</h4><ul><li><p>复合赋值运算符包含了一个隐式类型转换，a+&#x3D;5 等价于 a&#x3D;(a 的类型)(a+5)</p></li><li><p>复合赋值运算的使用注意点：p156</p></li></ul><h4 id="5-2-3-Java7-新增的二进制整数-p156"><a href="#5-2-3-Java7-新增的二进制整数-p156" class="headerlink" title="5.2.3 Java7 新增的二进制整数 p156"></a>5.2.3 Java7 新增的二进制整数 p156</h4><h3 id="5-3-输入法导致的陷阱-p157"><a href="#5-3-输入法导致的陷阱-p157" class="headerlink" title="5.3 输入法导致的陷阱 p157"></a>5.3 输入法导致的陷阱 p157</h3><h3 id="5-4-注释字符必须合法-p158"><a href="#5-4-注释字符必须合法-p158" class="headerlink" title="5.4 注释字符必须合法 p158"></a>5.4 注释字符必须合法 p158</h3><h3 id="5-5-转义字符的陷阱-p158"><a href="#5-5-转义字符的陷阱-p158" class="headerlink" title="5.5 转义字符的陷阱 p158"></a>5.5 转义字符的陷阱 p158</h3><h4 id="5-5-1-慎用字符的-Unicode-转义形式-p158"><a href="#5-5-1-慎用字符的-Unicode-转义形式-p158" class="headerlink" title="5.5.1 慎用字符的 Unicode 转义形式 p158"></a>5.5.1 慎用字符的 Unicode 转义形式 p158</h4><h4 id="5-5-2-中止行注释的转义字符-p159"><a href="#5-5-2-中止行注释的转义字符-p159" class="headerlink" title="5.5.2 中止行注释的转义字符 p159"></a>5.5.2 中止行注释的转义字符 p159</h4><h3 id="5-6-泛型可能引起的错误-p160"><a href="#5-6-泛型可能引起的错误-p160" class="headerlink" title="5.6 泛型可能引起的错误 p160"></a>5.6 泛型可能引起的错误 p160</h3><h4 id="5-6-1-原始类型变量的赋值-p160"><a href="#5-6-1-原始类型变量的赋值-p160" class="headerlink" title="5.6.1 原始类型变量的赋值 p160"></a>5.6.1 原始类型变量的赋值 p160</h4><ul><li>把原始类型的变量赋给带泛型类型的变量时的 sample p160</li></ul><h4 id="5-6-2-原始类型带来的擦除-p162"><a href="#5-6-2-原始类型带来的擦除-p162" class="headerlink" title="5.6.2 原始类型带来的擦除 p162"></a>5.6.2 原始类型带来的擦除 p162</h4><ul><li><p>将一个 List<String>类型的对象转型为 List，则该 List 对集合元素的类型检查变成了类型变量的上限（即 Object）。</p></li><li><p>当把一个带泛型信息的 Java 对象赋给不带泛型信息的变量时，Java 程序会发生擦除，这种擦除不仅会擦除使用该 Java 类时传入的类型实参，而且会擦除所有的泛型信息，也就是擦除所有尖括号里的信息。p163</p></li></ul><h4 id="5-6-3-创建泛型数组的陷阱-p164"><a href="#5-6-3-创建泛型数组的陷阱-p164" class="headerlink" title="5.6.3 创建泛型数组的陷阱 p164"></a>5.6.3 创建泛型数组的陷阱 p164</h4><h3 id="5-7-正则表达式的陷阱-p166"><a href="#5-7-正则表达式的陷阱-p166" class="headerlink" title="5.7 正则表达式的陷阱 p166"></a>5.7 正则表达式的陷阱 p166</h3><h3 id="5-8-多线程的陷阱-p167"><a href="#5-8-多线程的陷阱-p167" class="headerlink" title="5.8 多线程的陷阱 p167"></a>5.8 多线程的陷阱 p167</h3><h4 id="5-8-1-不要调用-run-方法-p167"><a href="#5-8-1-不要调用-run-方法-p167" class="headerlink" title="5.8.1 不要调用 run 方法 p167"></a>5.8.1 不要调用 run 方法 p167</h4><h4 id="5-8-2-静态的同步方法-p169"><a href="#5-8-2-静态的同步方法-p169" class="headerlink" title="5.8.2 静态的同步方法 p169"></a>5.8.2 静态的同步方法 p169</h4><ul><li>任何线程进入同步方法、同步代码块之前，必须先获取同步方法、同步代码块对应的同步监视器。</li></ul><h4 id="5-8-3-静态初始化块启动新线程执行初始化-p171"><a href="#5-8-3-静态初始化块启动新线程执行初始化-p171" class="headerlink" title="5.8.3 静态初始化块启动新线程执行初始化 p171"></a>5.8.3 静态初始化块启动新线程执行初始化 p171</h4><h4 id="5-8-4-注意多线程执行环境-p176"><a href="#5-8-4-注意多线程执行环境-p176" class="headerlink" title="5.8.4 注意多线程执行环境 p176"></a>5.8.4 注意多线程执行环境 p176</h4><ul><li>将线程不安全的类改成线程安全的形式 p179</li></ul><h2 id="第-6-章-流程控制的陷阱-p181"><a href="#第-6-章-流程控制的陷阱-p181" class="headerlink" title="第 6 章 流程控制的陷阱 p181"></a>第 6 章 流程控制的陷阱 p181</h2><h3 id="6-1-switch-语句陷阱-p182"><a href="#6-1-switch-语句陷阱-p182" class="headerlink" title="6.1 switch 语句陷阱 p182"></a>6.1 switch 语句陷阱 p182</h3><h4 id="6-1-1-default-分支永远会执行吗-p182"><a href="#6-1-1-default-分支永远会执行吗-p182" class="headerlink" title="6.1.1 default 分支永远会执行吗 p182"></a>6.1.1 default 分支永远会执行吗 p182</h4><h4 id="6-1-2-break-的重要性-p183"><a href="#6-1-2-break-的重要性-p183" class="headerlink" title="6.1.2 break 的重要性 p183"></a>6.1.2 break 的重要性 p183</h4><ul><li>输入 javac -X 命令查看支持的全部扩展选项</li></ul><h4 id="6-1-3-Java7-增强的-switch-表达式-p185"><a href="#6-1-3-Java7-增强的-switch-表达式-p185" class="headerlink" title="6.1.3 Java7 增强的 switch 表达式 p185"></a>6.1.3 Java7 增强的 switch 表达式 p185</h4><h3 id="6-2-标签引起的陷阱-p186"><a href="#6-2-标签引起的陷阱-p186" class="headerlink" title="6.2 标签引起的陷阱 p186"></a>6.2 标签引起的陷阱 p186</h3><h3 id="6-3-if-语句的陷阱-p187"><a href="#6-3-if-语句的陷阱-p187" class="headerlink" title="6.3 if 语句的陷阱 p187"></a>6.3 if 语句的陷阱 p187</h3><h4 id="6-3-1-else-隐含的条件-p187"><a href="#6-3-1-else-隐含的条件-p187" class="headerlink" title="6.3.1 else 隐含的条件 p187"></a>6.3.1 else 隐含的条件 p187</h4><ul><li>使用 if…else 语句有一条基本规则：总是优先把包含范围小的条件放在前面处理。</li></ul><h4 id="6-3-2-小心空语句-p190"><a href="#6-3-2-小心空语句-p190" class="headerlink" title="6.3.2 小心空语句 p190"></a>6.3.2 小心空语句 p190</h4><h3 id="6-4-循环体的花括号-p191"><a href="#6-4-循环体的花括号-p191" class="headerlink" title="6.4 循环体的花括号 p191"></a>6.4 循环体的花括号 p191</h3><h4 id="6-4-1-什么时候可以省略花括号-p191"><a href="#6-4-1-什么时候可以省略花括号-p191" class="headerlink" title="6.4.1 什么时候可以省略花括号 p191"></a>6.4.1 什么时候可以省略花括号 p191</h4><h4 id="6-4-2-省略花括号的危险-p192"><a href="#6-4-2-省略花括号的危险-p192" class="headerlink" title="6.4.2 省略花括号的危险 p192"></a>6.4.2 省略花括号的危险 p192</h4><ul><li>大部分时候，如果循环体只包含一条语句，那么就可以省略循环体的花括号；但如果循环体只包含一条局部变量定义语句，那依然不可以省略循环体的花括号。</li></ul><h3 id="6-5-for-循环的陷阱-p194"><a href="#6-5-for-循环的陷阱-p194" class="headerlink" title="6.5 for 循环的陷阱 p194"></a>6.5 for 循环的陷阱 p194</h3><h4 id="6-5-1-分号惹的祸-p194"><a href="#6-5-1-分号惹的祸-p194" class="headerlink" title="6.5.1 分号惹的祸 p194"></a>6.5.1 分号惹的祸 p194</h4><h4 id="6-5-2-小心循环计数器的值-p197"><a href="#6-5-2-小心循环计数器的值-p197" class="headerlink" title="6.5.2 小心循环计数器的值 p197"></a>6.5.2 小心循环计数器的值 p197</h4><h4 id="6-5-3-浮点数作循环计数器-p197"><a href="#6-5-3-浮点数作循环计数器-p197" class="headerlink" title="6.5.3 浮点数作循环计数器 p197"></a>6.5.3 浮点数作循环计数器 p197</h4><h3 id="6-6-foreach-循环的循环计数器-p199"><a href="#6-6-foreach-循环的循环计数器-p199" class="headerlink" title="6.6 foreach 循环的循环计数器 p199"></a>6.6 foreach 循环的循环计数器 p199</h3><h2 id="第-7-章-面向对象的陷阱-p202"><a href="#第-7-章-面向对象的陷阱-p202" class="headerlink" title="第 7 章 面向对象的陷阱 p202"></a>第 7 章 面向对象的陷阱 p202</h2><h3 id="7-1-instanceof-运算符的陷阱-p203"><a href="#7-1-instanceof-运算符的陷阱-p203" class="headerlink" title="7.1 instanceof 运算符的陷阱 p203"></a>7.1 instanceof 运算符的陷阱 p203</h3><ul><li><p>前一个操作数为引用类型的变量，后一个操作数通常为一个类或接口。</p></li><li><p>使 null 调用 instanceof 运算符时返回 false 是非常有用的行为。</p></li></ul><h3 id="7-2-构造器的陷阱-p207"><a href="#7-2-构造器的陷阱-p207" class="headerlink" title="7.2 构造器的陷阱 p207"></a>7.2 构造器的陷阱 p207</h3><h4 id="7-2-1-构造器之前的-void-p207"><a href="#7-2-1-构造器之前的-void-p207" class="headerlink" title="7.2.1 构造器之前的 void p207"></a>7.2.1 构造器之前的 void p207</h4><h4 id="7-2-2-构造器创建对象吗-p208"><a href="#7-2-2-构造器创建对象吗-p208" class="headerlink" title="7.2.2 构造器创建对象吗 p208"></a>7.2.2 构造器创建对象吗 p208</h4><ul><li><p>构造器并不会创建 Java 对象，构造器只是负责执行初始化。</p></li><li><p>以下 2 种方式创建 Java 对象无需使用构造器：使用反序列化的方式恢复 Java 对象；使用 clone 方法复制 Java 对象。</p></li><li><p>为单例类提供 readResolve()方法，保证反序列化时得到已有的 Java 实例。例 p210</p></li></ul><h4 id="7-2-3-无限递归的构造器-p212"><a href="#7-2-3-无限递归的构造器-p212" class="headerlink" title="7.2.3 无限递归的构造器 p212"></a>7.2.3 无限递归的构造器 p212</h4><h3 id="7-3-持有当前类的实例-p214"><a href="#7-3-持有当前类的实例-p214" class="headerlink" title="7.3 持有当前类的实例 p214"></a>7.3 持有当前类的实例 p214</h3><ul><li>对于一个 Java 类而言，它的一个实例变量持有当前类的另一个实例是被允许的。</li></ul><h3 id="7-4-到底调用哪个重载的方法-p215"><a href="#7-4-到底调用哪个重载的方法-p215" class="headerlink" title="7.4 到底调用哪个重载的方法 p215"></a>7.4 到底调用哪个重载的方法 p215</h3><h3 id="7-5-方法重写的陷阱-p218"><a href="#7-5-方法重写的陷阱-p218" class="headerlink" title="7.5 方法重写的陷阱 p218"></a>7.5 方法重写的陷阱 p218</h3><h4 id="7-5-1-重写-private-方法-p218"><a href="#7-5-1-重写-private-方法-p218" class="headerlink" title="7.5.1 重写 private 方法 p218"></a>7.5.1 重写 private 方法 p218</h4><h4 id="7-5-2-重写其他访问权限的方法-p219"><a href="#7-5-2-重写其他访问权限的方法-p219" class="headerlink" title="7.5.2 重写其他访问权限的方法 p219"></a>7.5.2 重写其他访问权限的方法 p219</h4><h3 id="7-6-非静态内部类的陷阱-p220"><a href="#7-6-非静态内部类的陷阱-p220" class="headerlink" title="7.6 非静态内部类的陷阱 p220"></a>7.6 非静态内部类的陷阱 p220</h3><h4 id="7-6-1-非静态内部类的构造器-p220"><a href="#7-6-1-非静态内部类的构造器-p220" class="headerlink" title="7.6.1 非静态内部类的构造器 p220"></a>7.6.1 非静态内部类的构造器 p220</h4><ul><li><p>非静态内部类必须寄生在外部类的实例中，没有外部类的对象，就不可能产生非静态内部类的对象。因此，非静态内部类不可能有无参数的构造器——即使系统为非静态内部类提供一个默认的构造器，这个默认的构造器也需要一个外部类形参。</p></li><li><p>系统在编译阶段总会为非静态内部类的构造器增加一个参数，非静态内部类的构造器的第一个形参总是外部类。</p></li></ul><h4 id="7-6-2-非静态内部类不能拥有静态成员-p222"><a href="#7-6-2-非静态内部类不能拥有静态成员-p222" class="headerlink" title="7.6.2 非静态内部类不能拥有静态成员 p222"></a>7.6.2 非静态内部类不能拥有静态成员 p222</h4><h4 id="7-6-3-非静态内部类的子类-p223"><a href="#7-6-3-非静态内部类的子类-p223" class="headerlink" title="7.6.3 非静态内部类的子类 p223"></a>7.6.3 非静态内部类的子类 p223</h4><ul><li><p>非静态内部类在外部类的内部派生子类是安全的。</p></li><li><p>如果条件允许，推荐多使用静态内部类，而不是非静态内部类。对于静态内部类来说，外部类相当于它的一个包。</p></li></ul><h3 id="7-7-static-关键字-p224"><a href="#7-7-static-关键字-p224" class="headerlink" title="7.7 static 关键字 p224"></a>7.7 static 关键字 p224</h3><h4 id="7-7-1-静态方法属于类-p224"><a href="#7-7-1-静态方法属于类-p224" class="headerlink" title="7.7.1 静态方法属于类 p224"></a>7.7.1 静态方法属于类 p224</h4><h4 id="7-7-2-静态内部类的限制-p226"><a href="#7-7-2-静态内部类的限制-p226" class="headerlink" title="7.7.2 静态内部类的限制 p226"></a>7.7.2 静态内部类的限制 p226</h4><ul><li>静态内部类不能访问外部类的非静态成员。</li></ul><h3 id="7-8-native-方法的陷阱-p226"><a href="#7-8-native-方法的陷阱-p226" class="headerlink" title="7.8 native 方法的陷阱 p226"></a>7.8 native 方法的陷阱 p226</h3><ul><li><p>对于 native 方法而言，Java 不会为该方法提供实现体。</p></li><li><p>native 方法通常需要借助 C 语言完成，实现步骤：p227</p></li></ul><h2 id="第-8-章-异常处理的陷阱-p229"><a href="#第-8-章-异常处理的陷阱-p229" class="headerlink" title="第 8 章 异常处理的陷阱 p229"></a>第 8 章 异常处理的陷阱 p229</h2><h3 id="8-1-正确关闭资源的方式-p230"><a href="#8-1-正确关闭资源的方式-p230" class="headerlink" title="8.1 正确关闭资源的方式 p230"></a>8.1 正确关闭资源的方式 p230</h3><ul><li>实例代码 p232</li></ul><h4 id="8-1-2-使用-Java7-增强的-try-语句关闭资源-p233"><a href="#8-1-2-使用-Java7-增强的-try-语句关闭资源-p233" class="headerlink" title="8.1.2 使用 Java7 增强的 try 语句关闭资源 p233"></a>8.1.2 使用 Java7 增强的 try 语句关闭资源 p233</h4><ul><li>实例代码 p234</li></ul><h3 id="8-2-finally-块的陷阱-p235"><a href="#8-2-finally-块的陷阱-p235" class="headerlink" title="8.2 finally 块的陷阱 p235"></a>8.2 finally 块的陷阱 p235</h3><h4 id="8-2-1-finally-的执行规则-p235"><a href="#8-2-1-finally-的执行规则-p235" class="headerlink" title="8.2.1 finally 的执行规则 p235"></a>8.2.1 finally 的执行规则 p235</h4><ul><li>实例代码：为系统注册了一个关闭钩子，关闭钩子负责在程序退出时回收系统资源。 p236</li></ul><h4 id="8-2-2-finally-块和方法返回值-p236"><a href="#8-2-2-finally-块和方法返回值-p236" class="headerlink" title="8.2.2 finally 块和方法返回值 p236"></a>8.2.2 finally 块和方法返回值 p236</h4><h3 id="8-3-catch-块的方法-p238"><a href="#8-3-catch-块的方法-p238" class="headerlink" title="8.3 catch 块的方法 p238"></a>8.3 catch 块的方法 p238</h3><h4 id="8-3-1-catch-块的顺序-p238"><a href="#8-3-1-catch-块的顺序-p238" class="headerlink" title="8.3.1 catch 块的顺序 p238"></a>8.3.1 catch 块的顺序 p238</h4><ul><li>捕捉父类异常的 catch 块都应该排在捕捉子类异常的 catch 块之后（先捕小异常再捕大异常），否则将出现编译错误。</li></ul><h4 id="8-3-2-不要用-catch-代替流程控制-p240"><a href="#8-3-2-不要用-catch-代替流程控制-p240" class="headerlink" title="8.3.2 不要用 catch 代替流程控制 p240"></a>8.3.2 不要用 catch 代替流程控制 p240</h4><h4 id="8-3-3-只有-catch-可能抛出的异常-p241"><a href="#8-3-3-只有-catch-可能抛出的异常-p241" class="headerlink" title="8.3.3 只有 catch 可能抛出的异常 p241"></a>8.3.3 只有 catch 可能抛出的异常 p241</h4><h4 id="8-3-4-做点实际的修复-p244"><a href="#8-3-4-做点实际的修复-p244" class="headerlink" title="8.3.4 做点实际的修复 p244"></a>8.3.4 做点实际的修复 p244</h4><h3 id="8-4-继承得到的异常-p246"><a href="#8-4-继承得到的异常-p246" class="headerlink" title="8.4 继承得到的异常 p246"></a>8.4 继承得到的异常 p246</h3><h3 id="8-5-Java7-增强的-throw-语句-p247"><a href="#8-5-Java7-增强的-throw-语句-p247" class="headerlink" title="8.5 Java7 增强的 throw 语句 p247"></a>8.5 Java7 增强的 throw 语句 p247</h3><h2 id="第-9-章-线性表-p250"><a href="#第-9-章-线性表-p250" class="headerlink" title="第 9 章 线性表 p250"></a>第 9 章 线性表 p250</h2><h3 id="9-1-线性表概述-p251"><a href="#9-1-线性表概述-p251" class="headerlink" title="9.1 线性表概述 p251"></a>9.1 线性表概述 p251</h3><h4 id="9-1-1-线性表的定义及逻辑结构-p251"><a href="#9-1-1-线性表的定义及逻辑结构-p251" class="headerlink" title="9.1.1 线性表的定义及逻辑结构 p251"></a>9.1.1 线性表的定义及逻辑结构 p251</h4><h4 id="9-1-2-线性表的基本操作-p252"><a href="#9-1-2-线性表的基本操作-p252" class="headerlink" title="9.1.2 线性表的基本操作 p252"></a>9.1.2 线性表的基本操作 p252</h4><h3 id="9-2-顺序存储结构-p252"><a href="#9-2-顺序存储结构-p252" class="headerlink" title="9.2 顺序存储结构 p252"></a>9.2 顺序存储结构 p252</h3><ul><li>简单的顺序结构线性表的源代码。p254</li></ul><h3 id="9-3-链式存储结构-p257"><a href="#9-3-链式存储结构-p257" class="headerlink" title="9.3 链式存储结构 p257"></a>9.3 链式存储结构 p257</h3><ul><li>链式存储结构的线性表不会按线性的逻辑顺序来保存数据元素，它需要在每一个数据元素里保存一个引用下一个数据元素的引用。</li></ul><h4 id="9-3-1-单链表上的基本运算-p258"><a href="#9-3-1-单链表上的基本运算-p258" class="headerlink" title="9.3.1 单链表上的基本运算 p258"></a>9.3.1 单链表上的基本运算 p258</h4><ul><li><p>单链表指的是每个节点只保留一个引用，该引用指向当前节点的下一个节点，没有引用指向头节点，尾节点的 next 引用为 null。</p></li><li><p>链表和顺序表性能上的差异：顺序表在随机存取时性能很好；链表在插入、删除时性能很好。</p></li></ul><h4 id="9-3-2-循环链表-p264"><a href="#9-3-2-循环链表-p264" class="headerlink" title="9.3.2 循环链表 p264"></a>9.3.2 循环链表 p264</h4><ul><li>循环链表是一种首尾相接的链表。循环链表有一个显著特征：从链表的任一节点出发均可找到表中的其他所有节点。</li></ul><h4 id="9-3-3-双向链表-p265"><a href="#9-3-3-双向链表-p265" class="headerlink" title="9.3.3 双向链表 p265"></a>9.3.3 双向链表 p265</h4><ul><li><p>双向链表是为每个节点保留两个引用 prev 和 next。</p></li><li><p>双向链表添加节点、删除节点的指针维护成本更大；在搜索节点、删除指定索引处的节点具有较好的性能。</p></li></ul><h3 id="9-4-线性表的分析-p271"><a href="#9-4-线性表的分析-p271" class="headerlink" title="9.4 线性表的分析 p271"></a>9.4 线性表的分析 p271</h3><h4 id="9-4-1-线性表的实现分析-p271"><a href="#9-4-1-线性表的实现分析-p271" class="headerlink" title="9.4.1 线性表的实现分析 p271"></a>9.4.1 线性表的实现分析 p271</h4><ul><li>线性表的顺序和链式两种实现的优势 p271</li></ul><h4 id="9-4-2-线性表的功能-p272"><a href="#9-4-2-线性表的功能-p272" class="headerlink" title="9.4.2 线性表的功能 p272"></a>9.4.2 线性表的功能 p272</h4><h2 id="第-10-章-栈和队列-p274"><a href="#第-10-章-栈和队列-p274" class="headerlink" title="第 10 章 栈和队列 p274"></a>第 10 章 栈和队列 p274</h2><h3 id="10-1-栈-p275"><a href="#10-1-栈-p275" class="headerlink" title="10.1 栈 p275"></a>10.1 栈 p275</h3><ul><li>栈是一种特殊的线性表，这种线性表只能在固定一端（通常尾端）进行插入、删除操作。</li></ul><h4 id="10-1-1-栈的基本定义-p275"><a href="#10-1-1-栈的基本定义-p275" class="headerlink" title="10.1.1 栈的基本定义 p275"></a>10.1.1 栈的基本定义 p275</h4><ul><li>栈就是一种后进先出（LIFO）的线性表。</li></ul><h4 id="10-1-2-栈的常用操作-p276"><a href="#10-1-2-栈的常用操作-p276" class="headerlink" title="10.1.2 栈的常用操作 p276"></a>10.1.2 栈的常用操作 p276</h4><ul><li><p>栈的标志性方法：入栈、出栈、访问栈顶元素。</p></li><li><p>栈同样既可采用顺序结构或链式结构存储栈内元素。</p></li></ul><h4 id="10-1-3-栈的顺序存储结构及实现-p276"><a href="#10-1-3-栈的顺序存储结构及实现-p276" class="headerlink" title="10.1.3 栈的顺序存储结构及实现 p276"></a>10.1.3 栈的顺序存储结构及实现 p276</h4><ul><li>顺序栈的代码实现 p277</li></ul><h4 id="10-1-4-栈的链式存储结构及实现-p281"><a href="#10-1-4-栈的链式存储结构及实现-p281" class="headerlink" title="10.1.4 栈的链式存储结构及实现 p281"></a>10.1.4 栈的链式存储结构及实现 p281</h4><ul><li>链栈的代码实现 p282</li></ul><h4 id="10-1-5-Java-集合中的栈-p284"><a href="#10-1-5-Java-集合中的栈-p284" class="headerlink" title="10.1.5 Java 集合中的栈 p284"></a>10.1.5 Java 集合中的栈 p284</h4><ul><li><p>java.util.Stack：一个普通的顺序栈，底层基于数组实现，线程安全。</p></li><li><p>java.util.LinkedList：一个双端链表。代表栈的链式实现，线程不安全。</p></li></ul><h3 id="10-2-对列-p284"><a href="#10-2-对列-p284" class="headerlink" title="10.2 对列 p284"></a>10.2 对列 p284</h3><ul><li>队列使用固定的一端来插入数据元素，另一端只用于删除元素。</li></ul><h4 id="10-2-1-队列的基本定义-p284"><a href="#10-2-1-队列的基本定义-p284" class="headerlink" title="10.2.1 队列的基本定义 p284"></a>10.2.1 队列的基本定义 p284</h4><ul><li>队列是一种特殊的线性表，只允许在表的前端进行删除，只允许在表的后端进行插入。先进先出（FIFO）的线性表。</li></ul><h4 id="10-2-2-队列的常用操作-p285"><a href="#10-2-2-队列的常用操作-p285" class="headerlink" title="10.2.2 队列的常用操作 p285"></a>10.2.2 队列的常用操作 p285</h4><ul><li><p>队列的标志性方法：加入元素、删除元素、访问队列的前端元素。</p></li><li><p>队列同样既可采用顺序结构或链式结构存储队列内元素。</p></li></ul><h4 id="10-2-3-队列的顺序存储结构及实现-p285"><a href="#10-2-3-队列的顺序存储结构及实现-p285" class="headerlink" title="10.2.3 队列的顺序存储结构及实现 p285"></a>10.2.3 队列的顺序存储结构及实现 p285</h4><ul><li>顺序队列的代码实现 p286</li></ul><h4 id="10-2-4-循环队列-p289"><a href="#10-2-4-循环队列-p289" class="headerlink" title="10.2.4 循环队列 p289"></a>10.2.4 循环队列 p289</h4><ul><li><p>循环队列是首尾相连的队列：当 front、rear 变量值达到底层数组的 capacity-1 之后，再前进一位就自动变成 0。</p></li><li><p>循环队列的代码实现 p290</p></li></ul><h4 id="10-2-5-队列的链式存储结构及实现-p293"><a href="#10-2-5-队列的链式存储结构及实现-p293" class="headerlink" title="10.2.5 队列的链式存储结构及实现 p293"></a>10.2.5 队列的链式存储结构及实现 p293</h4><ul><li><p>链队列的代码实现 p294</p></li><li><p>链队列不会出现队列“满”的情形，因此程序可以不受任何限制地向链队列中添加元素。</p></li></ul><h4 id="10-2-6-Java-集合中的队列-p296"><a href="#10-2-6-Java-集合中的队列-p296" class="headerlink" title="10.2.6 Java 集合中的队列 p296"></a>10.2.6 Java 集合中的队列 p296</h4><ul><li><p>从 JDK1.5 开始，Java 集合框架中提供了一个 Queue 接口，该接口代表了一个队列，实现该接口的类可以当成队列使用。</p></li><li><p>Queue 接口里定义的 6 个方法 p297</p></li><li><p>Dequeue 接口是一个双端队列。</p></li></ul><h3 id="10-3-双端队列-p297"><a href="#10-3-双端队列-p297" class="headerlink" title="10.3 双端队列 p297"></a>10.3 双端队列 p297</h3><ul><li><p>双端队列（Dequeue）可以在两端同时进行插入、删除操作。</p></li><li><p>Dequeue 既可当成队列使用，也可当成栈使用。</p></li><li><p>JDK 为 Dequeue 提供了 ArrayDequeue（顺序存储结构的双端队列）、LinkedList（链式存储结构的双端队列）两个常见的实现类。</p></li><li><p>LinkedList 既可当成线性表、也可当成栈、还可当成队列，但对大部分程序而言，使用 ArrayList、ArrayDequeue 的性能比 LinkedList 更好。</p></li></ul><h2 id="第-11-章-树和二叉树-p299"><a href="#第-11-章-树和二叉树-p299" class="headerlink" title="第 11 章 树和二叉树 p299"></a>第 11 章 树和二叉树 p299</h2><h3 id="11-1-树的概述-p300"><a href="#11-1-树的概述-p300" class="headerlink" title="11.1 树的概述 p300"></a>11.1 树的概述 p300</h3><ul><li>树是一种非线性结构。</li></ul><h4 id="11-1-1-树的定义和基本术语-p300"><a href="#11-1-1-树的定义和基本术语-p300" class="headerlink" title="11.1.1 树的定义和基本术语 p300"></a>11.1.1 树的定义和基本术语 p300</h4><ul><li>与树有关的术语 p301</li></ul><h4 id="11-1-2-树的基本操作-p301"><a href="#11-1-2-树的基本操作-p301" class="headerlink" title="11.1.2 树的基本操作 p301"></a>11.1.2 树的基本操作 p301</h4><ul><li>实现树的数据结构有 2 种选择：1）父节点表示法：每个子节点都记录它的父节点；2）子节点链表示法：每个非叶子节点通过一个链表来记录它所有的子节点。</li></ul><h4 id="11-1-3-父节点表示法-p302"><a href="#11-1-3-父节点表示法-p302" class="headerlink" title="11.1.3 父节点表示法 p302"></a>11.1.3 父节点表示法 p302</h4><ul><li><p>采用父节点表示法的代码实现 p303</p></li><li><p>父节点表示法的特点是：每个节点都可以快速找到它的父节点，但如果要找某个节点的所有子节点就比较麻烦，程序要遍历整个节点数组。</p></li></ul><h4 id="11-1-4-子节点链表示法-p305"><a href="#11-1-4-子节点链表示法-p305" class="headerlink" title="11.1.4 子节点链表示法 p305"></a>11.1.4 子节点链表示法 p305</h4><ul><li><p>子节点链表示法的代码实现 p306</p></li><li><p>子节点链表示法的特点是：每个节点都可以快速找到它的所有子节点，但如果要找某个节点的父节点则比较麻烦，程序要遍历整个节点数组。</p></li></ul><h3 id="11-2-二叉树-p309"><a href="#11-2-二叉树-p309" class="headerlink" title="11.2 二叉树 p309"></a>11.2 二叉树 p309</h3><h4 id="11-2-1-二叉树的定义和基本概念-p309"><a href="#11-2-1-二叉树的定义和基本概念-p309" class="headerlink" title="11.2.1 二叉树的定义和基本概念 p309"></a>11.2.1 二叉树的定义和基本概念 p309</h4><ul><li><p>二叉树指的是每个节点最多只能有两个子树的有序数。</p></li><li><p>如果一棵二叉树除最后一层外，其余层的所有节点都是满的，并且最后一层或者是满的，或者仅在右边缺少若干连续的节点，则此二叉树就是完全二叉树。</p></li><li><p>满二叉树是一种特殊的完全二叉树。当完全二叉树最后一层的所有节点都是满的时，这棵完全二叉树就变成了满二叉树。</p></li></ul><h4 id="11-2-2-二叉树的基本操作-p311"><a href="#11-2-2-二叉树的基本操作-p311" class="headerlink" title="11.2.2 二叉树的基本操作 p311"></a>11.2.2 二叉树的基本操作 p311</h4><ul><li>要实现二叉树的数据结构，有三种选择：顺序存储；二叉链表存储；三叉链表存储。</li></ul><h4 id="11-2-3-二叉树的顺序存储-p312"><a href="#11-2-3-二叉树的顺序存储-p312" class="headerlink" title="11.2.3 二叉树的顺序存储 p312"></a>11.2.3 二叉树的顺序存储 p312</h4><ul><li><p>当使用数组来存储二叉树的所有节点时可能会产生一定的空间浪费，如果该二叉树是完全二叉树，就不会有任何空间浪费了；但如果该二叉树的所有节点都只有右子节点，那么会产生相当大的空间浪费。</p></li><li><p>顺序存储的二叉树的代码实现 p313</p></li></ul><h4 id="11-2-4-二叉树的二叉链表存储-p315"><a href="#11-2-4-二叉树的二叉链表存储-p315" class="headerlink" title="11.2.4 二叉树的二叉链表存储 p315"></a>11.2.4 二叉树的二叉链表存储 p315</h4><ul><li><p>思想为每个节点增加 left、right 两个指针，分别引用该节点的左右两个子节点。</p></li><li><p>二叉链表的代码实现 p316</p></li><li><p>这种二叉链表的存储方式在遍历树节点时效率不高，指定节点访问其父节点时也比较困难。</p></li></ul><h4 id="11-2-5-二叉树的三叉链表存储-p319"><a href="#11-2-5-二叉树的三叉链表存储-p319" class="headerlink" title="11.2.5 二叉树的三叉链表存储 p319"></a>11.2.5 二叉树的三叉链表存储 p319</h4><ul><li><p>三叉链表是在二叉链表上增加了 parent 指针。</p></li><li><p>三叉链表的代码实现 p319</p></li></ul><h3 id="11-3-遍历二叉树-p322"><a href="#11-3-遍历二叉树-p322" class="headerlink" title="11.3 遍历二叉树 p322"></a>11.3 遍历二叉树 p322</h3><ul><li><p>遍历顺序结构的二叉树直接遍历底层数组即可；遍历链表存储的二叉树有 2 种：深度优先遍历、广度优先遍历。</p></li><li><p>深度优先遍历算法分为：前序遍历（DLR）、中序遍历(LDR)、后续遍历(LRD)</p></li></ul><h4 id="11-3-1-先序遍历-p323"><a href="#11-3-1-先序遍历-p323" class="headerlink" title="11.3.1 先序遍历 p323"></a>11.3.1 先序遍历 p323</h4><h4 id="11-3-2-中序遍历-p323"><a href="#11-3-2-中序遍历-p323" class="headerlink" title="11.3.2 中序遍历 p323"></a>11.3.2 中序遍历 p323</h4><h4 id="11-3-3-后序遍历-p324"><a href="#11-3-3-后序遍历-p324" class="headerlink" title="11.3.3 后序遍历 p324"></a>11.3.3 后序遍历 p324</h4><h4 id="11-3-4-广度优先（按层）遍历-p325"><a href="#11-3-4-广度优先（按层）遍历-p325" class="headerlink" title="11.3.4 广度优先（按层）遍历 p325"></a>11.3.4 广度优先（按层）遍历 p325</h4><ul><li>广度优先遍历的代码实现 p325</li></ul><h3 id="11-4-转换方法-p325"><a href="#11-4-转换方法-p325" class="headerlink" title="11.4 转换方法 p325"></a>11.4 转换方法 p325</h3><h4 id="11-4-1-森林、数和二叉树的转换-p326"><a href="#11-4-1-森林、数和二叉树的转换-p326" class="headerlink" title="11.4.1 森林、数和二叉树的转换 p326"></a>11.4.1 森林、数和二叉树的转换 p326</h4><h4 id="11-4-2-树的链表存储-p327"><a href="#11-4-2-树的链表存储-p327" class="headerlink" title="11.4.2 树的链表存储 p327"></a>11.4.2 树的链表存储 p327</h4><h3 id="11-5-哈夫曼数-p327"><a href="#11-5-哈夫曼数-p327" class="headerlink" title="11.5 哈夫曼数 p327"></a>11.5 哈夫曼数 p327</h3><h4 id="11-5-1-哈夫曼树的定义和基本概念-p328"><a href="#11-5-1-哈夫曼树的定义和基本概念-p328" class="headerlink" title="11.5.1 哈夫曼树的定义和基本概念 p328"></a>11.5.1 哈夫曼树的定义和基本概念 p328</h4><ul><li>带权路径最小的二叉树被称为哈夫曼数或最优二叉树。</li></ul><h4 id="11-5-2-创建哈夫曼树-p328"><a href="#11-5-2-创建哈夫曼树-p328" class="headerlink" title="11.5.2 创建哈夫曼树 p328"></a>11.5.2 创建哈夫曼树 p328</h4><h4 id="11-5-3-哈夫曼编码-p331"><a href="#11-5-3-哈夫曼编码-p331" class="headerlink" title="11.5.3 哈夫曼编码 p331"></a>11.5.3 哈夫曼编码 p331</h4><h3 id="11-6-排序二叉树-p332"><a href="#11-6-排序二叉树-p332" class="headerlink" title="11.6 排序二叉树 p332"></a>11.6 排序二叉树 p332</h3><ul><li><p>排序二叉树的性质：左子树上所有节点的值均小于它的根节点的值；右子数上所有节点的值均大于它的根节点的值；左右子树也分别为排序二叉树。</p></li><li><p>排序二叉树的代码实现 p335</p></li></ul><h3 id="11-7-红黑树-p340"><a href="#11-7-红黑树-p340" class="headerlink" title="11.7 红黑树 p340"></a>11.7 红黑树 p340</h3>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android系统架构概览</title>
      <link href="/2016-03-29/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/"/>
      <url>/2016-03-29/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>首先是<a href="http://source.android.com/source/index.html">官网</a>的架构图</p><p><img src="http://source.android.com/images/android_framework_details.png" alt="Android stack"></p><p>从图中可以看出，整个 Android 操作系统分为五层。它们分别是：</p><ol><li><p><strong>内核层（Linux Kernel）</strong>，这一层包含了 Linux Kernel 以及 Android 定制的一些改动。除此之外，Android 在 Linux 增加了一些定制的驱动，这些驱动通常与硬件无关，而是为了上层软件服务的，它们包括：</p><ul><li>Binder： 进程间通讯（IPC）基础设施。Binder 在 Android 系统中使用的地方非常多，几乎所有的 Framework 层的服务都是通过 Binder 的形式暴露出接口供外部使用的。</li><li>Ashmem 匿名共享内存。共享内存的作用是，当多个进程需要访问同一块数据时，可以避免数据拷贝。例如，经由 ContentProvider 接口获取数据的客户端和 ContentProvider 之间就是通过共享内存的方式来访问的。</li><li>lowmemorykiller 进程回收模块。在 Framework 层，所有的应用进程都是有 ActivityManagerService 来管理，它会根据进程的重要性设置一个优先级，这个优先级会被 LMK 读取。在系统内存较低时，LMK 会根据进程的优先级排序，将优先级低的进程杀死，直到系统恢复到合适的内存状态。</li><li>logger 日志相关。开发人员经常会使用 logcat 读取日志来帮助分析问题。而无论是 logcat 工具，还是通过日志 API 写入日志，最终都是有底层的 Logger 驱动进行处理。</li><li>wakelock 电源管理相关。Android 系统通常运行在以电池供电的移动设备上，因此专门增加了该模块来管理电源。</li><li>Alarm 闹钟相关，为 AlarmManager 服务。</li></ul></li><li><p><strong>硬件抽象层（HAL）</strong>，该层为硬件厂商定义了一套标准的接口。这样可以在不影响上层的情况下，调整内部实现。</p></li><li><p><strong>Runtime 和公共库层（Libraries &amp; Android Runtime）</strong>，这一层包含了虚拟机以及基本的运行环境。早期的 Android 的虚拟机是 Dalvik，后来在 Android 4.4 Google 又引入了 Android RunTime（ART）。</p></li><li><p><strong>Framework 层</strong>，这一层包含了一系列重要的系统服务。对于 App 层的管理以及 App 使用的 API 基本上都是在这一层提供的。这里面包含的服务很多，这里简单介绍一下最常见的几个服务：</p><ul><li>ActivityManagerService：负责四大组件的管理（Activity，Service，ContentProvider，BroadcastReceiver）以及 App 进程管理</li><li>WindowManagerService：负责窗口管理</li><li>PackageManagerService：负责 APK 包的管理，包括安装，卸载，更新等</li><li>NotificationManagerService：负责通知管理</li><li>PowerManagerService：电源管理</li><li>LocationManagerService：定位相关</li></ul></li><li><p><strong>应用层（Applications）</strong>，这是与用户直接接触的一层。大部分应用开发者都工作在这一层。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于mipmap和drawable文件夹的区别</title>
      <link href="/2016-03-10/%E5%85%B3%E4%BA%8Emipmap%E5%92%8Cdrawable%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2016-03-10/%E5%85%B3%E4%BA%8Emipmap%E5%92%8Cdrawable%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>现在我们通过 AS 创建 Android 工程，会发现 ic_launcher 默认放在了 mipmap 文件夹下，而不是原来的 drawable 文件夹。那这个 mipmap 文件夹和 drawable 有啥区别呢？</p><h2 id="关于-mipmap"><a href="#关于-mipmap" class="headerlink" title="关于 mipmap"></a>关于 mipmap</h2><p>查了一下就是一种图形渲染技术</p><p>维基百科百科链接：<a href="https://zh.wikipedia.org/wiki/Mipmap">Mipmap</a></p><h2 id="两者的定义"><a href="#两者的定义" class="headerlink" title="两者的定义"></a>两者的定义</h2><p>首先查询 google 官方资料<a href="http://developer.android.com/intl/zh-cn/tools/projects/index.html#ApplicationModules">http://developer.android.com/intl/zh-cn/tools/projects/index.html#ApplicationModules</a>，有如下这一段：</p><p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgw1f1rtcwvv5wj30ko06x0u2.jpg" alt="image"></p><p>我们可以看到，mipmap 文件夹下只用来放启动图标，就是应用装好后显示在桌面或应用抽屉里的图标。不论你的设备分辨率是多少，放在 mipmap 文件夹下的资源文件都会被系统保留，以便让 launcher 挑选最合适的 icon 显示。</p><p>而 drawable 文件夹，我们还是按照以前的方式放图片资源就行了。</p><p>我们再进一步看看这个<a href="http://developer.android.com/intl/zh-cn/tools/projects/index.html#mipmap">Managing Launcher Icons as mipmap Resources</a></p><p>里面有说到为什么要使用 mipmap 文件夹：</p><blockquote><p>When app resource optimization techniques remove resources for unused screen densities, launcher icons can wind up looking fuzzy because the launcher app has to upscale a lower-resolution icon for display. To avoid these display issues, apps should use the mipmap&#x2F; resource folders for launcher icons. The Android system preserves these resources regardless of density stripping, and ensures that launcher apps can pick icons with the best resolution for display.</p></blockquote><p>上面的大致意思就是，有个 resource optimization techniques 会移除不是当前设备屏幕密度的资源文件，那 launcher 应用只能通过放大一个较低分辨率的 icon 来展示，导致应用图标看上去模糊了。如果 resource 放在 mipmap 文件夹下，android 系统就会保留这些 resource 而无视 resource optimization techniques，这样 launcher 就可以使用最佳分辨率的来显示。</p><p>看完官方解释我表示没懂啊 T T</p><p>最后 google 还提了一句：</p><blockquote><p>Note: Even if you build a single APK for all devices, it is still best practice to move your launcher icons to the mipmap&#x2F; folders.</p></blockquote><p>这话的意思是如果我们是开发一个全设备通用的 app（现在不都这样么），图片资源包括 ic_launcher 还是可以像以前一样放在 drawable 文件夹内，也没有上面所说的影响咯？</p><p>stackoverflow 上有相关的问题：<a href="http://stackoverflow.com/questions/23935810/mipmap-drawables-for-icons">http://stackoverflow.com/questions/23935810/mipmap-drawables-for-icons</a>。看了其中的答案还是有些疑问。</p><h2 id="不算总结的总结"><a href="#不算总结的总结" class="headerlink" title="不算总结的总结"></a>不算总结的总结</h2><ol><li>mipmap 文件夹仅仅建议放启动图标，其文件夹下的图标会通过 mipmap 技术进行优化。</li><li>如果我们只开发所有设备通用的 apk，应用图标放不放到 mipmap 文件夹下都无所谓，不过官方建议应用图标以后都放倒 mipmap 文件夹里。</li></ol><h2 id="留有的疑问"><a href="#留有的疑问" class="headerlink" title="留有的疑问"></a>留有的疑问</h2><ol><li>是否需要把所有的图片资源都放到 mipmap 文件夹内？都放进去会有做什么 mipmap 优化吗？</li><li>如果是像素密度特定的 apk，为啥会导致 launcher 上的图标变模糊？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android M的运行时权限相关要点</title>
      <link href="/2016-03-08/Android%20M%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E8%A6%81%E7%82%B9/"/>
      <url>/2016-03-08/Android%20M%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2016-11-17 更新：如果已经了解运行时权限的基本使用，可以直接参考这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NDkxMTgyNw==&mid=2653058365&idx=1&sn=022b5828d1711a4efb5fbb6f17abae68&chksm=bd5656018a21df1765e6b272fdecd03a4cd6ccb6784b60842cddf32e8ee5a51dc9fdd26ee4c8&scene=0#rd">Android M 权限最佳实践</a></p></blockquote><p>样例代码：<a href="https://github.com/kinneyyan/RuntimePermissionSample">https://github.com/kinneyyan/RuntimePermissionSample</a></p><h2 id="1-新的权限机制"><a href="#1-新的权限机制" class="headerlink" title="1. 新的权限机制"></a>1. 新的权限机制</h2><p>6.0 开始将权限分为两类。</p><p>一类是 Normal Permissions，这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等。此类权限在应用安装时就被授予（同 6.0 之前）。</p><p>另一类是 Dangerous Permission，一般是涉及到用户隐私的，在 app 使用时需要用户进行授权，比如读取 sdcard、访问通讯录等。此类权限是分组的：</p><p><img src="http://inthecheesefactory.com/uploads/source/blog/mpermission/permgroup.png" alt="image"></p><p>同一组的任何一个权限被授权了，其他权限也自动被授权。</p><blockquote><p>2016-03-11 更新：所有需要申请的权限还是必须在 AndroidManifest 中声明，否则，即使同组一个权限被授权了，一个未在 AndroidManifest 中声明的权限授权还是会失败。</p></blockquote><h2 id="2-关于-targetSdkVersion-需要注意的"><a href="#2-关于-targetSdkVersion-需要注意的" class="headerlink" title="2. 关于 targetSdkVersion 需要注意的"></a>2. 关于 targetSdkVersion 需要注意的</h2><ul><li>若 targetSdkVersion 低于 23，将使用旧有规则：用户在安装的时候不得不接受所有权限，安装后 app 就有了那些权限。不过用户依然可以在设置中取消已经同意的授权。</li><li>若 targetSdkVersion 高于 23，如果 app 在使用一些敏感权限的时候没有做运行时权限的代码处理，app 会直接 crash。</li></ul><h2 id="3-相关-API-以及使用步骤"><a href="#3-相关-API-以及使用步骤" class="headerlink" title="3. 相关 API 以及使用步骤"></a>3. 相关 API 以及使用步骤</h2><p>假设我们的 app 有添加联系人的功能：</p><ol><li>在 AndroidManifest 文件中添加需要的权限 android.permission.WRITE_CONTACTS</li><li>在添加联系人的代码之前，检查权限</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hasWriteContactsPermission</span> <span class="operator">=</span> ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.WRITE_CONTACTS);</span><br><span class="line"><span class="keyword">if</span> (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"><span class="comment">//申请授权</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加联系人</span></span><br><span class="line">insertDummyContact();</span><br></pre></td></tr></table></figure><p><code>ContextCompat.checkSelfPermission</code>：用于检测某个权限是否已经被授予，返回值为<code>PackageManager.PERMISSION_DENIED</code>或者<code>PackageManager.PERMISSION_GRANTED</code></p><ol start="3"><li>申请授权</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.WRITE_CONTACTS&#125;, REQUEST_CODE_WRITE_CONTACTS);</span><br></pre></td></tr></table></figure><p><code>ActivityCompat.requestPermissions</code>：第一个参数是 Context；第二个参数是需要申请的权限的字符串数组，很明显这里可以一次申请多个；第三个参数为 requestCode，主要用于回调的时候检测。</p><ol start="4"><li>处理申请回调。不论用户同意还是拒绝，activity 的 onRequestPermissionsResult 都会被回调来通知结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, String[] permissions, <span class="type">int</span>[] grantResults)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line"><span class="keyword">case</span> REQUEST_CODE_WRITE_CONTACTS:</span><br><span class="line"><span class="comment">// Permission Granted</span></span><br><span class="line"><span class="keyword">if</span> (grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        insertDummyContact();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Permission Denied</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;WRITE_CONTACTS permission denied&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)</code>：第一个参数 requestCode 不用说；第二个参数为申请的权限，例如 Manifest.permission.WRITE_CONTACTS；第三个参数为申请结果。如果此次回调是一次申请多个权限的情况，那第二个参数和第三个参数为对应关系。</p><p>至此权限申请的步骤走通，不过还有个 API 需要提下：</p><p><code>ActivityCompat.shouldShowRequestPermissionRationale(Activity activity, String permission)</code>：该方法只有在用户在上一次已经拒绝过你的这个权限申请时返回 true；其余情况例如用户勾选了”不再显示”时均返回 false。这个 API 的目的主要用于给用户一个申请权限的解释，我们可以弹个对话框告知用户为什么需要这个权限，点击确定时再去申请权限。加入此方法的申请权限代码如下：<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hasWriteContactsPermission</span> <span class="operator">=</span> ContextCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.WRITE_CONTACTS);</span><br><span class="line"><span class="keyword">if</span> (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"><span class="comment">//该方法只有在用户在上一次已经拒绝过你的这个权限申请返回true;勾选了&quot;不再显示&quot;时返回false</span></span><br><span class="line"><span class="comment">//你需要给用户一个解释，为什么要授权</span></span><br><span class="line"><span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="built_in">this</span>, Manifest.permission.WRITE_CONTACTS)) &#123;</span><br><span class="line">showConfirmDialog(<span class="string">&quot;please accept WRITE_CONTACTS permission request.&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialog, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">ActivityCompat.requestPermissions(MainActivity.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.WRITE_CONTACTS&#125;, REQUEST_CODE_WRITE_CONTACTS);&#125;&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.WRITE_CONTACTS&#125;, REQUEST_CODE_WRITE_CONTACTS);</span><br><span class="line">&#125;</span><br><span class="line">insertDummyContact();</span><br></pre></td></tr></table></figure><p>如果用户勾选了“不再显示”拒绝后，再次申请权限时，在 onRequestPermissionsResult 回调方法中走权限拒绝的方法，如果用户又想开启此权限的话，我们可以通过 shouldShowRequestPermissionRationale 返回值判断是否勾选“不再显示”，是的话在回调方法判断权限拒绝的代码块中弹一个对话框告知用户：在设置－应用－权限管理中去开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REQUEST_CODE_WRITE_CONTACTS:</span><br><span class="line"><span class="comment">// Permission Granted</span></span><br><span class="line"><span class="keyword">if</span> (grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">insertDummyContact();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Permission Denied</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//若用户在拒绝权限时勾选了&quot;不再显示&quot;,显示对话框提示用户</span></span><br><span class="line"><span class="keyword">if</span> (!ActivityCompat.shouldShowRequestPermissionRationale(<span class="built_in">this</span>, Manifest.permission.WRITE_CONTACTS)) &#123;</span><br><span class="line">    showConfirmDialog(<span class="string">&quot;WRITE_CONTACTS permission denied, please enable it in Settings-Apps.&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;WRITE_CONTACTS permission denied&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="4-第三方开源库"><a href="#4-第三方开源库" class="headerlink" title="4. 第三方开源库"></a>4. 第三方开源库</h2><p>前两个使用了注解</p><ul><li><a href="https://github.com/hotchemi/PermissionsDispatcher">PermissionsDispatcher</a></li><li><a href="https://github.com/hongyangAndroid/MPermissions">MPermissions</a></li><li><a href="https://github.com/Karumi/Dexter">Dexter</a></li><li><a href="https://github.com/ParkSangGwon/TedPermission">TedPermission</a></li></ul><hr><blockquote><p>参考文章<br><a href="http://jijiaxin89.com/2015/08/30/Android-s-Runtime-Permission/">Android M 新的运行时权限开发者需要知道的一切</a> &gt; <a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=402456158&idx=1&sn=67d952c5fc3fb7876fc14783be6ab50a&scene=0#rd">Android 6.0 运行时权限处理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中分割线的常见做法</title>
      <link href="/2016-01-18/Android%E4%B8%AD%E5%88%86%E5%89%B2%E7%BA%BF%E7%9A%84%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95/"/>
      <url>/2016-01-18/Android%E4%B8%AD%E5%88%86%E5%89%B2%E7%BA%BF%E7%9A%84%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时我们在开发中做分割线是非常频繁的事情，这里总结一下水平、垂直的实线、虚线的常见做法。对于垂直虚线给出了比较靠谱的解决方法。</p><h2 id="水平、垂直实线"><a href="#水平、垂直实线" class="headerlink" title="水平、垂直实线"></a>水平、垂直实线</h2><p>1 若是在 LineayLayout 中需要添加分割线，可以在布局文件中使用如下两个属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:divider=&quot;@drawable&quot;</span><br><span class="line">android:showDividers = &quot;middle|end|beginning|none&quot;</span><br></pre></td></tr></table></figure><ul><li>android:divider：可以是图片文件，也可以是 xml 绘制的 shape。</li><li>android:showDividers：<ul><li>middle 在每一项中间添加分割线</li><li>end 在整体的最后一项添加分割线</li><li>beginning 在整体的最上方添加分割线</li><li>none 无</li></ul></li></ul><p>2 在每一项之间添加一个 view，设置宽高、背景。</p><p>3 对每一项设置带有下划线的背景。一般用 shape 去做：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;@color/alLineColor&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">size</span> <span class="attr">android:height</span>=<span class="string">&quot;1px&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:bottom</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;@color/alWhiteColor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4 使用 ListView 默认的 divider，或者设置 android:divider。</p><h2 id="水平虚线"><a href="#水平虚线" class="headerlink" title="水平虚线"></a>水平虚线</h2><p>用 shape：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">&quot;line&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stroke</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">&quot;1dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dashGap</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dashWidth</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">&quot;#63a219&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><p>width 指横线的高度，dashGap 指间隔宽度，dashWidth 指每个破折线的长度。</p><h2 id="垂直虚线"><a href="#垂直虚线" class="headerlink" title="垂直虚线"></a>垂直虚线</h2><p>本来想根据水平虚线的做法，使用 rotate 标签旋转 90 度。但是在实际使用中虚线的宽高并不能很好的自定义。最后还是自定义 view 来做,支持在布局文件中指定宽高、margin。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerticalDashView</span> <span class="keyword">extends</span> <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Paint paint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerticalDashView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerticalDashView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VerticalDashView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">widthSize</span> <span class="operator">=</span> MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        paint.setStrokeWidth(widthSize);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        paint = <span class="keyword">new</span> <span class="title class_">Paint</span>(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setColor(getResources().getColor(R.color.brokerLightLightGrayColor));</span><br><span class="line">        setLayerType(LAYER_TYPE_SOFTWARE, paint);</span><br><span class="line">        <span class="type">PathEffect</span> <span class="variable">effects</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DashPathEffect</span>(<span class="keyword">new</span> <span class="title class_">float</span>[]&#123;<span class="number">10</span>, <span class="number">10</span>&#125;, <span class="number">1</span>);</span><br><span class="line">        paint.setPathEffect(effects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        canvas.drawLine(<span class="number">0</span>, getTop(), <span class="number">0</span>, getBottom(), paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于 DashPathEffect 的参数含义，参考官网或<a href="http://blog.sina.com.cn/s/blog_8a86f4dd01018f7v.html">http://blog.sina.com.cn/s/blog_8a86f4dd01018f7v.html</a></li></ul><p>ps：水平、垂直虚线在 3.0 以上要正确显示的话，需要在 AndroidManifest.xml 中关闭硬件加速：android:hardwareAccelerated&#x3D;”false”。或者 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActionBar自定义样式总结</title>
      <link href="/2015-09-30/ActionBar%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2015-09-30/ActionBar%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>以下所有的配置都在 style.xml 中，使用 Theme.AppCompat</p><ul><li>自定义 ActionBar 背景、标题字体样式（背景的自定义如果配合使用 Toolbar 完全可以设置 colorPrimary 属性，没必要用以下的方法）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;CustomActionBarTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/Theme.AppCompat&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:actionBarStyle&quot;</span>&gt;</span>@style/MyActionBar<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;actionBarStyle&quot;</span>&gt;</span>@style/MyActionBar<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;MyActionBar&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/Widget.AppCompat.ActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>#33B5E5<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;background&quot;</span>&gt;</span>@drawable/actionbar_bk<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:titleTextStyle&quot;</span>&gt;</span>@style/MyActionBarTitleText<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;titleTextStyle&quot;</span>&gt;</span>@style/MyActionBarTitleText<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"></span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;MyActionBarTitleText&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>#00FF00<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>自定义 action button、overflow menu 样式（overflow menu 也就是我们通常在 ActionBar 右侧点击三个点出现的 PopupMenu）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;CustomOverflowMenuTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/Theme.AppCompat&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 无icon纯文字的actionButton样式 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:actionMenuTextAppearance&quot;</span>&gt;</span>@style/DarkGrayH3TextStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;actionMenuTextAppearance&quot;</span>&gt;</span>@style/DarkGrayH3TextStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 有icon的actionButton样式 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:actionButtonStyle&quot;</span>&gt;</span>@style/ActionButtonStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;actionButtonStyle&quot;</span>&gt;</span>@style/ActionButtonStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- overflowMenu的按钮样式 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:actionOverflowButtonStyle&quot;</span>&gt;</span>@style/OverflowButtonStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;actionOverflowButtonStyle&quot;</span>&gt;</span>@style/OverflowButtonStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- overflowMenu的整体样式 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;actionOverflowMenuStyle&quot;</span>&gt;</span>@style/OverflowMenuStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;DarkGrayH3TextStyle&quot;</span>&gt;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>@color/alDarkGrayColor<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>@dimen/alH3Font<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        </span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;ActionButtonStyle&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/Widget.AppCompat.ActionButton&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;OverflowButtonStyle&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/Widget.AppCompat.ActionButton.Overflow&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;OverflowMenuStyle&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/Widget.AppCompat.PopupMenu.Overflow&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;overlapAnchor&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;item name=&quot;android:popupBackground&quot;&gt;?attr/colorPrimary&lt;/item&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;item name=&quot;android:dropDownWidth&quot;&gt;wrap_content&lt;/item&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;item name=&quot;android:paddingRight&quot;&gt;4dp&lt;/item&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;item name=&quot;android:paddingLeft&quot;&gt;4dp&lt;/item&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;item name=&quot;android:dropDownVerticalOffset&quot;&gt;?attr/actionBarSize&lt;/item&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--&lt;item name=&quot;android:dropDownHorizontalOffset&quot;&gt;-4dp&lt;/item&gt;--&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>自定义 Toolbar 的 NavigationButton（也就是 Toolbar 左侧的一个按钮）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/Theme.AppCompat&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;toolbarNavigationButtonStyle&quot;</span>&gt;</span>@style/NavigationButtonStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;NavigationButtonStyle&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Widget.AppCompat.Toolbar.Button.Navigation&quot;</span>&gt;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:minWidth&quot;</span>&gt;</span>0dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:paddingLeft&quot;</span>&gt;</span>13dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:paddingRight&quot;</span>&gt;</span>3dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">    </span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 SectionIndexer 实现微信通讯录的效果</title>
      <link href="/2015-05-21/%E4%BD%BF%E7%94%A8SectionIndexer%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E6%95%88%E6%9E%9C/"/>
      <url>/2015-05-21/%E4%BD%BF%E7%94%A8SectionIndexer%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E9%80%9A%E8%AE%AF%E5%BD%95%E7%9A%84%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>最近在公司项目中看到用 SectionIndexer 来实现 ListView 的分组滚动实现通讯录导航的效果，这里我单独的写个 demo 出来。</p><p><a href="http://developer.android.com/reference/android/widget/SectionIndexer.html">SectionIndexer</a>：根据官方文档说，它是一个给 Adapter 去实现、用来在 AbsListView 中实现 section 之间的快速滚动的接口（翻译拙计见谅）。一个 section 相当于一组具有共同特性的 list 数据。比如，它们有相同的首字母。</p><p>知道它的定义了，那怎么使用它呢？本人口拙，咱们还是上代码说话~</p><p>先看要实现的效果图：</p><p><img src="http://i1.tietuku.com/dfd7394e85c32299.gif" alt="SectionIndexerDemo.gif" title="SectionIndexerDemo"></p><span id="more"></span><ol><li>activity 的布局文件</li></ol><figure class="highlight xml"><figcaption><span>activity_main.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_lv&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--显示在屏幕中央的字母--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_mask_tv&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;40sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@android:color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#33000000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:visibility</span>=<span class="string">&quot;visible&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">&quot;A&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--字母导航栏--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.shiyan.sectionindexerdemo.SideBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_sb&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>ListView 的 item 布局</li></ol><figure class="highlight xml"><figcaption><span>main_listview_item.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--section，表示组--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/section_tv&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;22sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@android:color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@android:color/holo_green_light&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">&quot;section&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/normal_tv&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;6dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>页面右侧的字母导航栏，继承了 View，核心部分在 onTouchEvent 方法中</li></ol><figure class="highlight java"><figcaption><span>SideBar.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SideBar</span> <span class="keyword">extends</span> <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] letters = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Paint paint;<span class="comment">//绘制字母的画笔</span></span><br><span class="line">    <span class="keyword">private</span> SectionIndexer sectionIndexer;</span><br><span class="line">    <span class="keyword">private</span> ListView mListView;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> drawWidth;<span class="comment">//要绘制的单个字母的宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> drawHeight;<span class="comment">//要绘制的单个字母的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">focusedIndex</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//点击选中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听当前点击的字母的接口，供外部实现</span></span><br><span class="line">    <span class="keyword">private</span> OnTouchChangedListener listener;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnTouchChangedListener</span><span class="params">(OnTouchChangedListener listener)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnTouchChangedListener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onTouchDown</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onTouchUp</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setListView</span><span class="params">(ListView mListView)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mListView = mListView;</span><br><span class="line">        sectionIndexer = (SectionIndexer) mListView.getAdapter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SideBar</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SideBar</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SideBar</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyle);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置字母的画笔属性</span></span><br><span class="line">        paint = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        paint.setColor(Color.GRAY);</span><br><span class="line">        paint.setTextSize(DisplayUtil.sp2px(getContext(), <span class="number">18f</span>));</span><br><span class="line">        paint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        drawWidth = getMeasuredWidth() / <span class="number">2</span>;<span class="comment">//宽度为整个SideBar宽度的一半</span></span><br><span class="line">        drawHeight = getMeasuredHeight() / letters.length;<span class="comment">//高度为整个SideBar高度除以索引的个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length; i++) &#123;</span><br><span class="line">            canvas.drawText(String.valueOf(letters[i]), drawWidth, drawHeight + (i * drawHeight), paint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pointerY</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">        <span class="comment">//点击的y坐标 / 整体高度 * 数组的长度 = 数组的某一索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">selectedIndex</span> <span class="operator">=</span> pointerY / drawHeight;</span><br><span class="line">        <span class="keyword">if</span> (selectedIndex &gt;= letters.length) &#123;</span><br><span class="line">            selectedIndex = letters.length - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectedIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            selectedIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">//点击时设置半透明的背景色</span></span><br><span class="line">                setBackgroundColor(Color.parseColor(<span class="string">&quot;#33000000&quot;</span>));</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (sectionIndexer == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sectionIndexer = (SectionIndexer) mListView.getAdapter();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据数组中的元素获取对应的组位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> sectionIndexer.getPositionForSection(letters[selectedIndex]);</span><br><span class="line">                <span class="keyword">if</span> (position == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//改变当前ListView的所处的位置</span></span><br><span class="line">                mListView.setSelection(position);</span><br><span class="line">                <span class="comment">//重绘SideBar</span></span><br><span class="line">                invalidate();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//供外部实现，监听当前点击的字母</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != listener) &#123;</span><br><span class="line">                    listener.onTouchDown(letters[selectedIndex]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="comment">//松开手指时取消背景色</span></span><br><span class="line">                setBackgroundResource(android.R.color.transparent);</span><br><span class="line">                <span class="comment">//重绘SideBar</span></span><br><span class="line">                invalidate();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != listener) &#123;</span><br><span class="line">                    listener.onTouchUp();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>ListView 的 Adapter，在这里我们实现了 SectionIndexer 接口，需要实现接口中的三个方法，见代码</li></ol><figure class="highlight java"><figcaption><span>MyAdapter.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdapter</span> <span class="keyword">extends</span> <span class="title class_">BaseAdapter</span> <span class="keyword">implements</span> <span class="title class_">SectionIndexer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater layoutInflater;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; stringList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAdapter</span><span class="params">(Context context, List&lt;String&gt; stringList)</span> &#123;</span><br><span class="line">        layoutInflater = LayoutInflater.from(context);</span><br><span class="line">        <span class="built_in">this</span>.stringList = stringList;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getItemId</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">        ViewHolder viewHolder;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == convertView) &#123;</span><br><span class="line">            convertView = layoutInflater.inflate(R.layout.main_listview_item, parent, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            viewHolder = <span class="keyword">new</span> <span class="title class_">ViewHolder</span>();</span><br><span class="line">            viewHolder.normalTv = (TextView) convertView.findViewById(R.id.normal_tv);<span class="comment">//普通项view</span></span><br><span class="line">            viewHolder.sectionTv = (TextView) convertView.findViewById(R.id.section_tv);<span class="comment">//组view</span></span><br><span class="line"></span><br><span class="line">            convertView.setTag(viewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            viewHolder = (ViewHolder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> stringList.get(position);</span><br><span class="line">        setSectionTv(position, viewHolder, label);</span><br><span class="line">        setNormalTv(viewHolder, label);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNormalTv</span><span class="params">(ViewHolder viewHolder, String label)</span> &#123;</span><br><span class="line">        viewHolder.normalTv.setText(label);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSectionTv</span><span class="params">(<span class="type">int</span> position, ViewHolder viewHolder, String label)</span> &#123;</span><br><span class="line">        <span class="comment">//获取每个item字符串的头一个字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> label.toUpperCase().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//若为第一个位置直接设置组view就行</span></span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">            viewHolder.sectionTv.setVisibility(View.VISIBLE);</span><br><span class="line">            viewHolder.sectionTv.setText(label.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若不是，需判断当前item首字母与上一个item首字母是否一致，再设置组view</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preLabel</span> <span class="operator">=</span> stringList.get(position - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//获取上一个item的首字母</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">preFirstChar</span> <span class="operator">=</span> preLabel.toUpperCase().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (firstChar != preFirstChar) &#123;</span><br><span class="line">                viewHolder.sectionTv.setVisibility(View.VISIBLE);</span><br><span class="line">                viewHolder.sectionTv.setText(label.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若与上一个item首字母一致则不需要重复设置组view</span></span><br><span class="line">                viewHolder.sectionTv.setVisibility(View.GONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPositionForSection</span><span class="params">(<span class="type">int</span> section)</span> &#123;</span><br><span class="line">        <span class="comment">//根据组信息获取索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringList.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringList.get(i);</span><br><span class="line">            <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str.toUpperCase().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (firstChar == section) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSectionForPosition</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="comment">//根据索引获取组信息，这里不做处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getSections() &#123;</span><br><span class="line">        <span class="comment">//获取组信息的数组，比如这里可以返回char[]&#123;&#x27;A&#x27;,&#x27;B&#x27;,...&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span> &#123;</span><br><span class="line">        TextView normalTv;</span><br><span class="line">        TextView sectionTv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>提供的列表数据若未按字母排序，需要按字母排序。</li></ol><figure class="highlight java"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要显示的列表数据，未按字母顺序排列</span></span><br><span class="line">    <span class="keyword">final</span> String[] strings = &#123;<span class="string">&quot;ooo&quot;</span>,<span class="string">&quot;abb&quot;</span>,<span class="string">&quot;zzz&quot;</span>,<span class="string">&quot;ppp&quot;</span>,<span class="string">&quot;bcc&quot;</span>,<span class="string">&quot;ppq&quot;</span>,<span class="string">&quot;eee&quot;</span>,<span class="string">&quot;eff&quot;</span>,<span class="string">&quot;fgg&quot;</span>,<span class="string">&quot;sss&quot;</span>,<span class="string">&quot;ghh&quot;</span>,<span class="string">&quot;hhh&quot;</span>,<span class="string">&quot;iii&quot;</span>,<span class="string">&quot;vvv&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jkk&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;kkk&quot;</span>,<span class="string">&quot;yyy&quot;</span>,<span class="string">&quot;lll&quot;</span>,<span class="string">&quot;mmm&quot;</span>,<span class="string">&quot;nnn&quot;</span>,<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;bdd&quot;</span>,<span class="string">&quot;qqq&quot;</span>,<span class="string">&quot;qrr&quot;</span>,<span class="string">&quot;rrr&quot;</span>,<span class="string">&quot;ggg&quot;</span>,<span class="string">&quot;srr&quot;</span>,<span class="string">&quot;ttt&quot;</span>,<span class="string">&quot;tfg&quot;</span>,<span class="string">&quot;uuu&quot;</span>,</span><br><span class="line">            <span class="string">&quot;jjj&quot;</span>,<span class="string">&quot;www&quot;</span>,<span class="string">&quot;www&quot;</span>,<span class="string">&quot;wwe&quot;</span>,<span class="string">&quot;wwg&quot;</span>,<span class="string">&quot;xxt&quot;</span>,<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;kin&quot;</span>,<span class="string">&quot;acc&quot;</span>,<span class="string">&quot;was&quot;</span>,<span class="string">&quot;wtg&quot;</span>,<span class="string">&quot;wfg&quot;</span>,<span class="string">&quot;brg&quot;</span>,<span class="string">&quot;hqq&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ListView mListView;</span><br><span class="line">    TextView maskTv;<span class="comment">//显示在屏幕中央的字母浮层</span></span><br><span class="line">    SideBar mSideBar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        findViews();</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">            stringList.add(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对列表数据进行按字母排序</span></span><br><span class="line">        Collections.sort(stringList);</span><br><span class="line">        <span class="keyword">return</span> stringList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAdapter</span>(<span class="built_in">this</span>, initList());</span><br><span class="line">        mListView.setAdapter(adapter);</span><br><span class="line">        mSideBar.setListView(mListView);</span><br><span class="line">        mSideBar.setOnTouchChangedListener(<span class="keyword">new</span> <span class="title class_">SideBar</span>.OnTouchChangedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTouchDown</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">                maskTv.setVisibility(View.VISIBLE);</span><br><span class="line">                maskTv.setText(c+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTouchUp</span><span class="params">()</span> &#123;</span><br><span class="line">                maskTv.setVisibility(View.GONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findViews</span><span class="params">()</span> &#123;</span><br><span class="line">        mListView = (ListView) findViewById(R.id.main_lv);</span><br><span class="line">        maskTv = (TextView) findViewById(R.id.main_mask_tv);</span><br><span class="line">        mSideBar = (SideBar) findViewById(R.id.main_sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写线程安全的单例模式</title>
      <link href="/2015-05-12/%E5%A6%82%E4%BD%95%E5%86%99%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015-05-12/%E5%A6%82%E4%BD%95%E5%86%99%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>前几天面试要写一个单例模式，我想这还不简单，唰唰几下后面试官又抛出了问题：如何应对多线程并行使用的情况？oshit……之前写单例都没有特别考虑过线程安全的问题，当时我是在获取实例变量的方法改成了同步方法，面试官说这样并不高效，同步操作只会在第一次调用时才被需要。当时有点懵了，不知道怎么搞了，后来写了个饿汉式的单例模式给他……面试官也没深究下去，囧。</p><p>所以回来后查读了一些博文，觉的还是有必要对单例模式的写法做个总结，特别是如何写个线程安全的单例模式。</p><ul><li>懒汉式-线程不安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，也使用了懒加载。但当有多个线程并行调用 getInstance() 的时候，就会创建多个实例，显然不符合单例，这也是我当时面试时写的&#x3D; &#x3D;。当然如果项目中不需要针对多线程的情况时，这种写法都是适用的。</p><ul><li>懒汉式-线程安全</li></ul><p>主要就是把 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。</p><ul><li>饿汉式-线程安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><p>缺点是它不是一种懒加载模式，单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p><ul><li>静态内部类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法仍然使用 JVM 本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><ul><li>单元素枚举类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;枚举元素</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Singleton.INSTANCE 来访问实例，这比调用 getInstance()方法简单多了。这种方法在功能上和公有域的方法相近，但是这样的方式更加简洁，可以提供序列化机制，可以绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候，虽然现在这样的方式使用较少，但是这样的方法是最佳的方式。</p><hr><p>以上是单例模式主流的几种写法，包括线程安全的。一般来说，如果项目中不需要针对多线程情况的话，懒汉式、饿汉式的写法都适用；如果需要保证多线程并行使用推荐静态内部类和枚举（最简单，用的人少- -）。</p><p>（完）</p><hr><blockquote><p>参考文章：<br><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/#">http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/#</a> &gt; <a href="http://chenqichao.me/2014/09/12/065-Effetive-Java-Item-03/">http://chenqichao.me/2014/09/12/065-Effetive-Java-Item-03/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android的tools命名空间使用详解-2</title>
      <link href="/2015-03-21/Android%E7%9A%84tools%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-2/"/>
      <url>/2015-03-21/Android%E7%9A%84tools%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://medium.com/sebs-top-tips/tools-of-the-trade-part-2-b91271892d10">https://medium.com/sebs-top-tips/tools-of-the-trade-part-2-b91271892d10</a></p></blockquote><p>在上篇文章中我们了解到 tools 命名空间可以被用来只在写 xml 布局文件期间覆盖任何 attribute，也可以帮助我们更好地使用 Lint。当然，tools attributes 还有其他为我们所做的。</p><hr><h4 id="UI-attributes"><a href="#UI-attributes" class="headerlink" title="UI attributes"></a>UI attributes</h4><p>tools 命名空间剩下的所有 8 个 attributes 都是和 IDE 的 UI 预览面板有关，所以称之为 UI attributes。</p><p>这些 UI attributes 在你使用 IDE 写 layout 文件时会让一些工作更加简单方便。这些 attributes 包括：</p><ul><li>tools:context</li><li>tools:menu</li><li>tools:actionBarNavMode</li><li>tools:listitem&#x2F;listheader&#x2F;listfooter</li><li>tools:showIn</li><li>tools:layout</li></ul><p><strong>The context attribute</strong></p><p>context attribute 是用来告诉 IDE 你的 layout 文件是由哪个 Context 所解析。这样预览面板自动选择相应的主题，此外在 AS 中，在类文件中打开 Go to Related files 选项更准确得索引到 layout 文件。</p><p>attribute 的值为包含包名的 Activity，写在 layout 的根节点中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/container&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:context</span>=<span class="string">&quot;com.android.example.MainActivity&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">​<span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>The menu attribute</strong></p><p>menu attribute 用来告诉 IDE 预览面板中显示哪个 menu。同样的，写在 layout 的根节点中。</p><p>如果你使用了刚刚介绍的 context attribute 声明了对应的 activity，那 IDE 就会在 onCreateOptionsMenu 尝试检查出你所使用的 menu 文件，然后显示在预览面板上。但我们若使用了 menu attribute 的话，预览面板就会显示我们所声明的 menu。</p><p>在这个 attribute 中你可以定义一个或多个 menu 的 XML 文件，只需要写 menu 的文件名即可，以逗号隔开，形如：<code>tools:menu=&quot;menu_main,menu_edit&quot;</code></p><p>要不显示 menu，只要把值设空：<code>tools:menu=&quot;&quot;</code></p><p>还有一点需要注意的是，当你设置的主题基于 Theme.AppCompat 时，以上 attribute 就不起作用了。</p><p><strong>The actionBarNavMode attribute</strong></p><p>这个 attribute 用来确定预览面板中 Action Bar 应该显示何种的导航模式。有以下 3 种：</p><ul><li>standard</li><li>tabs</li><li>list</li></ul><p>ps：这个 attribute 在你使用基于 Theme.AppCompat 或 Theme.Material 的主题时、或你在 layout 中有使用 Toolbar 控件的时候是不起作用的。只有 app 是基于 holo 风格的主题才会有效。</p><p><strong>The listitem, listheader and listfooter attributes</strong></p><p><img src="https://d262ilb51hltx0.cloudfront.net/max/600/1*ykykwHX0xB-3FnUo-K7MMA.png"></p><p>当在 layout 文件中有基于 AbsListView 的控件时，预览面板一般都只会显示常规的预览图。使用了 listitem、listheader 和 listfooter attributes 的话，你可以指定选择预览面板中显示 list items、header 和 footer 的 layout 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/list&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:listheader</span>=<span class="string">&quot;@layout/list_header&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:listitem</span>=<span class="string">&quot;@layout/list_item&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:listfooter</span>=<span class="string">&quot;@layout/list_footer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>但是这里请注意，GridView 只有 listitem attribute 有效果。</p><p><img src="https://d262ilb51hltx0.cloudfront.net/max/913/1*_3k2qGwN19tZFjUO_pzaSw.jpeg"></p><p>当然，RecyclerView 使用以上的 attribute 也是没用的，它都不继承自 AbsListView 啊……</p><p><strong>The layout attribute</strong></p><p>这个 attribute 用来告诉预览面板在运行时哪个 layout 文件会被解析到一个 fragment（在 onCreateView()中）。它与你使用 include 标签的 layout attribute 相类似。</p><p><img src="https://d262ilb51hltx0.cloudfront.net/max/1400/1*f5uMzpfa227Fr1RhNcunEw.png"></p><p><strong>The showIn attribute</strong></p><p>这个 attribute 适用于你使用 include 标签的 layout attribute 所指定的 layout 文件是以 merge 标签为根节点的情况。（介绍太长不翻了。。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:showIn</span>=<span class="string">&quot;@layout/activity_main&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://d262ilb51hltx0.cloudfront.net/max/757/1*9QdrcTjxpJO15RVmUmL5Iw.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>tools 命名空间的使用为的是提高我们的开发效率，很多的工作都可以通过 IDE 帮我们来完成，何乐而不为呢？</p><p>引用博主的最后一句话：</p><blockquote><h3 id="Don’t-be-a-tool-use-the-tools"><a href="#Don’t-be-a-tool-use-the-tools" class="headerlink" title="Don’t be a tool, use the tools."></a>Don’t be a tool, use the tools.</h3></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android的tools命名空间使用详解-1</title>
      <link href="/2015-03-19/Android%E7%9A%84tools%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-1/"/>
      <url>/2015-03-19/Android%E7%9A%84tools%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-1/</url>
      
        <content type="html"><![CDATA[<p>想必 android 开发的小伙伴在布局文件中经常会看到 <code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></p><p>但是实际开发过程中我们却很少用到 tools 中的东西。</p><p>最近读了国外写的关于 tools 命名空间的博文，觉得很有必要写一篇中文版的。英文好的小伙伴直接去看原文吧~</p><blockquote><p>原文链接：<a href="https://medium.com/sebs-top-tips/tools-of-the-trade-part-1-f3c1c73de898">https://medium.com/sebs-top-tips/tools-of-the-trade-part-1-f3c1c73de898</a></p></blockquote><hr><p>在写 android 的 layout 文件时，我们经常会遇到这样一种情况：布局里有好多 TextView，但是又想在 IDE 中看到预览效果，怎么办？通常我们都会这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/text_main&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:textAppearance</span>=<span class="string">&quot;@style/TextAppearance.Title&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_margin</span>=<span class="string">&quot;@dimen/main_margin&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">&quot;I am a title&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>直接在 TextView 中写上假数据看效果，但是很有可能写完布局文件你就忘了删了。导致的结果就是上线的 app 很有可能让用户看到你写的假数据不知所云。如何解决？so easy：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/text_main&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:textAppearance</span>=<span class="string">&quot;@style/TextAppearance.Title&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_margin</span>=<span class="string">&quot;@dimen/main_margin&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:text</span>=<span class="string">&quot;I am a title&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>只要改成上面这样，你既可以看到布局的预览图效果，也不会影响最终的 app。当然记得在布局文件的根标签加上 <code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></p><hr><p>tools attributes 其实可以被分为两类。第一类包含了所有的 attributes，会影响到 Lint analysis；第二类包含了其他的一些 attributes，会影响使用 IDE 编写 XML 的时候。</p><h4 id="Lint-attributes"><a href="#Lint-attributes" class="headerlink" title="Lint attributes"></a>Lint attributes</h4><p>在 tools 命名空间中有 3 种 Lint attributes：</p><ul><li><p>tools:ignore</p></li><li><p>tools:targetApi</p></li><li><p>tools:locale</p></li></ul><p><strong>The ignore attribute</strong></p><p>这个 ignore attribute 基本等同于 Java 中的@SuppressWarnings 注解，告诉 Lint 忽略某方面的警告信息。比如我们有个 ImageView 没有设置 android:contentDescription，在 XML 中 Lint 就会有警告信息。我们可以加上 ignore attribute 来去除 Lint 的警告：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_marginStart</span>=<span class="string">&quot;@dimen/margin_main&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_marginTop</span>=<span class="string">&quot;@dimen/margin_main&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:scaleType</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:src</span>=<span class="string">&quot;@drawable/divider&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:ignore</span>=<span class="string">&quot;contentDescription&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>The targetApi attribute</strong></p><p>这个 attribute 等同于 Java 中的@TargetApi 注解，用来告诉 Lint 你在 XML<br>中使用的某一控件的最低 API 版本（这句直接从英文翻译过来，感觉解释不清楚）。举例子，你在 drawable 文件夹（未标记为-v21）下的一个 layout 文件中写了 5.0 才有的 ripple 控件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:color</span>=<span class="string">&quot;@color/accent_color&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这样写在通用的 drawable 下 Lint 肯定会报警告信息，如果你确定已经在 API20 以下的版本时会使用其他的 layout，那你可以使用 targetApi attribute 消除 Lint 警告：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:color</span>=<span class="string">&quot;@color/accent_color&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:targetApi</span>=<span class="string">&quot;LOLLIPOP&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>The locale attribute</strong></p><p>最后一个 attribute 是用来标明一个 resource 是针对某一地区的。这个属性在 tools 命名空间里用的很少。如果你的应用只针对说意大利语地区的人，那你在 res&#x2F;values&#x2F;strings.xml 可以这么写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">tools:locale</span>=<span class="string">&quot;it&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Your strings go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样 Android Studio 就知道你的 app 语言不是以英语为主，而且在 strings.xml 中不会进行 spell check。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑客与画家》读书笔记</title>
      <link href="/2015-02-01/%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2015-02-01/%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>《黑客与画家》最近一口气把它读完了，感觉非常适合程序猿、互联网从业者、创业者去好好读一读。以下整理了我在阅读过程中记录的书摘，受益匪浅。</p><ul><li>2 黑客与画家</li></ul><blockquote><p>再比如，我们使用代码的行数考核程序员的工作效率。这样的考核容易实施，而容易实施的考核总是首先被采用。</p></blockquote><blockquote><p>唯一有效的外部考核就是时间。经过岁月的洗礼，优美的东西生存发展的机会更大，丑陋的东西往往会被淘汰。不幸的是，这种考核需要的时间可能比一个人的生命还要长。塞缪尔· 约翰逊说过，人们对一个作家的评价，需要 100 年才能达成一致。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。</p></blockquote><blockquote><p>编程语言首要的特性应该是允许动态扩展（malleable）。编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。</p></blockquote><blockquote><p>绘画的这个创作过程就值得学习。我认为黑客也应该这样工作。你不能盼望先有一个完美的规格设计，然后再动手编程，这样想是不现实的。如果你预先承认规格设计是不完美的，在编程的时候，就可以根据需要当场修改规格，最终会有一个更好的结果。</p></blockquote><blockquote><p>我认为，这也是多人共同开发一个软件的正确模式。需要合作，但是不要“合”得过头。如果一个代码块由三四个人共同开发，就没有人真正“拥有”这块代码。最终，它就会变得像一个公用杂物间，没人管理，又脏又乱，到处堆满了冗余代码。正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。</p></blockquote><blockquote><p>判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎样向没有技术背景的人解释技术问题。</p></blockquote><ul><li>3 不能说的话</li></ul><blockquote><p>有时候，别人会对你说：“要根据社会需要，改造自己的思想（well-adjusted）。”这种说法隐含的意思似乎是，如果你不认同社会，那么肯定是你自己的问题。你同意这种说法吗？事实上，它不仅不对，而且会让历史倒退。如果你真的相信了它，凡是不认同社会之处，你连想都不敢想，马上就放弃自己的观点，那才会真正出问题。</p></blockquote><blockquote><p>如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。小时候，每个人都会鼓励你不断成长，变成一个心智成熟、不再耍小孩子脾气的人。但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。</p></blockquote><ul><li>5 另一条路</li></ul><blockquote><p>早一点发现 bug 就不容易形成复合式 bug，也就是互相影响的两个 bug。举例来说，一个 bug 是楼梯很滑，另一个 bug 是扶手松了，那么只有当这两个 bug 互相作用时，才会导致你从楼梯上摔下来。在软件中，复合式 bug 是最难发现的 bug，往往也会导致最大的损失。传统的方法是：“把软件彻底拆开，将所有 bug 统统清理干净。”这样做难免产生一大堆的复合式 bug。如果软件是经常性发布，每次只有小幅度的变化，那么就不容易产生复合式 bug。这就好比做扫除：你一直在打扫大厅，掉落在地板上的东西会被立刻清理，省得它们时间一长与其他东西粘在一起。</p></blockquote><blockquote><p>不要只因为对方的头衔是市场专家、设计师或产品经理，就盲目听从他们的话。如果他们的观点真的很好，那就听从他们，关键是你要自己判断，不要盲从。只有懂得设计的黑客，才能设计软件，不能交给对软件一知半解的设计师。如果你不打算自己动手设计和开发，那就不要创业。</p></blockquote><ul><li>6 如何创造财富</li></ul><blockquote><p>我们这个世界，你向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。许许多多不创造任何财富的人——比如本科生、记者和政客——一听到最富有的 5%人口占有全社会一半以上的财富，往往会认定这是不公平的。一个有经验的程序员很可能也认为这是不公平的。因为最顶尖的 5%的程序员写出了全世界 99%的优秀软件。</p></blockquote><blockquote><p>一个大学毕业生总是想“我需要一份工作”，别人也是这么对他说的，好像变成某个组织的成员是一件多么重要的事情。更直接的表达方式应该是“你需要去做一些人们需要的东西”。即使不加入公司，你也能做到。公司不过是一群人在一起工作，共同做出某种人们需要的东西。真正重要的是做出人们需要的东西，而不是加入某个公司。</p></blockquote><blockquote><p>大公司就像巨型的古罗马战舰，一千个划船手共同划桨，推动它前进。但是，两个因素使得它快不起来。一个因素是，每个划船手看不到自己更努力划桨有何不同；另一个因素是，一千人的团队使得任何个人的努力都被大大地平均化了。</p></blockquote><blockquote><p>这不仅是创业公司运作的好方法，更是创业公司的本质。风险投资商（VC）知道这个道理，为它起了一个名字——进入壁垒（barriers to entry）。如果你有一个新点子去找 VC，问他是否投资，他首先就会问你几个问题，其中之一就是其他人复制你的模式是否很困难。也就是说，你为竞争对手设置的壁垒有多高。 你最好做出令人信服的解释，阐明你的技术难以复制的原因。否则一旦大公司看到了，它们就会做出自己的版本，再加上它们的品牌、资本、经销能力，一夜之间就把你的市场全部抢走。那时你就像来到开阔地带的游击队，会被正规军一举歼灭。</p></blockquote><ul><li>7 关注贫富分化</li></ul><blockquote><p>技术无法使其变得更便宜的唯一东西，就是品牌。这正是为什么我们现在越来越多地听到品牌的原因。富人与穷人之间生活差异的鸿沟正在缩小，品牌是这种差距的遗留物。</p></blockquote><blockquote><p>我想提出一种相反的观点：现代社会的收入差距扩大是一种健康的信号。技术使得生产率的差异加速扩大，如果这种扩大没有反映在收入上面，只有三种可能的解释：（a）技术革新停顿了；（b）那些创造大部分财富的人停止工作了；（c）创造财富的人没有获得报酬。</p></blockquote><blockquote><p>如果我可以做选择，到底是生活在一个整体上非常富裕但是我个人相对贫穷的社会，还是生活在一个我个人相对非常富裕但是整体上非常贫穷的社会呢？我会选择第一个选项。如果我有小孩的话，可能哪一个选项更好还值得争论。但是，总的来说，你要避免的是绝对贫穷，而不是相对贫穷。如果必须在这两种社会之间做选择，根据目前的证据，我选择个人相对贫穷、但是整体上更富裕的社会。</p></blockquote><ul><li>9 设计者的品味</li></ul><blockquote><p>如果你不知道自己的想法从何而来，那么你可能就是在模仿另一个模仿者。</p></blockquote><blockquote><p>今天的实验性错误就是明天的新理论。如果你想做出伟大的新成果，那就不能对常识与真理不相吻合之处视而不见，反而应该特别注意才对。</p></blockquote><ul><li>10 编程语言解析</li></ul><blockquote><p>高级语言还有一个优点，它使得程序更具有可移植性。不同计算机的机器语言都不是完全相同的。所以，你无法将为某一种机型写的机器语言程序放到另一种机型上运行，只有彻底重写才能实现。但是，如果你的程序是用高级语言写的，你只需要重写编译器就可以了。<br>编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。</p></blockquote><blockquote><p>那么，应该使用哪一种语言？嗯，关于这个问题，现在有很多争论。部分原因是，如果你长期使用某种语言，你就会慢慢按照这种语言的思维模式进行思考。所以，后来当你遇到其他任何一种有重大差异的语言，即使那种语言本身并没有任何不对的地方，你也会觉得它极其难用。缺乏经验的程序员对于各种语言优缺点的判断经常被这种心态误导。</p></blockquote><blockquote><p>语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。Java 语言是前一个阵营的代表，Perl 语言则是后一个阵营的代表。</p></blockquote><ul><li>11 一百年后的编程语言</li></ul><blockquote><p>在编程语言的帮助下，你的应用程序越是采用这种多层形式开发，它的可重用性就越好。</p></blockquote><ul><li>12 拒绝平庸</li></ul><blockquote><p>如果你为创业公司工作，那么这里有一个评估竞争对手的妙招——关注他们的招聘职位。他们网站上的其他内容无非是一些陈腐的照片和夸夸其谈的文字，但是招聘职位却不得不写得很明确，反映出他们到底想干什么，否则就会引来一大批不合适的求职者。</p></blockquote><ul><li>13 书呆子的复仇</li></ul><blockquote><p>使用一种不常见的语言会出现的问题我想到了三个：你的程序可能无法很好地与使用其他语言写的程序协同工作；你可能找不到很多函数库；你可能不容易雇到程序员。</p></blockquote><ul><li>15 设计与研究</li></ul><blockquote><p>艺术的各个领域有着巨大的差别，但是我觉得任何一个领域的最佳作品都不可能由对用户言听计从的人做出来。</p></blockquote><blockquote><p>我觉得，除非设定目标用户，否则一种设计的好坏根本无从谈起。</p></blockquote><blockquote><p>软件开发也可以这样做。原型（prototype）并不只是模型（model），不等于将来一定要另起炉灶，你完全能够在原型的基础上直接做出最后的成品。我认为，只要有可能，你就应该这样做。这样的方式使得你可以利用在开发过程中一路产生的新想法。不过更重要的是，这样做有助于鼓舞士气。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java7中的NIO.2</title>
      <link href="/2014-12-28/Java7%E4%B8%AD%E7%9A%84NIO-2/"/>
      <url>/2014-12-28/Java7%E4%B8%AD%E7%9A%84NIO-2/</url>
      
        <content type="html"><![CDATA[<p>Java7 对原有的 NIO 进行了重大改进，叫 NIO.2。</p><p>其中之一就是提供了全面的文件 IO 和文件系统访问支持，新增了 java.nio.file 包及各个子包。</p><p>NIO.2 引入了 Path 接口，Path 接口代表一个平台无关的平台路径；还提供了 Files、Paths 两个工具类，Files 包含了大量静态的工具方法来操作文件，Paths 则包含了两个返回 Path 的静态工厂方法。</p><p>这边我记录下以上几个的用法 sample，以后用得着。</p><ul><li>Path 接口的功能和用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Path接口的功能和用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//以当前路径创建Path对象</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Paths.get(\&quot;.\&quot;)：&quot;</span> + path);</span><br><span class="line">System.out.println(<span class="string">&quot;path的路径数量：&quot;</span> + path.getNameCount());</span><br><span class="line">System.out.println(<span class="string">&quot;path的根路径：&quot;</span> + path.getRoot());</span><br><span class="line">System.out.println(<span class="string">&quot;path的绝对路径：&quot;</span> + path.toAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;AbsolutePath的根路径：&quot;</span> + path.toAbsolutePath().getRoot());</span><br><span class="line">System.out.println(<span class="string">&quot;AbsolutePath的路径数量：&quot;</span> + path.toAbsolutePath().getNameCount());</span><br><span class="line">System.out.println(<span class="string">&quot;path.toAbsolutePath().getName(3)：&quot;</span> + path.toAbsolutePath().getName(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//以多个string构建path对象</span></span><br><span class="line"><span class="comment">//相当于e:\Workspace\IDEA，超方便有木有</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;e:&quot;</span>, <span class="string">&quot;Workspace&quot;</span>, <span class="string">&quot;IDEA&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Paths.get(\&quot;e:\&quot;, \&quot;Workspace\&quot;, \&quot;IDEA\&quot;)：&quot;</span> + path2);</span><br></pre></td></tr></table></figure><ul><li>Files 类的用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Files类的用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;pwd.txt&quot;</span>);</span><br><span class="line"><span class="comment">//复制文件</span></span><br><span class="line">Files.copy(path3, <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.txt&quot;</span>));</span><br><span class="line"><span class="comment">//判断是否为隐藏文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;pwd.txt是否为隐藏文件：&quot;</span> + Files.isHidden(path3));</span><br><span class="line"><span class="comment">//一次性读取文件的所有行</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path3, Charset.forName(<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">System.out.println(lines);</span><br><span class="line"><span class="comment">//判断指定文件的大小</span></span><br><span class="line">System.out.println(<span class="string">&quot;pwd.txt大小为：&quot;</span> + Files.size(path3));</span><br><span class="line"><span class="comment">//将多个字符串内容写入指定文件中</span></span><br><span class="line">List&lt;String&gt; poem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">poem.add(<span class="string">&quot;举头望明月&quot;</span>);</span><br><span class="line">poem.add(<span class="string">&quot;低头思故乡&quot;</span>);</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;poem.txt&quot;</span>), poem, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"><span class="comment">//判断C盘的总空间、可用空间</span></span><br><span class="line"><span class="type">FileStore</span> <span class="variable">fileStore</span> <span class="operator">=</span> Files.getFileStore(Paths.get(<span class="string">&quot;C:&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;C盘总空间：&quot;</span> + fileStore.getTotalSpace());</span><br><span class="line">System.out.println(<span class="string">&quot;C盘可用空间：&quot;</span> + fileStore.getUsableSpace());</span><br></pre></td></tr></table></figure><p>Files 工具类真心简单，原本需要通过 IO 操作才能完成的功能，现在 Files 类只要一个工具方法即可。</p><ul><li>使用 FileVisitor 遍历文件和子目录</li></ul><p>在之前的 java 版本中，遍历指定目录下的所有文件和子目录只能使用递归。有了 Files 工具类的帮助，遍历文件和子目录就方便的多了。Files 类主要使用 walkFileTree()来遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用FileVisitor遍历文件和子目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//遍历E:\Workspace\AndroidStudio目录下的所有文件和子目录</span></span><br><span class="line">Files.walkFileTree(Paths.get(<span class="string">&quot;E:&quot;</span>, <span class="string">&quot;Workspace&quot;</span>, <span class="string">&quot;AndroidStudio&quot;</span>), <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;() &#123;</span><br><span class="line">    <span class="comment">//访问文件时触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在访问&quot;</span> + file + <span class="string">&quot;文件&quot;</span>);</span><br><span class="line">        <span class="comment">//找到了MainActivity.java</span></span><br><span class="line">        <span class="keyword">if</span> (file.endsWith(<span class="string">&quot;MainActivity.java&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---已经找到目标文件---&quot;</span>);</span><br><span class="line">            <span class="comment">//返回终止访问的后续行为</span></span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.TERMINATE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回继续访问的后续行为</span></span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始访问文件时触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---开始访问&quot;</span> + dir + <span class="string">&quot;路径---&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（完）</p><blockquote><p>参考自《疯狂 JAVA 讲义》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简明指南&amp;GitHub资料汇总</title>
      <link href="/2014-12-14/Git%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97-GitHub%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
      <url>/2014-12-14/Git%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97-GitHub%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>在网上找到一个都是大白话的 Git 指南，以及分享了自己收集的一些 GitHub 的学习链接。</p><h3 id="git-简明指南"><a href="#git-简明指南" class="headerlink" title="git 简明指南"></a>git 简明指南</h3><blockquote><p>转自：<a href="http://rogerdudler.github.io/git-guide/index.zh.html">http://rogerdudler.github.io/git-guide/index.zh.html</a></p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="http://code.google.com/p/git-osx-installer/downloads/list?can=3">下载 git OSX 版</a></p><p><a href="http://msysgit.github.io/">下载 git Windows 版</a></p><p><a href="http://book.git-scm.com/2_installing_git.html">下载 git Linux 版</a></p><h4 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h4><p>创建新文件夹，打开，然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>以创建新的 git 仓库。</p><h4 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h4><p>执行如下命令以创建一个本地仓库的克隆版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone /path/to/repository</span><br></pre></td></tr></table></figure><p>如果是远端服务器上的仓库，你的命令会是这个样子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone username@host:/path/to/repository</span><br></pre></td></tr></table></figure><h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <strong>工作目录</strong>，它持有实际文件；第二个是 <strong>暂存区（Index）</strong>，它像个缓存区域，临时保存你的改动；最后是 <strong>HEAD</strong>，它指向你最后一次提交的结果。</p><p><img src="http://rogerdudler.github.io/git-guide/img/trees.png"></p><h4 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h4><p>你可以提出更改（把它们添加到暂存区），使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure><p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure><p>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</p><h4 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h4><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>可以把 master 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><img src="http://rogerdudler.github.io/git-guide/img/branches.png"></p><p>创建一个叫做“feature_x”的分支，并切换过去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换回主分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>再把新建的分支删掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>除非你将分支推送到远端仓库，不然该分支就是 _不为他人所见的_：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h4><p>要更新你的本地仓库至最新改动，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。</p><p>要合并其他分支到你的当前分支（例如 master），执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>在合并改动之前，你可以使用如下命令预览差异：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 1.0.0 1b2e1d63ff</span><br></pre></td></tr></table></figure><p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。</p><h4 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h4><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h4 id="实用小贴士"><a href="#实用小贴士" class="headerlink" title="实用小贴士"></a>实用小贴士</h4><p>内建的图形化 git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure><p>彩色的 git 输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config color.ui true</span><br></pre></td></tr></table></figure><p>显示历史记录时，每个提交的信息只显示一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config format.pretty oneline</span><br></pre></td></tr></table></figure><p>交互式添加文件到暂存区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure><h4 id="链接与资源"><a href="#链接与资源" class="headerlink" title="链接与资源"></a>链接与资源</h4><p>图形化客户端</p><p><em>PS：都是 OSX 的客户端，这里不贴了- -</em></p><p>指南和手册</p><p><a href="http://book.git-scm.com/">Git 社区参考书</a></p><p><a href="http://progit.org/book/">专业 Git</a></p><p><a href="http://think-like-a-git.net/">像 git 那样思考</a></p><p><a href="http://help.github.com/">GitHub 帮助</a></p><p><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git</a></p><p>（完）</p><hr><h3 id="GitHub-资料汇总"><a href="#GitHub-资料汇总" class="headerlink" title="GitHub 资料汇总"></a>GitHub 资料汇总</h3><ol><li>深入浅出地讲解了 GitHub 的方方面面，最后博主还反思了 GitHub 所带来的影响，初次想要了解 GitHub 的同学可以首先读这篇文章。地址：<a href="http://www.yangzhiping.com/tech/github.html">http://www.yangzhiping.com/tech/github.html</a></li><li>重量级教程——progit。是 github 公司传道士 schacon 写的一本全面介绍 github 结构及使用方法的书，提供多种语言翻译，但是需要手动生成图书：<a href="http://progit.org/book/">http://progit.org/book/</a> 。不过这里国内有人制作了中文的电子书，大家可以直接下载学习。地址：<a href="https://github.com/numbbbbb/progit-zh-pdf-epub-mobi">https://github.com/numbbbbb/progit-zh-pdf-epub-mobi</a></li><li>git magic，同样是一本书，不过比 progit 短很多。有志愿者已经翻译成了中文版。地址：<a href="https://github.com/blynn/gitmagic/tree/master/zh_cn">https://github.com/blynn/gitmagic/tree/master/zh_cn</a></li></ol><p>（完）</p><blockquote><p>参考自微信公众号：GitHub 不完全装 B 指南</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 技巧：两种方式实现页内跳转(转)</title>
      <link href="/2014-12-10/Markdown%E6%8A%80%E5%B7%A7%EF%BC%9A%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC(%E8%BD%AC)/"/>
      <url>/2014-12-10/Markdown%E6%8A%80%E5%B7%A7%EF%BC%9A%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC(%E8%BD%AC)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：<a href="http://ijtsai.com/2014/10/15/Markdown-jump/">http://ijtsai.com/2014/10/15/Markdown-jump/</a></p></blockquote><p><span id="jump">跳转到的地方</span> <em>未看完全文请忽略这行:)</em></p><p>最近，无论是在博客园还是在自己的博客写文章，都是用的 MarkDownPad2 写的。喜欢 MarkDown 这种简单直观的写作方式。</p><p><img src="http://ww3.sinaimg.cn/large/8942f980gw1elc1jxqdyhj20rz0cqtbt.jpg" alt="MarkDown写作"></p><p>但是写文章时，突然发现如果写了一篇很长的文章，要是没有目录的话。阅读起来十分不便。页内跳转就能很好的解决这个问题。如下图中的目录一样。</p><p><img src="http://ww1.sinaimg.cn/large/8942f980gw1elc2idr8paj20wc0fldgz.jpg"></p><p>Google 了一下，有两种方式在 MarkDown 中实现这两个功能：</p><h3 id="1-MarkDown-实现"><a href="#1-MarkDown-实现" class="headerlink" title="1.MarkDown 实现"></a>1.MarkDown 实现</h3><p>生成目录的方法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [<span class="string">1.语法示例</span>](<span class="link">#1</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">1.1 图片</span>](<span class="link">#1.1</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">1.2 换行</span>](<span class="link">#1.2</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">1.3 强调</span>](<span class="link">#1.3</span>)</span><br></pre></td></tr></table></figure><p>生成效果：</p><ul><li><a href="#1">1.语法示例</a></li><li><a href="#1.1">1.1 图片</a></li><li><a href="#1.2">1.2 换行</a></li><li><a href="#1.3">1.3 强调</a></li></ul><p>在正文中，只要将章节标题的 id 对应上去即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1.语法示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">这是第一段 这是第一段</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>1.1图片<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">这是第一段第一节 这是第一段第一节</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;1.2&quot;</span>&gt;</span>1.2换行<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">这是第一段第二节 这是第一段第二节</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>1.3强调<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">这是第一段第三节 这是第一段第三节</span><br></pre></td></tr></table></figure><p>生成效果：</p><h2 id="1">1.语法示例</h2><p>这是第一段</p><p>这是第一段</p><h3 id="1.1">1.1图片</h3><p>这是第一段第一节</p><p>这是第一段第一节</p><h3 id="1.2">1.2换行</h3><p>这是第一段第二节</p><p>这是第一段第二节</p><h3 id="1.1">1.3强调</h3><p>这是第一段第三节</p><p>这是第一段第三节</p><p>点击目录，发现可以页内跳转了。</p><hr><h3 id="2-html-标签实现"><a href="#2-html-标签实现" class="headerlink" title="2.html 标签实现"></a>2.html 标签实现</h3><ul><li>定义一个锚(id)：<span id="jump">跳转到的地方</span></li><li>使用 markdown 语法：[点击跳转](#jump)</li><li>在文章末尾设置一个锚，然后跳转到文章开始的地方。</li></ul><p><a href="#jump">点击跳转</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Github, Hexo 搭建博客</title>
      <link href="/2014-12-09/%E4%BD%BF%E7%94%A8Github,Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2014-12-09/%E4%BD%BF%E7%94%A8Github,Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>今天经过阅读大神们的博文总算通过使用 GitHub、hexo 搭建好了自己的博客。<br>这里我梳理一下大致的搭建流程，具体的步骤可以参考文末的链接，自己懒得写了- -。。</p><ul><li>安装<a href="http://nodejs.org/">Node.js</a></li><li>安装<a href="http://git-scm.com/download">git</a></li><li>注册 GitHub 账号，建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.io』或『your_user_name.github.com』</li><li>添加 SSH 公钥到 GitHub 的『Account settings -&gt; SSH Keys -&gt; Add SSH Key』</li><li>安装 hexo。页面生成、本地调试、写文章等操作都通过 hexo 指令完成。最好去<a href="http://hexo.io/">hexo</a>了解一下。</li><li>hexo 主题安装。去<a href="https://github.com/hexojs/hexo/wiki/Themes">Hexo Themes</a>挑一个吧。安装主题的方法就是一句 git 命令，比如要安装 modernist 这个主题：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</span><br></pre></td></tr></table></figure><p>安装完成后，在根目录_config.yml 下，修改：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">theme:</span> modernist</span><br></pre></td></tr></table></figure><ul><li>添加评论插件。静态博客要使用第三方评论系统，hexo 默认集成的是 Disqus，因为你懂的，所以国内的话还是建议用<a href="http://duoshuo.com/">多说</a>。</li></ul><p>ok，至于自定义页面、域名申请、网站统计等等就请看下面的文章吧。</p><blockquote><p>这位大神写的从安装到各种配置写得都比较详细，主要也是看了这篇文章搭建好的：<a href="http://ibruce.info/2013/11/22/hexo-your-blog/">http://ibruce.info/2013/11/22/hexo-your-blog/</a></p></blockquote><blockquote><p>各方面说的比较简明，配合上面一起看最好：<a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785/">http://blog.csdn.net/poem_of_sunshine/article/details/29369785/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 简明语法</title>
      <link href="/2014-12-09/Markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/"/>
      <url>/2014-12-09/Markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2014.12.18 更新：更换了几个主题，发现有些主题的确会出现部分 md 语法没效果的情况<br>2019.01.08 更新：排版调整，代码块 hexo、表格部分修改</p></blockquote><p>Markdown 是一种极简的『标记语言』，将文本转为 HTML，通常为我大码农所用。其不追求大而全，简洁至上，正所谓不求最贵，只求最好！</p><p>本文介绍 Markdown 基本语法，内容很少，一行语法一行示例，学会后可轻松写出高大上的文档，再也不需要各种编辑器去调文章格式。另外，网上有各平台下的 Markdown 工具可用，也有在线的，我直接使用 sublime 搞定，Markdown 本来就是为了追求简洁，弄个工具岂不多此一举。</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**一个人来到田纳西**</span></span><br><span class="line"><span class="strong">**毫无疑问**</span></span><br><span class="line"><span class="emphasis">_我做的馅饼</span></span><br><span class="line"><span class="emphasis">是全天下_</span></span><br><span class="line"><span class="emphasis">_最好吃的_</span></span><br></pre></td></tr></table></figure><p><strong>一个人来到田纳西</strong><br><strong>毫无疑问</strong><br><em>我做的馅饼<br>是全天下</em><br><em>最好吃的</em></p><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或更多-_*，必须单独一行，可含空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>符号后的空格可不要。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><p>内层符号前的空格必须要</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; 引用中的引用</span></span><br></pre></td></tr></table></figure><blockquote><p>引用</p><blockquote><blockquote><p>引用中的引用</p></blockquote></blockquote></blockquote><hr><h2 id="标题：Setext-方式"><a href="#标题：Setext-方式" class="headerlink" title="标题：Setext 方式"></a>标题：Setext 方式</h2><p>另起一行在文字下方加&#x3D;&#x3D;&#x3D;或---。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 大标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 小标题</span></span><br></pre></td></tr></table></figure><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><hr><h2 id="标题：Atx-方式"><a href="#标题：Atx-方式" class="headerlink" title="标题：Atx 方式"></a>标题：Atx 方式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 无序列表</span><br><span class="line"><span class="bullet">-</span> 无序列表</span><br><span class="line"><span class="bullet">-</span> 无序列表</span><br><span class="line"><span class="bullet">-</span> 无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！</span><br></pre></td></tr></table></figure><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li><li>无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！</li></ul><hr><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>数字不能省略但可无序，点号之后的空格不能少。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序列表</span><br><span class="line"><span class="bullet">2.</span> 有序列表</span><br><span class="line"><span class="bullet">3.</span> 有序列表</span><br><span class="line"><span class="bullet">4.</span> 有序列表</span><br></pre></td></tr></table></figure><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><hr><h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p>-+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 嵌套列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 嵌套列表</span><br><span class="line"><span class="bullet">*</span> 嵌套列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 嵌套列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 嵌套列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 嵌套列表</span><br></pre></td></tr></table></figure><ul><li>嵌套列表<ul><li>嵌套列表</li><li>嵌套列表<ul><li>嵌套列表<ul><li>嵌套列表</li></ul></li></ul></li></ul></li><li>嵌套列表</li></ul><hr><h2 id="文字超链：Inline-方式"><a href="#文字超链：Inline-方式" class="headerlink" title="文字超链：Inline 方式"></a>文字超链：Inline 方式</h2><p>Tooltips 可省略。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">不如</span>](<span class="link">http://bruce-sha.github.io &#x27;不如的博客&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="http://bruce-sha.github.io/" title="不如的博客">不如</a></p><hr><h2 id="图片超链"><a href="#图片超链" class="headerlink" title="图片超链"></a>图片超链</h2><p>多个感叹号，Tooltips 可省略，要设置大小只能借助 HTML 标记。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">GitHub Mark</span>](<span class="link">http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png &#x27;GitHub Mark&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"></p><hr><h2 id="索引超链：Reference-方式"><a href="#索引超链：Reference-方式" class="headerlink" title="索引超链：Reference 方式"></a>索引超链：Reference 方式</h2><p>索引 1、2 可以是任意字符。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">不如</span>][<span class="symbol">1</span>]</span><br><span class="line">![<span class="string">GitHub Octocat</span>][<span class="symbol">2</span>]</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://bruce-sha.github.io</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png</span></span><br></pre></td></tr></table></figure><p>[不如][1]<br>![GitHub Octocat][2]<br>[1]:<a href="http://bruce-sha.github.io/">http://bruce-sha.github.io</a><br>[2]:<a href="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png">http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png</a></p><hr><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>尖括号</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;http://ibruce.info&gt;</span></span><br><span class="line"><span class="language-xml">&lt;bu.ru@qq.com&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://ibruce.info/">http://ibruce.info</a><br><a href="mailto:&#98;&#117;&#x2e;&#114;&#117;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;">&#98;&#117;&#x2e;&#114;&#117;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;</a></p><hr><h2 id="代码：行内代码"><a href="#代码：行内代码" class="headerlink" title="代码：行内代码"></a>代码：行内代码</h2><p>在第一行后指定编程语言，也可以不指定。</p><p>```java<br>String s &#x3D; “hello world”;<br>System.out.println(s);<br>```</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><hr><h2 id="代码：段落代码"><a href="#代码：段落代码" class="headerlink" title="代码：段落代码"></a>代码：段落代码</h2><p>每行文字前加 4 个空格或者 1 个 Tab。</p><pre><code>String s = &quot;hello world&quot;;System.out.println(s);</code></pre><hr><h2 id="代码：hexo"><a href="#代码：hexo" class="headerlink" title="代码：hexo"></a>代码：hexo</h2><p>可指定编程语言、title</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:java Main.java  %&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.println(&#x27;Hello World!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Main.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.println(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用 html 的注释，好像只有这样？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>Markdown 中的转义字符为\ ，转义的有：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\\ 反斜杠</span><br><span class="line">\` 反引号 \<span class="emphasis">* 星号</span></span><br><span class="line"><span class="emphasis">\_ 下划线</span></span><br><span class="line"><span class="emphasis">\&#123;\&#125; 大括号</span></span><br><span class="line"><span class="emphasis">\[\] 中括号</span></span><br><span class="line"><span class="emphasis">\(\) 小括号</span></span><br><span class="line"><span class="emphasis">\# 井号</span></span><br><span class="line"><span class="emphasis">\+ 加号</span></span><br><span class="line"><span class="emphasis">\- 减号</span></span><br><span class="line"><span class="emphasis">\. 英文句号</span></span><br><span class="line"><span class="emphasis">\! 感叹号</span></span><br></pre></td></tr></table></figure><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>文本中可直接用 html 标签，但是要前后加上空行。</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 的扩展语法，hexo 不支持。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 年级   | 班级 |</span><br><span class="line">| ---- | ------ | ---- |</span><br><span class="line">| 小明 | 五年级 | 1 班 |</span><br><span class="line">| 小红 | 四年级 | 2 班 |</span><br></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th>年级</th><th>班级</th></tr></thead><tbody><tr><td>小明</td><td>五年级</td><td>1 班</td></tr><tr><td>小红</td><td>四年级</td><td>2 班</td></tr></tbody></table><p>（完）</p><hr><blockquote><p>参考文章：<a href="http://ibruce.info/2013/11/26/markdown">http://ibruce.info/2013/11/26/markdown</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇</title>
      <link href="/2014-12-09/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2014-12-09/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Nice-to-see-you！"><a href="#Nice-to-see-you！" class="headerlink" title="Nice to see you！"></a>Nice to see you！</h2><p>这是我的第一篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
