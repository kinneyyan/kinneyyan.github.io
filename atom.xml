<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Kinney&#39;s blog</title>
    <link>https://kinneyyan.github.io/</link>
    
    <atom:link href="https://kinneyyan.github.io/atom.xml" rel="self" type="application/rss+xml"/>
    
    <description>a personal blog by Kinney Yan</description>
    <pubDate>Tue, 27 Sep 2022 06:52:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>我的树莓派使用小结（2022）</title>
      <link>https://kinneyyan.github.io/2022-09-27/%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%EF%BC%882022%EF%BC%89/</link>
      <guid>https://kinneyyan.github.io/2022-09-27/%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%EF%BC%882022%EF%BC%89/</guid>
      <pubDate>Tue, 27 Sep 2022 05:46:57 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从两年前购置树莓派 4B 、2T 的西数红盘，前前后后尝试了不少玩法。目前部署的服务也基本趋于稳定，就是：个人网盘 + 离线下载 + 媒体库</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从两年前购置树莓派 4B 、2T 的西数红盘，前前后后尝试了不少玩法。目前部署的服务也基本趋于稳定，就是：个人网盘 + 离线下载 + 媒体库 + RSS 服务，也是我最高频使用的（<del>树莓派吃灰不存在的</del>）。在此做个小结，同时推荐一些 APP。</p><h2 id="目前部署的服务"><a href="#目前部署的服务" class="headerlink" title="目前部署的服务"></a>目前部署的服务</h2><p>首先我在树莓派上部署的服务都是基于 Docker 。用 Docker 部署真的省心，不用关心环境依赖，不想用了 <code>docker stop &lt;container id&gt;</code> 、删掉容器、镜像即可，很适合来回折腾。</p><h3 id="个人网盘"><a href="#个人网盘" class="headerlink" title="个人网盘"></a>个人网盘</h3><h4 id="Cloudreve"><a href="#Cloudreve" class="headerlink" title="Cloudreve"></a><a href="https://cloudreve.org/">Cloudreve</a></h4><p>国人开发的公私兼备的网盘系统，文档友好、部署方便。支持 WebDAV ，网页还支持 PWA 。</p><p><a href="https://imgse.com/i/xV2tiQ"><img src="https://s1.ax1x.com/2022/09/26/xV2tiQ.jpg" alt="Cloudreve"></a></p><p><em>之前用了一段时间 Nextcloud ，后来因为一次错误升级导致服务不可用，思索再三，选择了 Cloudreve 。说一下放弃 Nextcloud 的原因：(1)太重，内置的很多功能对我来说用不到；(2)部署问题不少，当初安装碰到很多坑查阅了很多论坛帖子；(3)导入已有文件的功能很不方便，需要通过特定 cli，不像 Cloudreve 直接在管理面板操作即可</em></p><h3 id="离线下载"><a href="#离线下载" class="headerlink" title="离线下载"></a>离线下载</h3><h4 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a><a href="https://aria2.github.io/">aria2</a></h4><p>强大、轻巧、全能的下载工具，但是需要自己会配置，对于非开发用户来说有一定门槛，虽然现在市面上也有很多打包自带 GUI 的软件了。</p><p><em>这里我用的 <a href="https://github.com/P3TERX">P3TERX</a> 大佬贡献的 <a href="https://github.com/P3TERX/aria2.conf">aria2 完美配置</a> 直接安装在 PI 上。然后在 Cloudreve 管理面板中配置下 aria2 RPC 地址和密码，就可以使用 Cloudreve 的离线下载功能了。</em></p><p><a href="https://imgse.com/i/xV2uRA"><img src="https://s1.ax1x.com/2022/09/26/xV2uRA.jpg" alt="Cloudreve 管理面板"></a></p><p><em>当然也可以通过 Docker 部署， Cloudreve 官网也有提供 <a href="https://docs.cloudreve.org/getting-started/install#docker-compose">Cloudreve + aria2 的 docker-compose 部署</a>的方法。</em></p><h3 id="媒体库"><a href="#媒体库" class="headerlink" title="媒体库"></a>媒体库</h3><h4 id="Emby"><a href="#Emby" class="headerlink" title="Emby"></a><a href="https://emby.media/">Emby</a></h4><p>大名鼎鼎的媒体库解决方案，颜值高，不过非开源并带付费高级版功能。</p><p><em>最初我肯定是优先选择 FOSS(free open source software) 的 Jellyfin 的，无奈使用其 arm 架构的 docker 启动后容器内一直报错，根据 log 网上搜索半天也无果。后来用 Emby 的 docker 启动一点问题都没有，果断用 Emby 了。</em></p><h3 id="RSS-服务"><a href="#RSS-服务" class="headerlink" title="RSS 服务"></a>RSS 服务</h3><h4 id="FreshRSS"><a href="#FreshRSS" class="headerlink" title="FreshRSS"></a><a href="https://freshrss.org/">FreshRSS</a></h4><p>比 Tiny Tiny RSS 配置更方便的 RSS 服务，高级功能方面内置的全文解析（需要一点动手能力，只要会检查网页元素）对我来说完全够用了。</p><p><a href="https://imgse.com/i/xV21qf"><img src="https://s1.ax1x.com/2022/09/26/xV21qf.jpg" alt="FressRSS"></a></p><p><em>之前用了很长一段时间 Tiny Tiny RSS ，又是因为自己手贱瞎升级 docker 镜像版本……然后看了下 FressRSS 提供的 docker ，只需要跑一个容器就够，简单明了。</em></p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>其实上述我使用的四个服务能构成一个完整的影视资源的发现、下载、落库的工作流 👇</p><ol><li>订阅影视资源站的 RSS</li><li>平时浏览 RSS 时发现有想看的影视资源更新了</li><li>复制对应的磁力链</li><li>打开 Cloudreve-离线下载，粘贴链接，选择下载完成后的目录</li><li>Cloudreve 借助 aria2 开始下载资源</li><li>资源下载完毕，Cloudreve 移动到对应的目录下</li><li>Emby 服务检测到监听的磁盘目录有新的文件，加入到媒体库中，同时扫描元信息，入库完成 😃</li></ol><h2 id="关于内网穿透"><a href="#关于内网穿透" class="headerlink" title="关于内网穿透"></a>关于内网穿透</h2><p>我的方案可能没有太大的参考性，因为家里的路由器装的是 H 大的老毛子固件，自带了很多内网穿透方案，我用的是 <a href="https://www.ddnsto.com/">DDNSTO</a></p><p><a href="https://imgse.com/i/xV2qWd"><img src="https://s1.ax1x.com/2022/09/26/xV2qWd.jpg" alt="路由器后台"></a></p><p><a href="https://imgse.com/i/xVRpTS"><img src="https://s1.ax1x.com/2022/09/26/xVRpTS.jpg" alt="DDNSTO 控制台"></a></p><p>可能以后会使用其他的备选方案：</p><ul><li>申请公网 IP ，配置 DDNS</li><li><a href="https://tailscale.com/">Tailscale</a></li><li><a href="https://www.zerotier.com/">ZeroTier</a></li></ul><h2 id="使用的-APP"><a href="#使用的-APP" class="headerlink" title="使用的 APP"></a>使用的 APP</h2><ul><li><a href="https://play.google.com/store/apps/details?id=pl.solidexplorer2">Solid Explorer File Manager</a>：功能强大、界面美观的 Android 文件浏览器，最重要的是支持 WebDAV，配合上面部署的 Cloudreve，访问个人网盘的文件就像访问本地文件一样简单</li><li><a href="https://emby.media/server-android.html">Emby</a>：Emby 官方的 Android 客户端</li><li><a href="https://play.google.com/store/apps/details?id=com.seazon.feedme">FeedMe</a>：用了多年的 RSS 阅读器，配置丰富。如果手机上只能选一款 RSS 阅读器，那只能是它了</li><li><a href="https://play.google.com/store/apps/details?id=allen.town.focus.reader">FocusReader </a>：新晋的 RSS 阅读器应用，界面、交互都很简约，缺点是同步时不支持显示进度，同步出错时会有些小 bug 。所以我目前会用它配置局域网的地址，在家里看；出门在外的话，就用配置好的 DDNSTO 地址的 FeedMe ，因为能显示同步进度，弱网环境下至少能知道卡在哪一步。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>絮絮叨叨了一堆东西，算是给我这个 “丐版 NAS” 的解决方案复盘了一遍。如此这般折腾肯定有人会问：为啥不买台 NAS ？我想，折腾也是一种乐趣所在吧 😆</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://kinneyyan.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</category>
      
      <category domain="https://kinneyyan.github.io/tags/aria2/">aria2</category>
      
      <category domain="https://kinneyyan.github.io/tags/RSS/">RSS</category>
      
      
      <comments>https://kinneyyan.github.io/2022-09-27/%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%EF%BC%882022%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 Tiny Tiny RSS 要点及踩坑记录</title>
      <link>https://kinneyyan.github.io/2020-11-26/%E4%BD%BF%E7%94%A8%20Tiny%20Tiny%20RSS%20%E8%A6%81%E7%82%B9%E5%8F%8A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <guid>https://kinneyyan.github.io/2020-11-26/%E4%BD%BF%E7%94%A8%20Tiny%20Tiny%20RSS%20%E8%A6%81%E7%82%B9%E5%8F%8A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Thu, 26 Nov 2020 07:04:18 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言（一些碎碎念）&quot;&gt;&lt;a href=&quot;#前言（一些碎碎念）&quot; class=&quot;headerlink&quot; title=&quot;前言（一些碎碎念）&quot;&gt;&lt;/a&gt;前言（一些碎碎念）&lt;/h2&gt;&lt;h3 id=&quot;什么是-RSS？RSS-能干什么？&quot;&gt;&lt;a href=&quot;#什么是-RSS？</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言（一些碎碎念）"><a href="#前言（一些碎碎念）" class="headerlink" title="前言（一些碎碎念）"></a>前言（一些碎碎念）</h2><h3 id="什么是-RSS？RSS-能干什么？"><a href="#什么是-RSS？RSS-能干什么？" class="headerlink" title="什么是 RSS？RSS 能干什么？"></a>什么是 RSS？RSS 能干什么？</h3><p>或许在 2020 年的今天，很多人会觉得 RSS 是过时的产物，甚至我身边的一些朋友都不知道 RSS。但是我觉得 RSS 是获取信息最酷最高效的方式！</p><p>自己总结 RSS 的特点就是：</p><ul><li>自由（订阅自己想要的信息源）、统一（所有信息源一处统一阅读）、无限制（可以使用任意的 RSS 阅读器客户端）</li></ul><p>关于 RSS 更多的食用方法，可以参考<a href="https://diygod.me/ohmyrss/">我有特别的 RSS 使用技巧</a></p><h3 id="什么是-Tiny-Tiny-RSS（TTRSS）？"><a href="#什么是-Tiny-Tiny-RSS（TTRSS）？" class="headerlink" title="什么是 Tiny Tiny RSS（TTRSS）？"></a>什么是 Tiny Tiny RSS（TTRSS）？</h3><p><a href="https://tt-rss.org/">Tiny Tiny RSS</a> 是一个开源免费的 RSS 服务，必须安装在 Web 服务器上的 Web 应用</p><h3 id="为什么要自己部署-RSS-服务如-TTRSS？"><a href="#为什么要自己部署-RSS-服务如-TTRSS？" class="headerlink" title="为什么要自己部署 RSS 服务如 TTRSS？"></a>为什么要自己部署 RSS 服务如 TTRSS？</h3><p>我是在 2017 年接触并开始使用 RSS 服务。当时国内有一款叫‘一览’的产品，在 Web 端、App 端体验都十分不错，RSS 功能也很完备，包括网站的 RSS 嗅探、新订阅源的申请（包括微信公众号！我记得当时还有一个专门提供微信公众号 feed 流的项目网站，名字忘了）、OPML 文件导入导出等。当然，2020 年的现在，这款小众的 RSS 产品早已停止运营，<a href="https://www.yilan.io/">官网</a>也打不开了，我 google 了下’一览’，竟然还找到了当年开发团队在<a href="https://v2ex.com/t/282706">V2EX 上发的贴</a>，一阵唏嘘……</p><p>通过接触‘一览’体验到 RSS 的魅力后，我又先后接触了 <a href="https://feedly.com/">Feedly</a>、<a href="https://inoreader.com/">Inoreader</a>、即刻、<a href="http://kzfeed.com/">快知</a>这些个国内外的 RSS 服务。前两者都是国外做了很多年的 RSS 服务商，账户、收费体系、客户端体验都十分成熟完备，Inoreader 我也使用至今；而<strong>早期</strong>的即刻、快知这些国内的产品，在 RSS 的功能上也是受用户认可的。</p><p>那为什么还要自建 RSS 服务呢？因为，由于’不可抗力’，Feedly 和 Inoreader 在国内都无法正常访问了；即刻？整改前已经在往社区化转型，整改后的 RSS 功能都是受监管的（虽然我没用过）；快知？这款 2020 年上线被寄希望取代即刻的产品目前也已经无法访问了……</p><p>当然除了外部因素，自建 RSS 服务也有自己的优势，你能享受很多在 Feedly、Inoreader 上原本需要收费的功能，比如：全文提取、过滤器等等。</p><h2 id="开始部署-TTRSS"><a href="#开始部署-TTRSS" class="headerlink" title="开始部署 TTRSS"></a>开始部署 TTRSS</h2><h3 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h3><p>由于树莓派是 ARM 架构，只能使用 PIP 来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -U docker-compose</span><br></pre></td></tr></table></figure><h3 id="通过-docker-compose-部署-Awesome-TTRSS"><a href="#通过-docker-compose-部署-Awesome-TTRSS" class="headerlink" title="通过 docker-compose 部署 Awesome TTRSS"></a>通过 docker-compose 部署 Awesome TTRSS</h3><p>Awesome TTRSS 是国人提供的 Tiny Tiny RSS 的 Docker 容器，插件和文档都很齐全，根据<a href="http://ttrss.henry.wang/zh/">文档</a>来部署就可以了，这里我<a href="http://ttrss.henry.wang/zh/#%E9%80%9A%E8%BF%87-docker-compose-%E9%83%A8%E7%BD%B2">通过 docker-compose 部署</a>。</p><p>操作成功后，访问 <a href="http://localhost:181/">http://localhost:181</a> 就能访问新鲜出炉的 TTRSS 了 😊</p><h3 id="导入-OPML"><a href="#导入-OPML" class="headerlink" title="导入 OPML"></a>导入 OPML</h3><p>科学上网访问我的 Inoreader，找到导出 OPML 的地方，下载一个 xml 文件到桌面。打开我的 TTRSS 的偏好设置页面，导入 OPML，选择刚才的 xml 文件。好了，我的 TTRSS 订阅源搞定了。</p><h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><p>拉取 RSSHub 的 RSS 源会报一个错：</p><p><code>; 28 Operation timed out after 15000 milliseconds with 0 bytes received</code></p><p>搜索问题发现有<a href="https://community.tt-rss.org/t/28-operation-timed-out-after-15000-milliseconds-with-0-bytes-received-it-can-be-more/2118/12">社区论坛</a>上说修改 php 相关变量可以解决，遂试之，不管用。</p><p>再次搜索发现有说是 dns 问题，需要配置容器的 dns，查了下配置所有容器 dns 的方法，在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。</p><p>随后先停止 ttrss 的容器，再启动，发现问题解决了！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://yeasy.gitbook.io/docker_practice/compose/install#pip-an-zhuang">Docker Compose 安装与卸载</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/network/dns">配置 DNS</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://kinneyyan.github.io/tags/RSS/">RSS</category>
      
      
      <comments>https://kinneyyan.github.io/2020-11-26/%E4%BD%BF%E7%94%A8%20Tiny%20Tiny%20RSS%20%E8%A6%81%E7%82%B9%E5%8F%8A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>低成本搭建私有云（树莓派4B + KodExplorer）</title>
      <link>https://kinneyyan.github.io/2020-11-17/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E6%A0%91%E8%8E%93%E6%B4%BE4B%20+%20KodExplorer%EF%BC%89/</link>
      <guid>https://kinneyyan.github.io/2020-11-17/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E6%A0%91%E8%8E%93%E6%B4%BE4B%20+%20KodExplorer%EF%BC%89/</guid>
      <pubDate>Tue, 17 Nov 2020 06:09:07 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前阵子基于老毛子路由器上搭建的 NAS 方案有几个缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;性能瓶颈：加载缩略图缓慢、在同时加载多张图片、上传几十个</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子基于老毛子路由器上搭建的 NAS 方案有几个缺陷：</p><ol><li>性能瓶颈：加载缩略图缓慢、在同时加载多张图片、上传几十个文件时，路由器的 cpu、内存都是满载的情况，更糟糕的时候会导致路由器直接宕机卡死（都是泪）</li><li>使用 ZeroTier 实现的内网穿透其实是异地组建局域网，必须要在连接的端上安装软件。<del>而且连接的稳定性挺迷的，有时候 <code>zerotier-cli info</code> 显示 ONLINE 了，ZeroTier 后台也显示两端都是 ONLINE 状态，不知道为啥还是 ping 不通</del>（2020-11-24：已解决，路由器防火墙作祟）</li></ol><p>基于以上原因，我购置了一个树莓派 4b（4g 内存），内网穿透方案采用了收费的<a href="https://natapp.cn/">NATAPP</a>。而私有云系统则使用了 <a href="https://kodcloud.com/">KodExplorer</a> 的 Docker 来镜像搭建，经过这次折腾也顺便学习了 Docker 的安装和使用，Docker 的虚拟化容器方案极大的方便了原本需要各种依赖环境的系统搭建。</p><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ol><li>树莓派 4b(4g 内存)：连同盒子、TF 卡、读卡器等套装共￥ 452.00</li><li>2T 的西数红盘 + Orico 3.5 寸硬盘盒：一共￥ 598.72</li><li>NATAPP 的 VIP_1 型隧道 9 元&#x2F;月（二级域名 3 元&#x2F;年）：共￥ 12</li></ol><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="给树莓派安装-Raspberry-Pi-OS"><a href="#给树莓派安装-Raspberry-Pi-OS" class="headerlink" title="给树莓派安装 Raspberry Pi OS"></a>给树莓派安装 Raspberry Pi OS</h3><p>将 TF 卡插到读卡器连接电脑，随后下载官方提供的<a href="https://www.raspberrypi.org/software">Raspberry Pi Imager</a>后，打开。在’Operating System’中选择’Erase’，选好 SD 卡，点击‘WRITE’，先将我们的 TF 卡格式化为 FAT32。</p><p><img src="https://www.raspberrypi.org/homepage-9df4b/static/md-67e1bf35c20ad5893450da28a449efc4.png" alt="Raspberry Pi Imager"></p><p>完成后再从 ‘Operating System’ 选择要刷入的系统镜像，这里我选择了’Raspberry Pi OS with desktop’，选好 SD 卡，点击’WRITE’，耐心等待即可。</p><h3 id="修改默认密码、开启-SSH、VNC、修改软件源"><a href="#修改默认密码、开启-SSH、VNC、修改软件源" class="headerlink" title="修改默认密码、开启 SSH、VNC、修改软件源"></a>修改默认密码、开启 SSH、VNC、修改软件源</h3><p>镜像刷入完成后，将 TF 卡插入树莓派，然后插上网线，另一端连上路由器的 LAN 口（当然如果没有网线的话等开机后连接 WIFI 也行，但是考虑到要做 NAS 用，有线连接会更稳定些，毕竟 4B 的网口也升级成了千兆）。然后通上电源，键盘、鼠标、显示器通通连上，稍等片刻就能看到系统桌面了。</p><p>首次开机会有向导设置，到软件更新那一步先点跳过，因为后续我要自己更换国内软件源再更新。向导设置结束后，需要做一些必要的系统设置：</p><ul><li><p>修改系统默认密码：左上角树莓标志–首选项–Raspberry Pi Configuration–System–Change Password<br><img src="https://qnam.smzdm.com/202010/22/5f91731e7b4de7895.png_e680.jpg" alt="Change Password"></p></li><li><p>开启 SSH、VNC：这两项功能能够方便后期在通过终端（SSH）和桌面环境（VNC）远程登录树莓派。具体步骤：左上角树莓标志–首选项–Raspberry Pi Configuration–Interfaces–SSH&#x2F;VNC–Enable<br><img src="https://qnam.smzdm.com/202010/22/5f917324ee7946396.png_e680.jpg" alt="SSH/VNC"></p></li><li><p>修改软件源（注意：不同的 Debian 版本修改的内容略有不同，具体见<a href="https://yeasy.gitbook.io/docker_practice/install/raspberry-pi">Raspberry Pi - Docker —— 从入门到实践</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br></pre></td></tr></table></figure><p>修改完成后执行以下命令更新软件源列表、更新现有的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>完成上述步骤后，就可以拔掉 HDMI 线和键鼠了。</p><h3 id="将硬盘连上树莓派"><a href="#将硬盘连上树莓派" class="headerlink" title="将硬盘连上树莓派"></a>将硬盘连上树莓派</h3><p>首先我将硬盘格式化为了 FAT32（本次方案对硬盘文件系统没有要求，所以 NTFS、EXT4 应该都可以），然后将硬盘装入 3.5 寸硬盘盒，通上电源，连上树莓派（记得连 USB3.0 的口，蓝色的）。由于我安装的是带桌面的系统，一般硬盘连接上就会被自动挂载了。</p><h3 id="SSH-登录树莓派，安装-Docker"><a href="#SSH-登录树莓派，安装-Docker" class="headerlink" title="SSH 登录树莓派，安装 Docker"></a>SSH 登录树莓派，安装 Docker</h3><p>SSH 前先要获取树莓派在局域网的 IP 地址，可以在之前的步骤中，通过在树莓派的终端输入<code>ifconfig</code>中查看，或者进入路由器后台查看树莓派的 IP。</p><p>打开我的 2015 款 MBP，启动 iterm2，输入 <code>ssh pi@192.168.123.218</code> （这里的 IP 地址是我局域网内的，请自行更改），输完密码后就进入树莓派的 shell 了。</p><p>下一步就要安装 Docker 了，可以通过 APT 安装或者脚本安装。我采用了脚本安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Docker</span></span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立 docker 用户组</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>完成后退出终端并重新登录即可。参考自<a href="https://yeasy.gitbook.io/docker_practice/install/raspberry-pi">Raspberry Pi - Docker —— 从入门到实践</a></p><h3 id="拉取-KodExplorer-的-Docker-镜像、启动"><a href="#拉取-KodExplorer-的-Docker-镜像、启动" class="headerlink" title="拉取 KodExplorer 的 Docker 镜像、启动"></a>拉取 KodExplorer 的 Docker 镜像、启动</h3><p>有幸在 Docker Hub 上找到了一个比较完美的 KodExplorer 镜像，使用方法详见<a href="https://github.com/dennischancs/KodExplorer#KodExplorer-for-all-plaTForm">dennischancs&#x2F;KodExplorer</a></p><p>由于我挂载了 3.5 寸硬盘，在端口映射的配置我做了些许修改，我输入的完整命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name kodexplorer \</span><br><span class="line">  --hostname=kodexplorer \</span><br><span class="line">  -p 5210:5210 \</span><br><span class="line">  -p 5218:5218 \</span><br><span class="line">  -v $HOME/koddata:/koddata \</span><br><span class="line">  -v /media/pi/WD/koddata/admin:/koddata/User/admin/home \</span><br><span class="line">  -v /media/pi/WD/koddata/public:/koddata/Group/public/home \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  dennischancs/kodexplorer</span><br></pre></td></tr></table></figure><p><code>/media/pi/WD/</code> 是我的硬盘挂载的目录，这里我将容器内 KodExplorer 的 admin 和公共目录分别映射到了硬盘下的 admin 和 public 目录。</p><p>容器启动成功后，浏览器访问 <code>树莓派IP:5210</code> 就可以看到 KodExplorer Web 页面了。</p><h3 id="内网穿透：NATAPP"><a href="#内网穿透：NATAPP" class="headerlink" title="内网穿透：NATAPP"></a>内网穿透：NATAPP</h3><p><a href="https://natapp.cn/article/natapp_newbie">NATAPP1 分钟快速新手图文教程</a><br><a href="https://natapp.cn/article/nohup">linux 后台运行 natapp(ngrok)教程</a><br><a href="https://natapp.cn/article/supervisor">natapp(ngrok) Linux 开机自启动</a></p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><a href="https://imgchr.com/i/DZY59J"><img src="https://s3.ax1x.com/2020/11/17/DZY59J.jpg" alt="DZY59J.jpg"></a></p><h2 id="ONE-MORE-THING-——-私有云系统踩坑经历总结"><a href="#ONE-MORE-THING-——-私有云系统踩坑经历总结" class="headerlink" title="ONE MORE THING —— 私有云系统踩坑经历总结"></a>ONE MORE THING —— 私有云系统踩坑经历总结</h2><p>最初是准备装 NextCloudPi 搭建私有云的，然后经历了 NextCloudPi 的 docker 容器版本问题、初始化 looping 等一系列问题后，最终放弃（主要是我不想按传统方式安装，只想通过 Docker 容器来跑，无奈问题一个接一个）。</p><p>期间也有使用国人开发的 <a href="https://cloudreve.org/">CloudReve</a>，相比 NextCloudPi 搭建难度异常简单，将对应架构的程序包下载下来解压、赋权执行脚本就行了：<code>./cloudreve &gt; cloudreve.log 2&gt;&amp;1 &amp;</code>。最后放弃的原因主要是因为功能相比 KodExplorer 少了些，也没有公共目录，其他其实都挺好，尤其是 UI，采用的 MD 风格还做了 PWA。所以如果是颜值党且不需要公共目录的话完全可以用 CloudReve 搭建私有云。</p><p><a href="https://imgchr.com/i/DZNywV"><img src="https://s3.ax1x.com/2020/11/17/DZNywV.png" alt="CloudReve 的 UI 是真的不错"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://post.smzdm.com/p/akmvd9rr">用树莓派搭建私人简易网盘 2&#x2F;5 树莓派 4B 初始设置</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian">Raspbian 镜像使用帮助</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/install/raspberry-pi">Raspberry Pi - Docker —— 从入门到实践</a></li></ul><h3 id="NextCloudPi-相关资料"><a href="#NextCloudPi-相关资料" class="headerlink" title="NextCloudPi 相关资料"></a>NextCloudPi 相关资料</h3><ul><li><a href="https://ownyourbits.com/2017/11/15/nextcloudpi-dockers-for-x86-and-arm">官方 Docker 镜像教程 1</a></li><li><a href="https://ownyourbits.com/2017/06/08/nextcloudpi-docker-for-raspberry-pi">官方 Docker 镜像教程 2</a></li><li><a href="https://sspai.com/post/58675">Raspberry Pi 树莓派 3B 结合 NextCloud PI 搭建皮米级 NAS 家庭储存</a></li><li><a href="https://www.hi-linux.com/posts/35330.html">手把手教会你解决 Chrome 访问非受信证书页面时，提示「您的连接不是私密连接」错误的方法</a></li></ul><p>EOF</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://kinneyyan.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</category>
      
      
      <comments>https://kinneyyan.github.io/2020-11-17/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E6%A0%91%E8%8E%93%E6%B4%BE4B%20+%20KodExplorer%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux 下 ZeroTier 的安装和使用</title>
      <link>https://kinneyyan.github.io/2020-11-11/%20Linux%20%E4%B8%8B%20ZeroTier%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <guid>https://kinneyyan.github.io/2020-11-11/%20Linux%20%E4%B8%8B%20ZeroTier%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Wed, 11 Nov 2020 03:24:22 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;账号注册流程见官网：&lt;a href=&quot;https://www.zerotier.com/download&quot;&gt;https://www.zerotier.com/download&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerli</description>
        
      
      
      
      <content:encoded><![CDATA[<p>账号注册流程见官网：<a href="https://www.zerotier.com/download">https://www.zerotier.com/download</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">zerotier-one -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取地址和服务状态</span></span><br><span class="line">zerotier-cli status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入、离开、列出网络</span></span><br><span class="line">zerotier-cli join &lt;Network ID&gt;</span><br><span class="line">zerotier-cli leave &lt;Network ID&gt;</span><br><span class="line">zerotier-cli listnetworks</span><br></pre></td></tr></table></figure><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start zerotier-one.service</span><br><span class="line">sudo systemctl enable zerotier-one.service</span><br></pre></td></tr></table></figure><p>在树莓派上也可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/rc.local</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 <span class="built_in">exit</span> 0 所在行之前前添加以下代码</span></span><br><span class="line">zerotier-one -d</span><br></pre></td></tr></table></figure><h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><p>如果 ZeroTier 是安装在路由器上的，<strong>务必</strong>设置防火墙规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT  -i ztmjflx5xm -j ACCEPT</span><br><span class="line">iptables -I FORWARD -i ztmjflx5xm -j ACCEPT</span><br><span class="line">iptables -I FORWARD -o ztmjflx5xm -j ACCEPT</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用来设置转发流量到路由器下的内网设备</span></span><br><span class="line">iptables -t nat -I POSTROUTING -o ztmjflx5xm -j MASQUERADE</span><br><span class="line">zerotier-one -d</span><br></pre></td></tr></table></figure><p><code>ztmjflx5xm</code> 为我的虚拟网卡 id，可以通过 <code>ifconfig</code> 查看自己的虚拟网卡。</p><p>我已经将上述代码放到每次路由器启动后执行（老毛子后台设置在：[高级设置]-[自定义设置]-[脚本]-[在路由器启动后执行]）</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><ul><li><a href="https://blog.boxks.com/archives/zerotier-0ffsite-networking/">使用 ZeroTier 异地组网</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://kinneyyan.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/">内网穿透</category>
      
      
      <comments>https://kinneyyan.github.io/2020-11-11/%20Linux%20%E4%B8%8B%20ZeroTier%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>低成本搭建私有云（老毛子 + KodExplorer）</title>
      <link>https://kinneyyan.github.io/2020-11-10/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%80%81%E6%AF%9B%E5%AD%90%20+%20KodExplorer%EF%BC%89/</link>
      <guid>https://kinneyyan.github.io/2020-11-10/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%80%81%E6%AF%9B%E5%AD%90%20+%20KodExplorer%EF%BC%89/</guid>
      <pubDate>Tue, 10 Nov 2020 06:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本准备给家里购置一台 NAS，然后上网研究了下，发现无论是群晖还是威联通，想要买一台自己满意的 NAS（4 盘位、x86 CPU），价格基</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本准备给家里购置一台 NAS，然后上网研究了下，发现无论是群晖还是威联通，想要买一台自己满意的 NAS（4 盘位、x86 CPU），价格基本都是 2000 上下，有点小贵……后来在网上搜索之余发现有通过路由器配合 <code>KodExplorer</code> 搭建私有云的教程，想起来家里正在用的新路由 3 支持，随即开始搭（cai）建（keng）之旅。当然最后是搭建成功了，但是有必要在这里记录一下关键步骤和坑点。</p><p>期间也考虑到了内网穿透问题，最后采用了免费易上手的 <code>ZeroTier</code>。</p><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ol><li>刷了老毛子（Padavan）固件的路由器（关于路由器能否&#x2F;如何刷老毛子，本文不做介绍，因为我的新路由 3 是买来就刷好的。tb 搜索‘路由器 老毛子’即可）</li><li>一块 2T 的西数红盘</li></ol><p><em>所有成本就是路由器+硬盘+硬盘盒的价格，总共 700 出头</em></p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h3><p>将硬盘连接到新路由 3 的 USB 口后，打开路由器控制台，按下图操作：</p><p><a href="https://imgchr.com/i/Bhk9kF"><img src="https://s1.ax1x.com/2020/11/06/Bhk9kF.png" alt="Bhk9kF.png"></a></p><p>这里我遇到的问题是：虽然通过控制台这么操作了，但是实际上硬盘并没有格式化成 EXT4（从控制台 Log 中看出来），从而导致后续安装过程出错。所以最后我是通过 ssh 到路由器，通过命令行将硬盘格式化为 ext4 的。参考：<a href="https://www.jianshu.com/p/f96ca9cb89da">linux 命令行格式化 ext4</a>。</p><h3 id="USB-应用程序设置（可选）"><a href="#USB-应用程序设置（可选）" class="headerlink" title="USB 应用程序设置（可选）"></a>USB 应用程序设置（可选）</h3><p>这一步可选，主要是针对硬盘的一些配置：</p><p><a href="https://imgchr.com/i/BhEuzd"><img src="https://s1.ax1x.com/2020/11/06/BhEuzd.png" alt="BhEuzd.png"></a></p><p>参考：<a href="http://www.duomingxing.com/jiaocheng/padavan/71.php">Padavan 老毛子 U 盘硬盘共享一些细节参数设置</a></p><h3 id="将-opt-安装模式改为‘安装到-U-盘’"><a href="#将-opt-安装模式改为‘安装到-U-盘’" class="headerlink" title="将 opt 安装模式改为‘安装到 U 盘’"></a>将 opt 安装模式改为‘安装到 U 盘’</h3><p><a href="https://imgchr.com/i/BhVZmq"><img src="https://s1.ax1x.com/2020/11/06/BhVZmq.png" alt="BhVZmq.png"></a></p><p>根据上图改好后，点击最下方‘应用本页面设置‘，页面刷新后，再点击’重置 opt 文件‘，随后观察日志、等待。直到’当前 opt 文件’有显示正确的版本号就说明成功了。</p><h3 id="开启-LNMP"><a href="#开启-LNMP" class="headerlink" title="开启 LNMP"></a>开启 LNMP</h3><p><a href="https://imgchr.com/i/BhZTRe"><img src="https://s1.ax1x.com/2020/11/06/BhZTRe.png" alt="BhZTRe.png"></a></p><p>根据上图操作后，耐心等待（一定要耐心），观察日志同时红线处显示了版本号就说明安装成功了。</p><p>安装成功之后就要开始安装 KodExplorer 了，这里我没有马上打开老毛子控制台上 KodExplorer 的开关，原因有 2 个：1. 开启后，路由器会执行 lnmp 中的脚本 wget 下载 zip 包，这一步很可能因为网络原因速度很慢下载不下来；2. lnmp 脚本中指定的 KodExplorer 的 zip 包并不是最新的版本。</p><h3 id="下载-x2F-安装-KodExplorer"><a href="#下载-x2F-安装-KodExplorer" class="headerlink" title="下载&#x2F;安装 KodExplorer"></a>下载&#x2F;安装 KodExplorer</h3><p>KodExplorer 是一个国内团队开发的基于 Web 技术的私有云在线文档管理解决方案。个人用户也可以通过搭建 KodExplorer 实现自己的一套私有云。</p><p>首先我去官网下载 KodeExplorer 的<a href="http://static.kodcloud.com/update/download/kodexplorer4.40.zip">最新版本的 zip 包</a></p><p>然后通过 scp（scp 命令参考我博客中的<a href="https://kinneyyan.github.io/2019-04-08/SSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">SSH 常用命令</a>）将 zip 包传到路由器的 <code>/opt</code> 路径下，再 ssh 到路由器，将 zip 解压到 <code>/opt/wwwroot/Kodexplorer</code>（通常解压下来还有一层目录，要将那一层目录下的文件放到此目录下）。</p><p>操作完成后，再去老毛子控制台：</p><p><a href="https://imgchr.com/i/Bhm2Ax"><img src="https://s1.ax1x.com/2020/11/06/Bhm2Ax.png" alt="Bhm2Ax.png"></a></p><p>点击下方‘应用本页面设置’后，观察日志你会发现，lnmp 脚本发现我们已经有解压好的 KodeExplorer 了，就不执行下载转而进行后续配置了。</p><p>观察日志提示成功后，我们就可以访问 <code>路由器IP地址:88</code> ，首次访问创建账号密码后，就可以进入 KodExplorer 的页面啦：</p><p><a href="https://imgchr.com/i/BqSoKH"><img src="https://s1.ax1x.com/2020/11/10/BqSoKH.png" alt="BqSoKH.png"></a></p><p><a href="https://imgchr.com/i/BhnXZR"><img src="https://s1.ax1x.com/2020/11/06/BhnXZR.png" alt="BhnXZR.png"></a></p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>这里列下当初我考虑的几种方案：</p><ul><li><p>公网 IP+DDNS+端口转发（家里没有公网 IP，放弃）：<a href="https://sspai.com/post/60303">家里搭建了 NAS 需要远程访问？这几个步骤很重要</a></p></li><li><p>ddnsto（老毛子自带，配置方便，但只能通过 web 端访问并需要微信登录）：<a href="https://zhuanlan.zhihu.com/p/79778358">0 成本搭建个人私有云</a></p></li><li><p>ZeroTier（配置方便，但需要连接的两端安装客户端，最后采用此方案）：<a href="https://zhuanlan.zhihu.com/p/73552123">老毛子 Padavan 路由器安装 ZeroTier</a>、<a href="https://zhih.me/zerotier-getting-started">ZeroTier 内网穿透教程</a></p></li><li><p><a href="https://natapp.cn/">NATAPP</a>（一款基于 ngrok 的内网穿透服务，有免费有付费。表哥推荐，后续准备试用下）</p></li></ul><p>EOF</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      
      <comments>https://kinneyyan.github.io/2020-11-10/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%80%81%E6%AF%9B%E5%AD%90%20+%20KodExplorer%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>tmux 常用命令</title>
      <link>https://kinneyyan.github.io/2019-04-15/tmux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>https://kinneyyan.github.io/2019-04-15/tmux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Mon, 15 Apr 2019 03:10:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;新建会话&quot;&gt;&lt;a href=&quot;#新建会话&quot; class=&quot;headerlink&quot; title=&quot;新建会话&quot;&gt;&lt;/a&gt;新建会话&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tmux&lt;/code&gt;: 新建一个无名称的会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux new -s</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h3><ul><li><code>tmux</code>: 新建一个无名称的会话</li><li><code>tmux new -s demo</code>: 新建一个名称为 demo 的会话</li></ul><h3 id="断开当前会话"><a href="#断开当前会话" class="headerlink" title="断开当前会话"></a>断开当前会话</h3><ul><li><code>tmux detach</code>: 断开当前会话，会话在后台运行（快捷键：[prefix]+d）</li></ul><h3 id="进入之前的会话"><a href="#进入之前的会话" class="headerlink" title="进入之前的会话"></a>进入之前的会话</h3><ul><li><code>tmux a</code>: 默认进入第一个会话</li><li><code>tmux a -t demo</code>: 进入到名称为 demo 的会话</li></ul><h3 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h3><ul><li><code>tmux kill-session -t demo</code>: 关闭 demo 会话</li><li><code>tmux kill-server</code>: 关闭服务器，所有的会话都将关闭</li></ul><h3 id="查看所有的会话"><a href="#查看所有的会话" class="headerlink" title="查看所有的会话"></a>查看所有的会话</h3><ul><li>快捷键：[prefix] + s</li></ul><h3 id="常用快捷指令"><a href="#常用快捷指令" class="headerlink" title="常用快捷指令"></a>常用快捷指令</h3><p>默认 <code>[prefix]</code> 为 <code>ctrl + b</code></p><h4 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h4><ul><li><code>[prefix] + d</code>: 断开当前会话</li><li><code>[prefix] + s</code>: 显示会话列表用于选择并切换</li><li><code>[prefix] + :</code>: 进入命令行模式，此时可直接输入 ls 等命令</li></ul><h4 id="window-指令"><a href="#window-指令" class="headerlink" title="window 指令"></a>window 指令</h4><ul><li><code>[prefix] + c</code>: 新建窗口</li><li><code>[prefix] + &amp;</code>: 关闭当前窗口</li><li><code>[prefix] + 0~9</code>: 切换到指定窗口</li><li><code>[prefix] + p</code>: 切换到上一窗口</li><li><code>[prefix] + n</code>: 切换到下一窗口</li><li><code>[prefix] + w</code>: 打开窗口列表，用于切换窗口</li><li><code>[prefix] + ,</code>: 重命名当前窗口</li></ul><h4 id="pane-指令"><a href="#pane-指令" class="headerlink" title="pane 指令"></a>pane 指令</h4><ul><li><code>[prefix] + &quot;</code>: 当前面板上下一分为二</li><li><code>[prefix] + %</code>: 当前面板左右一分为二</li><li><code>[prefix] + x</code>: 关闭当前面板</li><li><code>[prefix] + z</code>: 最大化当前面板，再重复一次按键后恢复正常</li><li><code>[prefix] + &#123;</code>: 向前置换当前面板</li><li><code>[prefix] + &#125;</code>: 向后置换当前面板</li><li><code>[prefix] + o</code>: 选择下一面板</li><li><code>[prefix] + Alt+方向键</code>: 以 5 个单元格为单位调整当前面板边缘</li><li><code>[prefix] + Alt+方向键</code>: 以 5 个单元格为单位调整当前面板边缘</li></ul><hr><blockquote><p>参考自：<a href="http://louiszhai.github.io/2017/09/30/tmux">http://louiszhai.github.io/2017/09/30/tmux</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      
      <comments>https://kinneyyan.github.io/2019-04-15/tmux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SSH 常用命令</title>
      <link>https://kinneyyan.github.io/2019-04-08/SSH%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>https://kinneyyan.github.io/2019-04-08/SSH%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Mon, 08 Apr 2019 02:11:39 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;远程登录&quot;&gt;&lt;a href=&quot;#远程登录&quot; class=&quot;headerlink&quot; title=&quot;远程登录&quot;&gt;&lt;/a&gt;远程登录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;以用户名 user，登录远程主机 host&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highligh</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><ul><li>以用户名 user，登录远程主机 host</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> user<span class="variable">@host</span></span><br></pre></td></tr></table></figure><ul><li>如果本地用户名与远程用户名一致，登录时可以省略用户名</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh host</span></span><br></pre></td></tr></table></figure><h2 id="传输文件-scp"><a href="#传输文件-scp" class="headerlink" title="传输文件: scp"></a>传输文件: scp</h2><ul><li>从远程复制文件到本地目录</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user<span class="variable">@host</span><span class="symbol">:/opt/soft/nginx-</span><span class="number">0.5</span>.<span class="number">38</span>.tar.gz /opt/soft/</span><br></pre></td></tr></table></figure><ul><li>从远程复制目录到本地</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r user<span class="variable">@host</span><span class="symbol">:/opt/soft/mongodb</span> /opt/soft/</span><br></pre></td></tr></table></figure><ul><li>从本地上传文件&#x2F;目录到远程<br>同 1、2，参数顺序反过来就行</li></ul>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://kinneyyan.github.io/tags/ssh/">ssh</category>
      
      
      <comments>https://kinneyyan.github.io/2019-04-08/SSH%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>find, grep 命令速查</title>
      <link>https://kinneyyan.github.io/2019-01-29/find,%20grep%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</link>
      <guid>https://kinneyyan.github.io/2019-01-29/find,%20grep%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</guid>
      <pubDate>Tue, 29 Jan 2019 06:08:19 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;平时使用命令行要进行搜索相关的操作时，老是记不住 find 和 grep 命令的参数，这里记一下方便之后速查。&lt;/p&gt;
&lt;h2 id=&quot;find&quot;&gt;&lt;a href=&quot;#find&quot; class=&quot;headerlink&quot; title=&quot;find&quot;&gt;&lt;/a&gt;find&lt;/h2&gt;&lt;h</description>
        
      
      
      
      <content:encoded><![CDATA[<p>平时使用命令行要进行搜索相关的操作时，老是记不住 find 和 grep 命令的参数，这里记一下方便之后速查。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="在-x2F-home-目录下查找以-txt-结尾的文件名"><a href="#在-x2F-home-目录下查找以-txt-结尾的文件名" class="headerlink" title="在 &#x2F;home 目录下查找以 .txt 结尾的文件名"></a>在 &#x2F;home 目录下查找以 .txt 结尾的文件名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="同上，但忽略大小写"><a href="#同上，但忽略大小写" class="headerlink" title="同上，但忽略大小写"></a>同上，但忽略大小写</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -iname &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="当前目录及子目录下查找所有以-txt-和-pdf-结尾的文件"><a href="#当前目录及子目录下查找所有以-txt-和-pdf-结尾的文件" class="headerlink" title="当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件"></a>当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br></pre></td></tr></table></figure><h3 id="匹配文件路径或者文件"><a href="#匹配文件路径或者文件" class="headerlink" title="匹配文件路径或者文件"></a>匹配文件路径或者文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure><h3 id="找出-x2F-home-下不是以-txt-结尾的文件"><a href="#找出-x2F-home-下不是以-txt-结尾的文件" class="headerlink" title="找出&#x2F;home 下不是以.txt 结尾的文件"></a>找出&#x2F;home 下不是以.txt 结尾的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="根据文件类型进行搜索"><a href="#根据文件类型进行搜索" class="headerlink" title="根据文件类型进行搜索"></a>根据文件类型进行搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type 类型参数</span><br></pre></td></tr></table></figure><p>类型参数列表：</p><ul><li>f 普通文件</li><li>l 符号连接</li><li>d 目录</li><li>c 字符设备</li><li>b 块设备</li><li>s 套接字</li><li>p Fifo</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><h3 id="在文件中搜索一个单词，命令会返回一个包含-“match-pattern”-的文本行"><a href="#在文件中搜索一个单词，命令会返回一个包含-“match-pattern”-的文本行" class="headerlink" title="在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行"></a>在文件中搜索一个单词，命令会返回一个包含 <strong>“match_pattern”</strong> 的文本行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure><h3 id="统计文件或者文本中包含匹配字符串的行数-c-选项"><a href="#统计文件或者文本中包含匹配字符串的行数-c-选项" class="headerlink" title="统计文件或者文本中包含匹配字符串的行数 -c 选项"></a>统计文件或者文本中包含匹配字符串的行数 <strong>-c</strong> 选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c &quot;text&quot; file_name</span><br></pre></td></tr></table></figure><h3 id="输出包含匹配字符串的行数-n-选项"><a href="#输出包含匹配字符串的行数-n-选项" class="headerlink" title="输出包含匹配字符串的行数 -n 选项"></a>输出包含匹配字符串的行数 <strong>-n</strong> 选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;text&quot; -n file_name</span><br></pre></td></tr></table></figure><h3 id="在多级目录中对文本进行递归搜索"><a href="#在多级目录中对文本进行递归搜索" class="headerlink" title="在多级目录中对文本进行递归搜索"></a>在多级目录中对文本进行递归搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;text&quot; . -r -n</span><br></pre></td></tr></table></figure><blockquote><p>参考自：<a href="https://wangchujiang.com/linux-command">Linux 命令搜索引擎</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Linux/">Linux</category>
      
      
      <comments>https://kinneyyan.github.io/2019-01-29/find,%20grep%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>git rebase 交互模式的使用</title>
      <link>https://kinneyyan.github.io/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <guid>https://kinneyyan.github.io/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Wed, 16 Jan 2019 05:59:30 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;使用 &lt;code&gt;git rebase -i &amp;lt;branch&amp;gt;&lt;/code&gt; 可以进入交互式模式，可以对 &lt;strong&gt;某一范围内的提交&lt;/strong&gt; 进行重新编辑。&lt;/p&gt;
&lt;p&gt;默认情况下，直接使用 &lt;code&gt;git rebase -i&lt;/code&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>使用 <code>git rebase -i &lt;branch&gt;</code> 可以进入交互式模式，可以对 <strong>某一范围内的提交</strong> 进行重新编辑。</p><p>默认情况下，直接使用 <code>git rebase -i</code> 命令的操作对象为自最后一次从 origin 仓库拉取或者向 origin 推送之后的所有提交。</p><h2 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h2><p>假设我要把 master 上红色区域的分支合并成一个提交</p><p><img src="https://image-static.segmentfault.com/281/046/2810467133-5a60c6023a3f0"></p><p>首先找到起始 commit 的 前一个，也就是 <code>865b2ac</code>，rebase 会显示当前分支从这个 comimt 之后的所有 commit。</p><p>执行 <code>git rebase -i 865b2ac</code>，会自动唤出编辑器，内容如下：</p><p><img src="https://image-static.segmentfault.com/375/466/3754664714-5a60c78e73aff"></p><p>这些信息表示从 <code>865b2ac</code> commit 操作后有 4 个提交。每个提交都用一行来表示，按时间顺序展示，首行是最早的提交，末行是最新的提交，行格式如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">action</span>) (<span class="name">partial-sha</span>) (<span class="name"><span class="built_in">short</span></span> commit message)</span><br></pre></td></tr></table></figure><p>当修改这个文件后，git 会依次把这些 commit 按照 action 重新执行。action 有很多种，默认都是 <code>pick</code>，即使用该 commit，不作任何修改。</p><p>我们现在想把后三个提交合并到第一个中去，这里需要用到 <code>squash</code>，该 action 表示 使用该提交，但是把它与前一提交合并，所以只需把后四个的 action 改为 squash 即可。</p><p><img src="https://image-static.segmentfault.com/342/468/342468431-5a60c67e10149"></p><p>保存之后，会唤出编辑器提示基于历史的提交信息创建一个新的提交信息，也就是需要用户编辑一下合并之后的 commit 信息，更改提示信息并保存即可。</p><p>合并完之后的历史记录：</p><p><img src="https://image-static.segmentfault.com/208/861/2088619411-5a60c69095b66"></p><h2 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h2><p>如果想把某个 commit 拆分成多个 commit，可以使用 <code>edit</code> 作为 action，edit 表示 <strong>使用该提交，但是先在这一步停一下，等我重新编辑完再进行下一步。</strong></p><p>初始状态如下：</p><p><img src="https://image-static.segmentfault.com/208/861/2088619411-5a60c69095b66"></p><p><code>just add a new line</code> 这个 commit 修改了两个文件 <code>myfile.txt</code> 和 <code>anothorfile.txt</code>，我们希望把它拆成两个 commit，每个文件的修改各提交一个 commit</p><p>执行 <code>git rebase -i 13243ea</code>，然后修改 <code>865b2ac</code> 这个 commit 的 action 为 <code>edit</code></p><p><img src="https://image-static.segmentfault.com/280/539/2805395445-5a60c6c6471a5"></p><p>保存并退出后，git 会提示在 <code>865b2ac</code> 上停止了</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  git rebase -i <span class="number">13243</span>ea</span><br><span class="line">Stopped <span class="keyword">at</span> <span class="number">865</span>b2ac... just <span class="built_in">add</span> <span class="keyword">a</span> <span class="built_in">new</span> <span class="built_in">line</span></span><br><span class="line">You can amend <span class="keyword">the</span> commit now, <span class="keyword">with</span></span><br><span class="line">    git commit <span class="comment">--amend</span></span><br><span class="line">Once you are satisfied <span class="keyword">with</span> your changes, run</span><br><span class="line">    git rebase <span class="comment">--continue</span></span><br></pre></td></tr></table></figure><p>这里可以使用 <code>git commit --amend</code> 命令对 commit 信息进行重新编辑</p><p>我们这里是要拆分 commit，所以要先对 commit 内容 reset，然后重新提交</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  git <span class="built_in">reset</span> HEAD^ # 撤销提交</span><br><span class="line">Unstaged changes after <span class="built_in">reset</span>:</span><br><span class="line">M   myfile.txt</span><br><span class="line">M   anotherfile.txt</span><br><span class="line">➜  git add myfile.txt # 拆解出第一个提交</span><br><span class="line">➜  git commit -m &#x27;<span class="built_in">first</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit&#x27;</span><br><span class="line">[detached HEAD d0727f7] <span class="built_in">first</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line">➜  git add anotherfile.txt # 拆解出第二个提交</span><br><span class="line">➜  git commit -m &#x27;<span class="built_in">second</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit&#x27;</span><br><span class="line">[detached HEAD 2302fc7] <span class="built_in">second</span> <span class="built_in">part</span> of <span class="built_in">split</span> commit</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> anotherfile.txt</span><br><span class="line">➜  git rebase --continue</span><br><span class="line">Successfully rebased <span class="keyword">and</span> updated refs/heads/master.</span><br></pre></td></tr></table></figure><p>拆分完成后使用 <code>git rebase --continue</code> 即结束 rebase，结果如下：</p><p><img src="https://image-static.segmentfault.com/389/902/389902978-5a60c6ecbb37d"></p><h2 id="删除提交"><a href="#删除提交" class="headerlink" title="删除提交"></a>删除提交</h2><p>如果想删除某个提交，使用 git rebase -i 后直接在编辑器中删除那一行 commit 即可</p><p><img src="https://image-static.segmentfault.com/611/432/611432141-5a60c6fd9dbe2"></p><p>假设删除的是 commit 2，那么编辑完成后 git 会比较 commit 1 与 commit 3 的差异，如果有冲突，需要手动解决冲突后 add 并 <code>git rebase --continue</code></p><p><img src="https://image-static.segmentfault.com/608/244/608244281-5a60c7117654b"></p><blockquote><p>转自：<a href="https://segmentfault.com/a/1190000012897755">https://segmentfault.com/a/1190000012897755</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Git/">Git</category>
      
      
      <comments>https://kinneyyan.github.io/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React 的生命周期(转)</title>
      <link>https://kinneyyan.github.io/2019-01-07/React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%BD%AC/</link>
      <guid>https://kinneyyan.github.io/2019-01-07/React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%BD%AC/</guid>
      <pubDate>Mon, 07 Jan 2019 09:25:06 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;转自 Ant Design 实战教程：&lt;a href=&quot;https://www.yuque.com/ant-design/course/lifemethods&quot;&gt;https://www.yuque.com/ant-design/course/lif</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>转自 Ant Design 实战教程：<a href="https://www.yuque.com/ant-design/course/lifemethods">https://www.yuque.com/ant-design/course/lifemethods</a></p></blockquote><p>你有没有遇到过这样的问题:</p><ul><li>组件的生命周期有哪些？为什么要有生命周期函数?</li><li>我应该什么时候去获取后台数据? 为什么很多教程都推荐用 componentDidMount? 用 componentWillMount 会有什么问题?</li><li>为什么 setState 写在这里造成了重复渲染多次？</li><li>setState 在这里写合适吗？</li></ul><p>读完本文希望你能对 React 的组件生命周期有一定的了解，编写 React 代码的时候能够更加得心应手，注意本文的生命周期讲的主要是浏览器端渲染，这是后端和全栈的主要使用方式，服务端渲染有些不一样，请注意区分，我们会在文中进行简单说明。</p><blockquote><p>Update: 更新为 React16 版本，React16 由于异步渲染等特性会让之前的一些方法如 componentWillMount 变得不够安全高效逐步废弃，详见<a href="https://reactjs.org/docs/react-component.html#legacy-lifecycle-methods">Legacy Methods</a></p></blockquote><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>如果你做过安卓开发方面的编程，那么你应该了解 onCreate，onResume，onDestrory 等常见生命周期方法，生命周期函数说白了就是让我们在一个组件的各个阶段都提供一些钩子函数来让开发者在合适的时间点可以介入并进行一些操作，比如初始化(onCreate)的时候我们应该初始化组件相关的状态和变量，组件要销毁(onDestrory)时，我们应该把一些数据结构销毁掉以节约内存，防止后台任务一直运行。在 java 类中也存在一个最常见的钩子函数 contructor，你可以在这里调用 super 方法初始化父类，也可以在这里初始化各种变量。</p><p>我们先看下下面的图建立一个 React 组件生命周期的直观认识，图为 React 16 的生命周期，总的来说 React 组件的生命周期分为三个部分: <code>装载期间(Mounting)</code> ，<code>更新期间(Updating)</code> 和<code>卸载期间(Unmounting)</code> ，React16 多出来一个<a href="https://reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch()</a> 函数用于捕捉错误。知道什么时候去使用哪些生命周期函数对于掌握和理解 React 是非常重要的，你可以看到这些生命周期函数有一定的规律，比如在某件事情发生之前调用的会用 xxxWillxxx，而在这之后发生的会用 xxxDidxxx。</p><p>&#x2F;&#x2F; 图来源于网络（侵删)</p><p><img src="https://cdn.yuque.com/lark/0/2018/png/5482/1528371738002-2a20482c-f375-45d0-a7e9-3492e2496b0f.png" alt="image.png | left | 747x414"></p><p>接下来我们就这三个阶段分别介绍一下各个生命周期函数，详细的生命周期函数解释可以看官方文档 <a href="https://reactjs.org/docs/react-component.html">React.Component</a>。</p><hr><h3 id="装载期间"><a href="#装载期间" class="headerlink" title="装载期间"></a>装载期间</h3><p>组件被实例化并挂载在到 DOM 树这一过程称为装载，在装载期调用的生命周期函数依次为</p><ul><li><a href="https://reactjs.org/docs/react-component.html#constructor">constructor()</a></li><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps</a>()</li><li><a href="https://reactjs.org/docs/react-component.html#render">render()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidmount">componentDidMount()</a></li></ul><hr><h4 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h4><p>构造函数，用于初始化这个组件的一些状态和操作，如果你是通过继承<code>React.Component</code>子类来创建 React 的组件的，那么你应当首先调用<code>super(props)</code> 初始化父类。</p><p>在 contructor 函数中，你可以<strong>初始化 state</strong>，比如<code>this.state = &#123;xxx&#125;;</code>，不要在构造函数中使用 setState()函数，强行使用的话 React 会报错。其次你可以在构造函数中<strong>进行函数 bind</strong>，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure><p>一个示例 contructor 实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不需要初始化状态也不需要绑定 handle 函数的 this，那么你可以不实现 constructor 函数，由默认实现代替。</p><hr><h4 id="关于-bind-函数的解释说明"><a href="#关于-bind-函数的解释说明" class="headerlink" title="关于 bind 函数的解释说明"></a>关于 bind 函数的解释说明</h4><p>注意 js 的 this 指向比较特殊，比如以下的例子作为 onClick 回调函数由 button 组件去调用的时候不会把组件类的上下文带过去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handleClick&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line"> &lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt;click&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>这种问题推荐三种可能的解决方式，其核心均为将函数的 this 强制绑定到组件类上:<br>1. 就是上面说的在 constructor 函数中显示调用 bind。<br>2. 在 onClick 的时候进行 bind: <code>&lt;button onClick = &#123;this.handleClick.bind(this)&#125; &gt;</code>，这种方式的劣势是每次调用的时候都需要进行 bind，优势是方便传参，处理函数需要传参可以参考 React 的文档 <a href="https://reactjs.org/docs/handling-events.html#passing-arguments-to-event-handlers">Passing Arguments to Event Handlers</a><br>3. 声明函数时使用箭头匿名函数，箭头函数会自动设置 this 为当前类。(<strong>简洁有效，墙裂推荐</strong>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;handleClick&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// Component</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps()"></a>getDerivedStateFromProps()</h4><p>这个函数会在 render 函数被调用之前调用，包括第一次的初始化组件以及后续的更新过程中，<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state。</span></span></p><p>该方法主要用来替代<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">componentWillReceiveProps 方法，willReceiveProps 经常被误用，导致了一些问题，因此在新版本中被标记为 unsafe。以</span></span><a href="https://juejin.im/post/5abf4a09f265da237719899d">掘金</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">上的 🌰 为例，</span></span>componentWillReceiveProps 的常见用法如下，根据传进来的属性值判断是否要 load 新的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isScrollingDown</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">currentRow</span> !== nextProps.<span class="property">currentRow</span>) &#123;</span><br><span class="line">      <span class="comment">// 检测到变化后更新状态、并请求数据</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">isScrollingDown</span>: nextProps.<span class="property">currentRow</span> &gt; <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">currentRow</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">loadAsyncData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loadAsyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个方法的一个问题是<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">外部组件多次频繁更新传入多次不同的 props，而该组件将这些更新 batch 后仅仅触发单次自己的更新，这种写法会导致不必要的异步请求，相比下来</span></span>getDerivedStateFromProps 配合 componentDidUpdate 的写法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isScrollingDown</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">lastRow</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// 不再提供 prevProps 的获取方式</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.<span class="property">currentRow</span> !== prevState.<span class="property">lastRow</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">isScrollingDown</span>: nextProps.<span class="property">currentRow</span> &gt; prevState.<span class="property">lastRow</span>,</span><br><span class="line">        <span class="attr">lastRow</span>: nextProps.<span class="property">currentRow</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认不改动 state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 仅在更新触发后请求数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">loadAsyncData</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loadAsyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式只在更新触发后请求数据，相比下来更节省资源。</p><blockquote><p>注意<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">getDerivedStateFromProps 是一个 static 方法，意味着拿不到实例的 this</span></span></p></blockquote><hr><h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><blockquote><p>该方法在一个 React 组件中是必须实现的，你可以看成是一个 java interface 的接口</p></blockquote><p>这是 React 组件的核心方法，用于根据状态 state 和属性 props 渲染一个 React 组件。我们应该保持该方法的纯洁性，这会让我们的组件更易于理解，只要 state 和 props 不变，每次调用 render 返回的结果应当相同，所以请<strong>不要在 render 方法中改变组件状态，也不要在在这个方法中和浏览器直接交互</strong>。</p><p>如果你 React 如何使用 render 方法原理不太了解，可以阅读文章《<a href="https://lark.alipay.com/afx-es/ffb/react-intro">当 React 来敲门</a>》。</p><hr><h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h4><p>componentDidMount 方法会在 render 方法之后立即被调用，该方法在整个 React 生命周期中只会被调用一次。React 的组件树是一个树形结构，此时你可以认为这个组件以及他下面的所有子组件都已经渲染完了，所以在这个方法中你可以调用和真实 DOM 相关的操作了。</p><p>有些组件的启动工作是依赖 DOM 的，例如动画的启动，而  <code>componentWillMount</code>  的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在  <code>componentDidMount</code>  当中。</p><p>我们推荐可以在这个函数中<strong>发送异步请求</strong>，在回调函数中调用 setState()设置 state，等数据到达后触发重新渲染。但注意尽量<strong>不要</strong>在这个函数中<strong>直接调用</strong>setState()设置状态，这会触发一次额外的重新渲染，可能造成性能问题。</p><p>下面的代码演示了如何在 componentDidMount 加载数据并设置状态:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentDidMount&#x27;</span>);</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://api.github.com/search/repositories?q=language:java&amp;sort=stars&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="comment">// 触发render</span></span><br><span class="line">          <span class="attr">items</span>: result.<span class="property">items</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;);</span><br><span class="line">  <span class="comment">// this.setState(&#123;color: xxx&#125;) // 不要这样做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="更新期间"><a href="#更新期间" class="headerlink" title="更新期间"></a>更新期间</h3><p>当组件的状态或属性变化时会触发更新，更新过程中会依次调用以下方法:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps()</a> 上文已描述，不赘述</li><li><a href="https://reactjs.org/docs/react-component.html#unsafe_componentwillupdate">componentWillUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#render">render()</a></li><li><a href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidupdate">componentDidUpdate()</a></li></ul><hr><h4 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h4><p>你可以用这个方法来告诉 React 是否要进行下一次 render()，默认这个函数放回 true，即每次更新状态和属性的时候都进行组件更新。注意这个函数如果返回 false 并不会导致子组件也不更新。</p><p>这个钩子函数**一般不需要实现, **如果你的组件性能比较差或者渲染比较耗时，你可以考虑使<a href="https://reactjs.org/docs/react-api.html#reactpurecomponent">React.PureComponent</a> 重新实现该组件，PureComponent 默认实现了一个版本的 shouldComponentUpdate 会进行 state 和 props 的比较。当然如果你有自信，可以自己实现比较 nextProps 和 nextState 是否发生了改变。</p><p>该函数通常是优化性能的紧急出口，是个大招，不要轻易用，如果要用可以参考<a href="https://github.com/camsong/blog/issues/3">Immutable 详解及 React 中实践</a> .</p><hr><h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a>getSnapshotBeforeUpdate()</h4><p>该方法的触发时间为<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">update 发生的时候，在 render 之后 dom 渲染之前</span></span>返回一个值，作为 componentDidUpdate 的第三个参数。<span data-type="color" style="color:rgb(26, 26, 26)"><span data-type="background" style="background-color:rgb(255, 255, 255)">该函数与 componentDidUpdate 一起使用可以取代 componentWillUpdate 的所有功能</span></span>，比如以下是官方的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollingList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.<span class="property">list</span>.<span class="property">length</span> &lt; <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      <span class="keyword">return</span> list.<span class="property">scrollHeight</span> - list.<span class="property">scrollTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, we&#x27;ve just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don&#x27;t push the old ones out of view.</span></span><br><span class="line">    <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      list.<span class="property">scrollTop</span> = list.<span class="property">scrollHeight</span> - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.listRef&#125;</span>&gt;</span>&#123;/* ...contents... */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h4><p>该方法会在更新完成后被立即调用，你可以在这个方法中进行<strong>DOM 操作</strong>，或者<strong>做一些异步调用。</strong>这个和首次装载过程后调用 componentDidMount 是类似的，不一样的是你可能需要判断下属性是否变化了再发起网络请求，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123; <span class="comment">// 来自网络</span></span><br><span class="line">  <span class="keyword">if</span>(prevProps.<span class="property">myProps</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">myProp</span>) &#123;</span><br><span class="line">    <span class="comment">// this.props.myProp has a different value</span></span><br><span class="line">    <span class="comment">// we can perform any operations that would</span></span><br><span class="line">    <span class="comment">// need the new value and/or cause side-effects</span></span><br><span class="line">    <span class="comment">// like AJAX calls with the new value - this.props.myProp</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="卸载期间"><a href="#卸载期间" class="headerlink" title="卸载期间"></a>卸载期间</h3><p>卸载期间是指组件被从 DOM 树中移除时，调用的相关方法为:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#componentwillunmount">componentWillUnmount()</a></li></ul><h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h4><p>该方法会在组件被卸载之前被调用，你可以在这个函数中进行相关清理工作，比如删除定时器。</p><p>下面给个示例代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentWillUnmount&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除timer</span></span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerID1</span>);</span><br><span class="line">  <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timerID2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭socket</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">myWebsocket</span>.<span class="title function_">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消消息订阅...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h3><p>React16 中新增了一个生命周期函数:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch()</a></li></ul><h4 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a>componentDidCatch(error, info)</h4><p>在 react 组件中如果产生的错误没有被被捕获会被抛给上层组件，如果上层也不处理的话就会抛到顶层导致浏览器白屏错误，在 React16 中我们可以实现这个方法来捕获<strong>子组件</strong>产生的错误，然后在父组件中妥善处理，比如搞个弹层通知用户网页崩溃等。</p><p>在这个函数中请只进行错误恢复相关的处理，不要做其他流程控制方面的操作。比如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123; <span class="comment">// from react.org</span></span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="React16-中的生命周期函数变化"><a href="#React16-中的生命周期函数变化" class="headerlink" title="React16 中的生命周期函数变化"></a>React16 中的生命周期函数变化</h3><p>componentWillMount，componentWillUpdate, componentWillReceiveProps 等生命周期方法在下个主版本中会被废弃?</p><p>根据这份<a href="https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md">RFC</a>，是的，这些生命周期方法被认为是不安全的，在 React16 中被重命名为 UNSAFE_componentWillMount，UNSAFE_componentWillUpdate，UNSAFE_componentWillReceiveProps，而在更下个大版本中他们会被废弃。详见<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html"> React 16.3 版本发布公告</a>。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，以上讲的这些生命周期都有自己存在的意义，但在 React 使用过程中我们最常用到的生命周期函数是如下几个:</p><ul><li><strong>constructor</strong>: 初始化状态，进行函数绑定</li><li><strong>componentDidMount</strong>: 进行 DOM 操作，进行异步调用初始化页面</li><li><strong>componentWillReceiveProps</strong>: 根据 props 更新状态</li><li><strong>componentWillUnmount</strong>: 清理组件定时器，网络请求或者相关订阅等</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://www.mrfront.com/2016/05/03/react-components-study-states/">http://www.mrfront.com/2016/05/03/react-components-study-states/</a></li><li><a href="https://github.com/superman66/Front-End-Blog/issues/2">https://github.com/superman66/Front-End-Blog/issues/2</a></li><li><a href="https://juejin.im/entry/587de1b32f301e0057a28897">https://juejin.im/entry/587de1b32f301e0057a28897</a></li><li><a href="https://github.com/JasonBoy/javascript/tree/master/react">Airbnb React&#x2F;JSX 编码规范</a></li><li><a href="https://segmentfault.com/a/1190000013354181">理解 React 组件的生命周期</a></li><li><a href="https://medium.com/@baphemot/understanding-reactjs-component-life-cycle-823a640b3e8d">Understanding React — Component life-cycle</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085">React Fiber 是什么</a></li><li><a href="https://reactjs.org/docs/react-component.html">react component</a></li><li><a href="https://juejin.im/post/5abf4a09f265da237719899d">讲讲今后 React 异步渲染带来的生命周期变化</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/React/">React</category>
      
      
      <comments>https://kinneyyan.github.io/2019-01-07/React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%BD%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Class 文件结构&amp;字节码指令-《深入理解Java虚拟机》读书笔记</title>
      <link>https://kinneyyan.github.io/2018-08-29/Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&amp;%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <guid>https://kinneyyan.github.io/2018-08-29/Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&amp;%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 29 Aug 2018 07:57:00 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;Class-类文件的结构-6-3&quot;&gt;&lt;a href=&quot;#Class-类文件的结构-6-3&quot; class=&quot;headerlink&quot; title=&quot;Class 类文件的结构 (#6.3)&quot;&gt;&lt;/a&gt;Class 类文件的结构 (#6.3)&lt;/h4&gt;&lt;p&gt;Class 文件</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="Class-类文件的结构-6-3"><a href="#Class-类文件的结构-6-3" class="headerlink" title="Class 类文件的结构 (#6.3)"></a>Class 类文件的结构 (#6.3)</h4><p>Class 文件是一组<strong>以 8 位字节为基础单位的二进制流</strong>，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个 8 位字节进行存储。</p><p>Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>，后面的解析都要以这两种数据类型为基础。</p><p><strong>无符号数</strong>属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</p><p><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。</p><p><img src="https://s1.ax1x.com/2018/08/29/PXSBVI.jpg" alt="Class文件格式"></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>魔数与 Class 文件的版本</td><td>头 4 个字节称为魔数（Magic Number），作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件；紧接着魔数的 4 个字节存储的是<strong>Class 文件的版本号</strong>：第 5 和第 6 个字节是<strong>次版本号（Minor Version）</strong>，第 7 和第 8 个字节是**主版本号（Major Version）</td></tr><tr><td>常量池</td><td>可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。</td></tr><tr><td></td><td><strong>常量池</strong>中主要存放两大类常量：<strong>字面量（Literal）</strong>和<strong>符号引用（Symbolic References）</strong>。字面量比较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符</td></tr><tr><td>访问标志</td><td>紧接着的两个字节代表<strong>访问标志（access_flags）</strong>，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等</td></tr><tr><td>类索引、父类索引与接口索引集合</td><td><strong>类索引（this_class）</strong>和<strong>父类索引（super_class）</strong>都是一个 u2 类型的数据，而<strong>接口索引集合（interfaces）</strong>是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系</td></tr><tr><td>字段表集合</td><td><strong>字段表（field_info）</strong>用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</td></tr><tr><td>方法表集合</td><td>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</td></tr><tr><td></td><td>方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</td></tr><tr><td>属性表集合</td><td>在 Class 文件、字段表、方法表都可以携带自己的<strong>属性表（attribute_info）</strong>集合，以用于描述某些场景专有的信息。</td></tr><tr><td></td><td>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。这个处理只对实例方法有效。</td></tr></tbody></table><h4 id="字节码指令简介-6-4"><a href="#字节码指令简介-6-4" class="headerlink" title="字节码指令简介 (#6.4)"></a>字节码指令简介 (#6.4)</h4><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p><p>如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效地工作：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do</span>&#123;</span><br><span class="line">自动计算<span class="built_in">PC</span>寄存器的值加<span class="number">1</span>；</span><br><span class="line">根据<span class="built_in">PC</span>寄存器的指示位置，从字节码流中取出操作码；</span><br><span class="line"><span class="symbol">if</span>（字节码存在操作数）从字节码流中取出操作数；</span><br><span class="line">执行操作码所定义的操作；</span><br><span class="line">&#125;<span class="meta">while</span>（字节码流长度＞<span class="number">0</span>）；</span><br></pre></td></tr></table></figure><h5 id="字节码与数据类型-6-4-1"><a href="#字节码与数据类型-6-4-1" class="headerlink" title="字节码与数据类型 (#6.4.1)"></a>字节码与数据类型 (#6.4.1)</h5><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long,s 代表 short,b 代表 byte,c 代表 char,f 代表 float,d 代表 double,a 代表 reference。也有一些指令的助记符中没有明确地指明操作类型的字母，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令 goto 则是与数据类型无关的。</p><p>Java 虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会故意被设计成非完全独立的（Java 虚拟机规范中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><p>表 6-31 列举了 Java 虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换 opcode 列的指令模板中的 T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。例如，load 指令有操作 int 类型的 iload，但是没有操作 byte 类型的同类指令。</p><p>从表 6-31 中可以看出，大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，<strong>实际上都是使用相应的 int 类型作为运算类型（Computational Type）</strong>。</p><p><img src="https://s1.ax1x.com/2018/08/29/PX9it0.jpg" alt="Java虚拟机指令集所支持的数据类型"><br><img src="https://s1.ax1x.com/2018/08/29/PX9FhV.jpg" alt="Java虚拟机指令集所支持的数据类型"></p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>加载和存储指令</td><td>用于将数据在栈帧中的局部变量表和操作数栈（见第 2 章关于内存区域的介绍）之间来回传输</td></tr><tr><td>运算指令</td><td>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</td></tr><tr><td>类型转换指令</td><td>可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</td></tr><tr><td>对象创建与访问指令</td><td>虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在第 7 章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素</td></tr><tr><td>操作数栈管理指令</td><td>如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令</td></tr><tr><td>控制转移指令</td><td>可以让 Java 虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改 PC 寄存器的值</td></tr><tr><td>方法调用和返回指令</td><td>invokevirtual, invokeinterface, invokespecial, invokestatic, invokedynamic</td></tr><tr><td>异常处理指令</td><td>在 Java 程序中显式抛出异常的操作（throw 语句）都由 athrow 指令来实现，除了用 throw 语句显式抛出异常情况之外，Java 虚拟机规范还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出</td></tr><tr><td>同步指令</td><td>Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Java/">Java</category>
      
      
      <comments>https://kinneyyan.github.io/2018-08-29/Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&amp;%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java 内存区&amp;GC_《深入理解Java虚拟机》读书笔记</title>
      <link>https://kinneyyan.github.io/2018-08-28/Java%20%E5%86%85%E5%AD%98%E5%8C%BA&amp;GC_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <guid>https://kinneyyan.github.io/2018-08-28/Java%20%E5%86%85%E5%AD%98%E5%8C%BA&amp;GC_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 28 Aug 2018 07:55:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Java-内存区域与内存溢出异常-2&quot;&gt;&lt;a href=&quot;#Java-内存区域与内存溢出异常-2&quot; class=&quot;headerlink&quot; title=&quot;Java 内存区域与内存溢出异常 (#2)&quot;&gt;&lt;/a&gt;Java 内存区域与内存溢出异常 (#2)&lt;/h3&gt;&lt;h4</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Java-内存区域与内存溢出异常-2"><a href="#Java-内存区域与内存溢出异常-2" class="headerlink" title="Java 内存区域与内存溢出异常 (#2)"></a>Java 内存区域与内存溢出异常 (#2)</h3><h4 id="运行时数据区域-2-2"><a href="#运行时数据区域-2-2" class="headerlink" title="运行时数据区域 (#2.2)"></a>运行时数据区域 (#2.2)</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java 虚拟机规范（Java SE 7 版）》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示：<img src="https://guolei1130.github.io/images/jvm/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="Java内存区域"></p><h4 id="程序计数器-2-2-1"><a href="#程序计数器-2-2-1" class="headerlink" title="程序计数器 (#2.2.1)"></a>程序计数器 (#2.2.1)</h4><p><strong>程序计数器</strong>（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<strong>“线程私有”的内存</strong>。</p><h4 id="Java-虚拟机栈-2-2-2"><a href="#Java-虚拟机栈-2-2-2" class="headerlink" title="Java 虚拟机栈 (#2.2.2)"></a>Java 虚拟机栈 (#2.2.2)</h4><p><strong>Java 虚拟机栈</strong>（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p><strong>局部变量表所需的内存空间</strong>在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h4 id="Java-堆-2-2-4"><a href="#Java-堆-2-2-4" class="headerlink" title="Java 堆 (#2.2.4)"></a>Java 堆 (#2.2.4)</h4><p><strong>Java 堆</strong>（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域。</p><p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，<u>栈上分配</u>、<u>标量替换</u>优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><h4 id="方法区-2-2-5"><a href="#方法区-2-2-5" class="headerlink" title="方法区 (# 2.2.5)"></a>方法区 (# 2.2.5)</h4><p><strong>方法区</strong>（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p><h4 id="运行时常量池-2-2-6"><a href="#运行时常量池-2-2-6" class="headerlink" title="运行时常量池 (#2.2.6)"></a>运行时常量池 (#2.2.6)</h4><p><strong>运行时常量池</strong>（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h4 id="HotSpot-虚拟机对象探秘-2-3"><a href="#HotSpot-虚拟机对象探秘-2-3" class="headerlink" title="HotSpot 虚拟机对象探秘 (#2.3)"></a>HotSpot 虚拟机对象探秘 (#2.3)</h4><h4 id="对象的创建-2-3-1"><a href="#对象的创建-2-3-1" class="headerlink" title="对象的创建 (#2.3.1)"></a>对象的创建 (#2.3.1)</h4><p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。</p><p>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。</p><h4 id="对象的内存布局-2-3-2"><a href="#对象的内存布局-2-3-2" class="headerlink" title="对象的内存布局 (#2.3.2)"></a>对象的内存布局 (#2.3.2)</h4><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h4 id="对象的访问定位-2-3-3"><a href="#对象的访问定位-2-3-3" class="headerlink" title="对象的访问定位 (#2.3.3)"></a>对象的访问定位 (#2.3.3)</h4><p>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><ol><li>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li><li>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</li></ol><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><h3 id="垃圾收集器与内存分配策略-3"><a href="#垃圾收集器与内存分配策略-3" class="headerlink" title="垃圾收集器与内存分配策略 (#3)"></a>垃圾收集器与内存分配策略 (#3)</h3><h4 id="引用计数算法-3-2-1"><a href="#引用计数算法-3-2-1" class="headerlink" title="引用计数算法 (#3.2.1)"></a>引用计数算法 (#3.2.1)</h4><ul><li><p>定义：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。</p></li><li><p>缺点：很难解决对象之间相互循环引用的问题。</p></li></ul><h4 id="可达性分析算法-3-2-2"><a href="#可达性分析算法-3-2-2" class="headerlink" title="可达性分析算法 (#3.2.2)"></a>可达性分析算法 (#3.2.2)</h4><ul><li>定义：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。</li></ul><p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</p><h4 id="再谈引用-3-2-3"><a href="#再谈引用-3-2-3" class="headerlink" title="再谈引用 (#3.2.3)"></a>再谈引用 (#3.2.3)</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。</p><p><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似“Object obj&#x3D;new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。</p><p><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</p><p><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</p><h4 id="生存还是死亡-3-2-4"><a href="#生存还是死亡-3-2-4" class="headerlink" title="生存还是死亡 (#3.2.4)"></a>生存还是死亡 (#3.2.4)</h4><p>关于对象死亡时<strong>finalize（）</strong>方法建议尽量避免使用它，因为它不是 C&#x2F;C++中的析构函数，而是 Java 刚诞生时为了使 C&#x2F;C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize（）能做的所有工作，使用 try-finally 或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉 Java 语言中有这个方法的存在。</p><h4 id="回收方法区-3-2-5"><a href="#回收方法区-3-2-5" class="headerlink" title="回收方法区 (#3.2.5)"></a>回收方法区 (#3.2.5)</h4><p>很多人认为方法区（或者 HotSpot 虚拟机中的永久代）是没有垃圾收集的，Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收 70%～ 95%的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><h4 id="垃圾收集算法-3-3"><a href="#垃圾收集算法-3-3" class="headerlink" title="垃圾收集算法 (#3.3)"></a>垃圾收集算法 (#3.3)</h4><h4 id="标记-清除算法-3-3-1"><a href="#标记-清除算法-3-3-1" class="headerlink" title="标记-清除算法 (#3.3.1)"></a>标记-清除算法 (#3.3.1)</h4><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p><h4 id="复制算法-3-3-2"><a href="#复制算法-3-3-2" class="headerlink" title="复制算法 (#3.3.2)"></a>复制算法 (#3.3.2)</h4><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><h4 id="标记-整理算法-3-3-3"><a href="#标记-整理算法-3-3-3" class="headerlink" title="标记-整理算法 (#3.3.3)"></a>标记-整理算法 (#3.3.3)</h4><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h4 id="分代收集算法-3-3-4"><a href="#分代收集算法-3-3-4" class="headerlink" title="分代收集算法 (#3.3.4)"></a>分代收集算法 (#3.3.4)</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<u>复制算法</u>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“<u>标记—清理</u>”或者“<u>标记—整理</u>”算法来进行回收。</p><h4 id="内存分配与回收策略-3-6"><a href="#内存分配与回收策略-3-6" class="headerlink" title="内存分配与回收策略 (#3.6)"></a>内存分配与回收策略 (#3.6)</h4><h4 id="对象优先在-Eden-分配-3-6-1"><a href="#对象优先在-Eden-分配-3-6-1" class="headerlink" title="对象优先在 Eden 分配 (#3.6.1)"></a>对象优先在 Eden 分配 (#3.6.1)</h4><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p><em>Minor GC 和 Full GC 有什么不一样吗？</em></p><p><strong>新生代 GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p><p><strong>老年代 GC（Major GC&#x2F;Full GC）</strong>：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</p><h4 id="大对象直接进入老年代-3-6-2"><a href="#大对象直接进入老年代-3-6-2" class="headerlink" title="大对象直接进入老年代 (#3.6.2)"></a>大对象直接进入老年代 (#3.6.2)</h4><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。</p><h4 id="长期存活的对象将进入老年代-3-6-3"><a href="#长期存活的对象将进入老年代-3-6-3" class="headerlink" title="长期存活的对象将进入老年代 (#3.6.3 　)"></a>长期存活的对象将进入老年代 (#3.6.3 　)</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold 设置。</p><h4 id="动态对象年龄判定-3-6-4"><a href="#动态对象年龄判定-3-6-4" class="headerlink" title="动态对象年龄判定 (#3.6.4)"></a>动态对象年龄判定 (#3.6.4)</h4><p>虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="空间分配担保-3-6-5"><a href="#空间分配担保-3-6-5" class="headerlink" title="空间分配担保 (#3.6.5)"></a>空间分配担保 (#3.6.5)</h4><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。</p><h3 id="虚拟机性能监控与故障处理工具-4"><a href="#虚拟机性能监控与故障处理工具-4" class="headerlink" title="虚拟机性能监控与故障处理工具 (#4)"></a>虚拟机性能监控与故障处理工具 (#4)</h3><h4 id="JDK-的可视化工具-4-3"><a href="#JDK-的可视化工具-4-3" class="headerlink" title="JDK 的可视化工具 (#4.3)"></a>JDK 的可视化工具 (#4.3)</h4><p>JDK 中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole 和 VisualVM。</p><h4 id="VisualVM：多合一故障处理工具-4-3-2"><a href="#VisualVM：多合一故障处理工具-4-3-2" class="headerlink" title="VisualVM：多合一故障处理工具 (#4.3.2)"></a>VisualVM：多合一故障处理工具 (#4.3.2)</h4><p>VisualVM 可以做到： 显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。 监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。 dump 以及分析堆转储快照（jmap、jhat）。 方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。 离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。 其他 plugins 的无限的可能性……</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Java/">Java</category>
      
      
      <comments>https://kinneyyan.github.io/2018-08-28/Java%20%E5%86%85%E5%AD%98%E5%8C%BA&amp;GC_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git submodule 学习笔记</title>
      <link>https://kinneyyan.github.io/2017-12-26/Git%20submodule%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>https://kinneyyan.github.io/2017-12-26/Git%20submodule%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 26 Dec 2017 10:04:16 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;参考自 Git 官方文档：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97&quot;&gt;7.11 Git 工具 - 子模块&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>参考自 Git 官方文档：<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">7.11 Git 工具 - 子模块</a></p></blockquote><h2 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h2><p><strong>将一个已存在的 Git 仓库添加为正在工作的仓库的子模块</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add &lt;子模块仓库地址&gt;</span></span><br></pre></td></tr></table></figure><h2 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h2><p>普通的<code>git clone</code>命令默认会包含子模块的目录，但其中还没有任何文件，需要执行 2 个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化本地配置文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule init</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从该项目中抓取所有数据并检出父项目中列出的合适的提交</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update</span></span><br></pre></td></tr></table></figure><p>更简单的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会自动初始化并更新仓库中的每一个子模块</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --recursive &lt;包含子模块的仓库地址&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h2><h3 id="拉取上游修改"><a href="#拉取上游修改" class="headerlink" title="拉取上游修改"></a>拉取上游修改</h3><ol><li>进入子模块目录执行：<code>git fetch</code>与<code>git merge</code></li><li>直接在主项目目录下执行：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Git 默认会尝试更新所有子模块，所以如果有很多子模块的话，你可以传递想要更新的子模块的名字</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update --remote &lt;--rebase&gt;&lt;--merge&gt;</span></span><br></pre></td></tr></table></figure><p>如果你忘记  –rebase  或  –merge，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态<br>​<br>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基  origin&#x2F;stable（或任何一个你想要的远程分支）就行了。</p><h3 id="修改子模块的默认分支"><a href="#修改子模块的默认分支" class="headerlink" title="修改子模块的默认分支"></a>修改子模块的默认分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如要修改子模块的默认分支到develop上</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config -f .gitmodules submodule.子模块名.branch develop</span></span><br></pre></td></tr></table></figure><p>其实就是修改了<code>.gitmodule</code>这个文件。提交以后，当其他人执行<code>git submodule update --remote</code>后，就会从子模块拉取 develop 这个新分支（但是还得手动进入子模块目录后切到 develop 分支- -）</p><h3 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h3><p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。 那些改动只存在于我们本地的拷贝中。</p><p>所以我们可以：</p><p>1. 让 Git 在推送到主项目前检查所有子模块是否已推送，如果任何提交的子模块改动没有推送那么 “check” 选项会直接使  push  操作失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --recurse-submodules=check</span></span><br></pre></td></tr></table></figure><p>2. 让 Git 进入到每个子模块中然后在推送主项目前推送。如果那个子模块因为某些原因推送失败，主项目也会推送失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --recurse-submodules=on-demand</span></span><br></pre></td></tr></table></figure><h3 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h3><h2 id="子模块技巧"><a href="#子模块技巧" class="headerlink" title="子模块技巧"></a>子模块技巧</h2><h3 id="子模块遍历"><a href="#子模块遍历" class="headerlink" title="子模块遍历"></a>子模块遍历</h3><p>有一个  foreach  子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule foreach <span class="string">&#x27;git pull&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h3><ul><li>问题一</li></ul><p>在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。</p><ul><li>解决方案</li></ul><p>如果你移除它然后切换回有那个子模块的分支，需要运行  submodule update –init  来重新建立和填充。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -fdx</span></span><br><span class="line">Removing CryptoLibrary/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout add-crypto</span></span><br><span class="line">Switched to branch &#x27;add-crypto&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> CryptoLibrary/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update --init</span></span><br><span class="line">Submodule path &#x27;CryptoLibrary&#x27;: checked out &#x27;b8dda6aa182ea4464f3f3264b11e0268545172af&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> CryptoLibrary/</span></span><br><span class="line">Makefileincludesscriptssrc</span><br></pre></td></tr></table></figure><ul><li>问题二</li></ul><p>如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行  submodule add，Git 会朝你大喊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -Rf CryptoLibrary/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add https://github.com/chaconinc/CryptoLibrary</span></span><br><span class="line">&#x27;CryptoLibrary&#x27; already exists in the index</span><br></pre></td></tr></table></figure><ul><li>解决方案</li></ul><p>你必须要先取消暂存  CryptoLibrary  目录。 然后才可以添加子模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -r CryptoLibrary</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add https://github.com/chaconinc/CryptoLibrary</span></span><br><span class="line">Cloning into &#x27;CryptoLibrary&#x27;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Git/">Git</category>
      
      
      <comments>https://kinneyyan.github.io/2017-12-26/Git%20submodule%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《算法图解》读书笔记</title>
      <link>https://kinneyyan.github.io/2017-11-02/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <guid>https://kinneyyan.github.io/2017-11-02/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Thu, 02 Nov 2017 08:57:25 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;1-2-二分查找&quot;&gt;&lt;a href=&quot;#1-2-二分查找&quot; class=&quot;headerlink&quot; title=&quot;1.2 二分查找&quot;&gt;&lt;/a&gt;1.2 二分查找&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.2.1 更佳的查找方式&lt;br&gt;一般而言，对于包含 n 个元素的列表，用二分查</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h4><ul><li>1.2.1 更佳的查找方式<br>一般而言，对于包含 n 个元素的列表，用二分查找最多需要 log2 n 步，而简单查找最多需要 n 步。</li></ul><h4 id="1-3-大-O-表示法"><a href="#1-3-大-O-表示法" class="headerlink" title="1.3 大 O 表示法"></a>1.3 大 O 表示法</h4><ul><li>1.3.1 算法的运行时间以不同的速度增加<br>仅知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大 O 表示法的用武之地。</li></ul><h4 id="3-1-递归"><a href="#3-1-递归" class="headerlink" title="3.1 递归"></a>3.1 递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">look_for_key</span>(<span class="params">box</span>):</span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> box:</span><br><span class="line">    <span class="keyword">if</span> item.is_a_box():</span><br><span class="line">      look_for_key(item)  ←------递归！</span><br><span class="line">    <span class="keyword">elif</span> item.is_a_key():</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;found the key!&quot;</span></span><br></pre></td></tr></table></figure><p>这两种方法的作用相同，但在我看来，第二种方法更清晰。递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。我很喜欢 Leigh Caldwell 在 Stack Overflow 上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”</p><h4 id="第-4-章-快速排序"><a href="#第-4-章-快速排序" class="headerlink" title="第 4 章 快速排序"></a>第 4 章 快速排序</h4><p>分而治之 （divide and conquer，D&amp;C）——一种著名的递归式问题解决方法</p><h4 id="4-3-再谈大-O-表示法"><a href="#4-3-再谈大-O-表示法" class="headerlink" title="4.3 再谈大 O 表示法"></a>4.3 再谈大 O 表示法</h4><p>快速排序的独特之处在于，其速度取决于选择的基准值。</p><ul><li>4.3.1 比较合并排序和快速排序<br>在大 O 表示法 O (n )中，n 实际上指的是这样的。<br>c 是算法所需的固定时间量，被称为常量 。例如，print<em>items 所需的时间可能是 10 毫秒 * n ，而 print</em>items2 所需的时间为 1 秒 * n 。</li></ul><h4 id="5-1-散列函数"><a href="#5-1-散列函数" class="headerlink" title="5.1 散列函数"></a>5.1 散列函数</h4><p>散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。</p><h4 id="5-3-冲突"><a href="#5-3-冲突" class="headerlink" title="5.3 冲突"></a>5.3 冲突</h4><p>散列函数很重要 。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。</p><h4 id="7-1-使用狄克斯特拉算法"><a href="#7-1-使用狄克斯特拉算法" class="headerlink" title="7.1 使用狄克斯特拉算法"></a>7.1 使用狄克斯特拉算法</h4><p>狄克斯特拉算法找出的是总权重最小的路径</p><h4 id="7-2-术语"><a href="#7-2-术语" class="headerlink" title="7.2 术语"></a>7.2 术语</h4><p>要计算非加权图中的最短路径，可使用广度优先搜索 。要计算加权图中的最短路径，可使用狄克斯特拉算法<br>在无向图中，每条边都是一个环。狄克斯特拉算法只适用于有向无环图 （directed acyclic graph，DAG）。</p><h4 id="7-3-换钢琴"><a href="#7-3-换钢琴" class="headerlink" title="7.3 换钢琴"></a>7.3 换钢琴</h4><p>狄克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径 ！</p><h4 id="8-4-NP-完全问题"><a href="#8-4-NP-完全问题" class="headerlink" title="8.4 NP 完全问题"></a>8.4 NP 完全问题</h4><ul><li>8.4.2 如何识别 NP 完全问题<br>NP 完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。</li></ul><h4 id="10-2-创建推荐系统"><a href="#10-2-创建推荐系统" class="headerlink" title="10.2 创建推荐系统"></a>10.2 创建推荐系统</h4><ul><li>10.2.3 挑选合适的特征<br>在挑选合适的特征方面，没有放之四海皆准的法则，你必须考虑到各种需要考虑的因素。</li></ul><h4 id="11-1-树"><a href="#11-1-树" class="headerlink" title="11.1 树"></a>11.1 树</h4><p>二叉查找树类似于下面这样。对于其中的每个节点，左子节点的值都比它小 ，而右子节点的值都比它大 。<br>在二叉查找树中查找节点时，平均运行时间为 O (log n )，但在最糟的情况下所需时间为 O (n )；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有 O (log n )，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。<br>B 树是一种特殊的二叉树，数据库常用它来存储数据。</p><h4 id="11-5-MapReduce"><a href="#11-5-MapReduce" class="headerlink" title="11.5 MapReduce"></a>11.5 MapReduce</h4><ul><li>11.5.1 分布式算法为何很有用<br>MapReduce 是一种流行的分布式算法，你可通过流行的开源工具 Apache Hadoop 来使用它。</li><li>11.5.3 归并函数<br>映射是将一个数组转换为另一个数组。<br>归并是将一个数组转换为一个元素。</li></ul>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category>
      
      
      
      <comments>https://kinneyyan.github.io/2017-11-02/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Data Binding学习笔记——Attribute Setters</title>
      <link>https://kinneyyan.github.io/2017-08-24/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Attribute-Setters/</link>
      <guid>https://kinneyyan.github.io/2017-08-24/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Attribute-Setters/</guid>
      <pubDate>Thu, 24 Aug 2017 06:16:53 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;这是 Data Binding 学习笔记的最后一篇，我觉得 &lt;code&gt;Attribute Setters&lt;/code&gt; 的特性大大提高了 Data Binding 库的可用性、拓展性。以下主要翻译自官方文档。&lt;/p&gt;
&lt;h2 id=&quot;Attribute-Setters（属</description>
        
      
      
      
      <content:encoded><![CDATA[<p>这是 Data Binding 学习笔记的最后一篇，我觉得 <code>Attribute Setters</code> 的特性大大提高了 Data Binding 库的可用性、拓展性。以下主要翻译自官方文档。</p><h2 id="Attribute-Setters（属性-Setter）"><a href="#Attribute-Setters（属性-Setter）" class="headerlink" title="Attribute Setters（属性 Setter）"></a>Attribute Setters（属性 Setter）</h2><p>当一个 View 绑定的数据发生变动时，自动生成的 binding 类其实会根据 xml 中的 binding 表达式来调用 View 对应属性的 <code>setter</code> 函数。Data binding 框架内置了几种自定义赋值的方法。</p><h3 id="Automatic-Setters"><a href="#Automatic-Setters" class="headerlink" title="Automatic Setters"></a>Automatic Setters</h3><p>如果 UI 控件内的一个 attribute 叫 xxx，data binding 会尝试寻找对应的 setXXX 函数。</p><p>比如，针对一个与 TextView 的 <code>android:text</code> 绑定的表达式，data binding 会自动寻找 <code>setText(CharSequence)</code> 函数；如果表达式返回值为 int 类型，则会寻找 <code>setText(int)</code> 函数。</p><h3 id="Renamed-Setters"><a href="#Renamed-Setters" class="headerlink" title="Renamed Setters"></a>Renamed Setters</h3><p>如果 attribute 的命名与 <code>setter</code>函数不对应，我们可以用 <code>BindingMethods</code> 注解来将 attribute 与 <code>setter</code> 绑定到一起。举个例子，<code>android:tint</code> 属性可以这样与 <code>setImageTintList(ColorStateList)</code> 绑定，而不是 <code>setTint</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingMethods(&#123;</span></span><br><span class="line"><span class="meta">       @BindingMethod(type = &quot;android.widget.ImageView&quot;,</span></span><br><span class="line"><span class="meta">                      attribute = &quot;android:tint&quot;,</span></span><br><span class="line"><span class="meta">                      method = &quot;setImageTintList&quot;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>Android 框架中的 setter 重命名已经在库中实现了，开发者只需要专注于自己的 setter。</p><h3 id="Custom-Setters"><a href="#Custom-Setters" class="headerlink" title="Custom Setters"></a>Custom Setters</h3><p>一些属性需要自定义 setter 逻辑。例如，目前没有与 <code>android:paddingLeft</code> 对应的 setter，只有一个 <code>setPadding(left, top, right, bottom)</code> 函数。结合静态 binding adapter 函数与 <a href="http://developer.android.com/reference/android/databinding/BindingAdapter.html"><code>BindingAdapter</code></a> 注解可以让开发者自定义属性 setter。</p><p>Android 属性已经内置一些 BindingAdapter。例如，这是一个 <code>paddingLeft</code> 的自定义 setter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:paddingLeft&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setPaddingLeft</span><span class="params">(View view, <span class="type">int</span> padding)</span> &#123;</span><br><span class="line">   view.setPadding(padding,</span><br><span class="line">                   view.getPaddingTop(),</span><br><span class="line">                   view.getPaddingRight(),</span><br><span class="line">                   view.getPaddingBottom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Binding adapter 在其他自定义类型上也很好用。举个例子，一个 loader 可以在非主线程加载图片。</p><p>当存在冲突时，开发者创建的 binding adapter 会覆盖 data binding 的默认 adapter。</p><p>你也可以创建多个参数的 adapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BindingAdapter(&#123;<span class="string">&quot;bind:imageUrl&quot;</span>, <span class="string">&quot;bind:error&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> &#123;</span><br><span class="line">   Picasso.with(view.getContext()).load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">app:imageUrl</span>=<span class="string">“@&#123;venue.imageUrl&#125;”</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:error</span>=<span class="string">“@&#123;@drawable/venueError&#125;”/</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <strong>imageUrl</strong> 与 <strong>error</strong> 存在时这个 adapter 会被调用。imageUrl 是一个 String，error 是一个 Drawable。</p><ul><li>在匹配时自定义命名空间会被忽略</li><li>你可以为 android 命名空间编写 adapter</li></ul><p>Binding adapter 方法可以获取旧的赋值。只需要将旧值放置在前，新值放置在后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:paddingLeft&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setPaddingLeft</span><span class="params">(View view, <span class="type">int</span> oldPadding, <span class="type">int</span> newPadding)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (oldPadding != newPadding) &#123;</span><br><span class="line">       view.setPadding(newPadding,</span><br><span class="line">                       view.getPaddingTop(),</span><br><span class="line">                       view.getPaddingRight(),</span><br><span class="line">                       view.getPaddingBottom());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件 handler 仅可用于只拥有一个抽象方法的接口或者抽象类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:onLayoutChange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setOnLayoutChangeListener</span><span class="params">(View view, View.OnLayoutChangeListener oldValue,</span></span><br><span class="line"><span class="params">       View.OnLayoutChangeListener newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnLayoutChangeListener(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnLayoutChangeListener(newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 listener 内置多个函数时，必须分割成多个 listener。例如，<a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html"><code>View.OnAttachStateChangeListener</code></a> 内置两个函数：<a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html#onViewAttachedToWindow(android.view.View)"><code>onViewAttachedToWindow()</code></a> 与 <a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html#onViewDetachedFromWindow(android.view.View)"><code>onViewDetachedFromWindow()</code></a>。在这里必须为两个不同的属性创建不同的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnViewDetachedFromWindow</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onViewDetachedFromWindow</span><span class="params">(View v)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnViewAttachedToWindow</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onViewAttachedToWindow</span><span class="params">(View v)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为改变一个 listener 会影响到另外一个，我们必须编写三个不同的 adapter，包括修改一个属性的，和修改两个属性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(&quot;android:onViewAttachedToWindow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">(View view, OnViewAttachedToWindow attached)</span> &#123;</span><br><span class="line">    setListener(view, <span class="literal">null</span>, attached);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BindingAdapter(&quot;android:onViewDetachedFromWindow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">(View view, OnViewDetachedFromWindow detached)</span> &#123;</span><br><span class="line">    setListener(view, detached, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BindingAdapter(&#123;&quot;android:onViewDetachedFromWindow&quot;, &quot;android:onViewAttachedToWindow&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">(View view, <span class="keyword">final</span> OnViewDetachedFromWindow detach,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> OnViewAttachedToWindow attach)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        <span class="keyword">final</span> OnAttachStateChangeListener newListener;</span><br><span class="line">        <span class="keyword">if</span> (detach == <span class="literal">null</span> &amp;&amp; attach == <span class="literal">null</span>) &#123;</span><br><span class="line">            newListener = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newListener = <span class="keyword">new</span> <span class="title class_">OnAttachStateChangeListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewAttachedToWindow</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (attach != <span class="literal">null</span>) &#123;</span><br><span class="line">                        attach.onViewAttachedToWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewDetachedFromWindow</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (detach != <span class="literal">null</span>) &#123;</span><br><span class="line">                        detach.onViewDetachedFromWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">OnAttachStateChangeListener</span> <span class="variable">oldListener</span> <span class="operator">=</span> ListenerUtil.trackListener(view,</span><br><span class="line">                newListener, R.id.onAttachStateChangeListener);</span><br><span class="line">        <span class="keyword">if</span> (oldListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子比普通情况下复杂，因为 View 是 add&#x2F;remove <a href="http://developer.android.com/reference/android/view/View.OnAttachStateChangeListener.html"><code>View.OnAttachStateChangeListener</code></a> 而不是 set。<code>android.databinding.adapters.ListenerUtil</code> 可以用来辅助跟踪旧的 listener 并移除它。</p><p>对应 <a href="http://developer.android.com/reference/android/view/View.html#addOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener)"><code>addOnAttachStateChangeListener(View.OnAttachStateChangeListener)</code></a> 支持的 api 版本，通过向 <code>OnViewDetachedFromWindow</code> 和 <code>OnViewAttachedToWindow</code> 添加 <code>@TargetApi(VERSION_CODES.HONEYCHOMB_MR1)</code> 注解，data binding 代码生成器会知道这些 listener 只会在 Honeycomb MR1 或更新的设备上使用。</p><p>（完）</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Android/">Android</category>
      
      
      <comments>https://kinneyyan.github.io/2017-08-24/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Attribute-Setters/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Data Binding学习笔记——Data Objects</title>
      <link>https://kinneyyan.github.io/2017-08-21/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Data-Objects/</link>
      <guid>https://kinneyyan.github.io/2017-08-21/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Data-Objects/</guid>
      <pubDate>Mon, 21 Aug 2017 06:36:30 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;关于 Data Binding 的基本使用在上一篇文章中已经做了总结，接下来会着重介绍下 Data Binding 库中个人认为最重要的两个特性：&lt;strong&gt;Data Objects&lt;/strong&gt;与&lt;strong&gt;Attribute Setters&lt;/strong&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>关于 Data Binding 的基本使用在上一篇文章中已经做了总结，接下来会着重介绍下 Data Binding 库中个人认为最重要的两个特性：<strong>Data Objects</strong>与<strong>Attribute Setters</strong>。前者是真正能让我们实现<code>数据-UI</code>双向绑定的关键；后者则为我们提供了自定义 UI 控件数据绑定的可能性。</p><p>当然，至于 Data Binding 其他的特性诸如<code>自定义Binding Class命名</code>、<code>Views with IDs</code>（此特性可以完全取代<code>Butterknife</code>啦）等，查阅<a href="https://developer.android.google.cn/topic/libraries/data-binding">官方文档</a>可以了。</p><h2 id="Data-Objects（数据对象）"><a href="#Data-Objects（数据对象）" class="headerlink" title="Data Objects（数据对象）"></a>Data Objects（数据对象）</h2><p>之前介绍的基本使用中，我们定义的 model 类对象虽然能够绑定对应的 UI 并显示数据，但是修改了对象的属性并不会更新 UI。为此，Data Binding 提供了三种不同的数据变动通知机制： <code>observable objects</code> 、<code>observable fields</code> 和 <code>observable collection</code> 。</p><p>当以上的 observable 对象绑定在 UI 上，数据发生变化时，UI 就会同步更新。</p><h3 id="1-observable-objects"><a href="#1-observable-objects" class="headerlink" title="1. observable objects"></a>1. observable objects</h3><p>此种方法其实就是让我们定义的 model 类继承一个基类 <code>BaseObservable</code> ，这个类是 <code>Observable</code> （Data Binding 中的）接口的实现类，内部也就是基于观察者模式的一套添加&#x2F;移除 listener 的机制。<code>BaseObservable</code> 帮我们实现了 listener 的注册，但是我们需要在 <code>getter</code> 使用 <code>Bindable</code> 注解，并在 <code>setter</code> 中调用方法去发通知。例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">BaseObservable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String firstName;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">   <span class="meta">@Bindable</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Bindable</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">       notifyPropertyChanged(BR.firstName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">       notifyPropertyChanged(BR.lastName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bindable</code> 注解会在编译时在 BR 类内生成一个元素（比如上面代码中的 <code>BR.firstName</code> ）。</p><p>个人总结：如果一个 model 类的属性有很多，或者是想在原有项目中引入 <code>Data Binding</code> 的话，使用此方法的编写和改动的工作量还是有点繁琐。（不知道有没有开发者已经提供了一键生成的 AS 插件 😏）</p><h3 id="2-observable-fields"><a href="#2-observable-fields" class="headerlink" title="2. observable fields"></a>2. observable fields</h3><p>我们还可以使用 <code>ObservableField</code> 及它的派生比如 <code>ObservableInt</code> 、 <code>ObservableBoolean</code> 等作为 model 的数据类型。我们只要在数据类中创建一个 public final 域即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName =</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">ObservableField</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName =</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">ObservableField</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">ObservableInt</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObservableInt</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后要存取数据的话，只需要使用 <code>ObservableField</code> 中的 <code>get</code> 、 <code>set</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> user.age.get();</span><br></pre></td></tr></table></figure><p>个人总结：相比第一种方法，代码编写更方便省时，缺点就是：1、数据类的 <code>field</code> 如果很多的话，写起来还是麻烦；2、一般我们都会用到 <code>FastJson</code> 配合 <code>Retrofit</code> 来做 API 请求，结果直接返回给我们对应直接转化好的 model 类对象，所以不太可能直接运用在原本项目中的 model 类中。参考 google 的 <code>todo-mvvm-databinding</code> 中可以发现，原本的 model 类还是不动，每个页面都有一个 <code>ViewModel</code> 类，用于存放该页面中所有的数据对象，都是 <code>ObservableField</code> 相关的类型。</p><h3 id="3-observable-collections"><a href="#3-observable-collections" class="headerlink" title="3. observable collections"></a>3. observable collections</h3><p>顾名思义，就是 observable 容器类，个人认为也算是上面一种。</p><p>比如使用 <code>ObservableArrayMap</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">ObservableArrayMap</span>&lt;&gt;();</span><br><span class="line">user.put(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Inc.&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;age&quot;</span>, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>在 xml 中，可以用 String 类型的 key 来获取 map 中的数据：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;android.databinding.ObservableMap&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ObservableMap<span class="symbol">&amp;lt;</span>String, Object<span class="symbol">&amp;gt;</span>&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">…</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TextView</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:text</span>=<span class="string">&#x27;@</span></span></span><span class="template-variable">&#123;user[&quot;lastName&quot;]&#125;</span><span class="language-xml"><span class="tag"><span class="string">&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TextView</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:text</span>=<span class="string">&#x27;@</span></span></span><span class="template-variable">&#123;String.valueOf(1 + (Integer)user[&quot;age&quot;])&#125;</span><span class="language-xml"><span class="tag"><span class="string">&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>当 key 是 int 类型还可以使用 <code>ObservableArrayList</code>，使用的话和 <code>ArrayList</code> 没啥却别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayList&lt;Object&gt; user = <span class="keyword">new</span> <span class="title class_">ObservableArrayList</span>&lt;&gt;();</span><br><span class="line">user.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">user.add(<span class="string">&quot;Inc.&quot;</span>);</span><br><span class="line">user.add(<span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>xml 中就是通过下标来获取数据，就不贴代码了 😁。</p><hr><p>先写到这，下篇再总结<strong>Attribute Setters</strong>。</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Android/">Android</category>
      
      
      <comments>https://kinneyyan.github.io/2017-08-21/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Data-Objects/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Data Binding学习笔记——基本使用</title>
      <link>https://kinneyyan.github.io/2017-08-16/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <guid>https://kinneyyan.github.io/2017-08-16/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Wed, 16 Aug 2017 07:59:34 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Data Binding 是 google 推出的布局与数据做双向绑定的库。它是一个 support library，可以在 &lt;strong&gt;Android 2.1&lt;/strong&gt; (API level 7+)以上的平台使用，同时 Android Plugin for G</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Data Binding 是 google 推出的布局与数据做双向绑定的库。它是一个 support library，可以在 <strong>Android 2.1</strong> (API level 7+)以上的平台使用，同时 Android Plugin for Gradle 的版本必须是 <strong>1.5.0-alpha1</strong> 以上。</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>在<code>build.gradle</code>中添加：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">    <span class="operator">....</span></span><br><span class="line">    <span class="keyword">dataBinding</span> &#123;</span><br><span class="line">        enabled <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点要注意，如果 library 项目中使用了 data binding，app 项目必须也得在<code>build.gradle</code>中声明以上配置。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>这里分三部分来讲解：1、model 类；2、布局文件；3、activity&#x2F;fragment</p><h3 id="model-类的定义"><a href="#model-类的定义" class="headerlink" title="model 类的定义"></a>model 类的定义</h3><p>定义一个 POJO（plain-old Java object），形如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> firstName;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> lastName;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="type">String</span> firstName, <span class="type">String</span> lastName)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">       <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h3><p>使用一个名为<code>layout</code>的根节点编写我们以往的 layout 文件，在<code>data</code>节点内声明我们要绑定的数据，比如：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:text</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;user.firstName&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:text</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;user.lastName&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到，在<code>data</code>节点内的<code>&lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; </code>描述了此 layout 文件要使用的 model，在<code>TextView</code>的使用形如<code>@&#123;user.firstName&#125; </code>来设置 text。</p><h3 id="activity-x2F-fragment"><a href="#activity-x2F-fragment" class="headerlink" title="activity&#x2F;fragment"></a>activity&#x2F;fragment</h3><ul><li><strong>数据绑定</strong></li></ul><p>通常情况下，as 会根据我们刚才编写的 layout 文件自动生成一个 Binding class，如果 layout 文件为<code>activity_main.xml</code>，则生成的 class 就命名为<code>ActivityMainBinding</code>。然后我们需要在代码中使用这个类来做数据绑定：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;</span><br><span class="line">   super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;</span><br><span class="line">   MainActivityBinding binding = <span class="module-access"><span class="module"><span class="identifier">DataBindingUtil</span>.</span></span>set<span class="constructor">ContentView(<span class="params">this</span>, R.<span class="params">layout</span>.<span class="params">main_activity</span>)</span>;</span><br><span class="line">   <span class="comment">//or</span></span><br><span class="line">   <span class="comment">//MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());</span></span><br><span class="line">   User user = <span class="keyword">new</span> <span class="constructor">User(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;User&quot;</span>)</span>;</span><br><span class="line">   binding.set<span class="constructor">User(<span class="params">user</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们是在 ListView 或 RecyclerView 的 adapter 中要使用 data binding，如下使用：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding <span class="keyword">binding</span> = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">ListItemBinding <span class="keyword">binding</span> = DataBindingUtil.inflate(layoutInflater, R.<span class="keyword">layout</span>.list_item, viewGroup, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>事件处理</strong></li></ul><p>Data Binding 提供了两种方式来做事件绑定和处理：<code>Method References</code>和<code>Listener Bindings</code>。</p><p>这两种方式最主要的区别在于：<code>Method References</code>是当数据被绑定时就创建了对应的 listener，而<code>Listener Bindings</code>则是当事件发生时创建。</p><p><strong>Method References</strong></p><p>定义一个用来处理事件的类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onClickFriend</span>(<span class="params">View view</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout 文件中：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;handlers&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.MyHandlers&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:text</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;user.firstName&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">android:onClick</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;handlers::onClickFriend&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>此方式必须保证<strong>类中的方法签名和对应 listener 的签名保持一致</strong>，否则在编译期间会报错。</p><p><strong>Listener Bindings</strong></p><p>此种方式和<code>method references</code>类似，也是定义一个类来处理事件，区别是在 xml 中使用 lambda 表达式来声明，而且只需要类的返回类型和 listener 一致即可。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Presenter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">onSaveClick</span><span class="params">(View view, <span class="built_in">Task</span> task)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;task&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.android.example.Task&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;presenter&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.android.example.Presenter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">android:onClick</span>=<span class="string">&quot;@</span></span></span><span class="template-variable">&#123;(v) -&gt; presenter.onSaveClick(v, task)&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果要在表达式中使用断言，我们可以使用<code>void</code>作为一个符号：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>onClick=<span class="string">&quot;@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;&quot;</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文章：<br><a href="http://yanghui.name/blog/2016/02/17/data-binding-guide/">http://yanghui.name/blog/2016/02/17/data-binding-guide/</a> &gt; <a href="https://developer.android.google.cn/topic/libraries/data-binding/index.html">https://developer.android.google.cn/topic/libraries/data-binding/index.html</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Android/">Android</category>
      
      
      <comments>https://kinneyyan.github.io/2017-08-16/Data%20Binding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《穿越计算机的迷雾》读书笔记</title>
      <link>https://kinneyyan.github.io/2017-06-22/%E3%80%8A%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <guid>https://kinneyyan.github.io/2017-06-22/%E3%80%8A%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Thu, 22 Jun 2017 02:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;1-4-电流是怎样形成的&quot;&gt;&lt;a href=&quot;#1-4-电流是怎样形成的&quot; class=&quot;headerlink&quot; title=&quot;1.4 电流是怎样形成的&quot;&gt;&lt;/a&gt;1.4 电流是怎样形成的&lt;/h4&gt;&lt;p&gt;电压的存在是导致电流产生的原因&lt;/p&gt;
&lt;p&gt;通常，衡量一个</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="1-4-电流是怎样形成的"><a href="#1-4-电流是怎样形成的" class="headerlink" title="1.4 电流是怎样形成的"></a>1.4 电流是怎样形成的</h4><p>电压的存在是导致电流产生的原因</p><p>通常，衡量一个电源的重要指标是它的电压，也就是它产生电的能力。不同的电源，所提供的电压也不相同。</p><h4 id="2-3-二进制数就是比特串"><a href="#2-3-二进制数就是比特串" class="headerlink" title="2.3 二进制数就是比特串"></a>2.3 二进制数就是比特串</h4><p>对于单个的二进制数位，它们都只有一个称呼“比特”，每个比特具有两个可能的值：0 或者 1。</p><h4 id="3-3-使用全加器来构造加法机"><a href="#3-3-使用全加器来构造加法机" class="headerlink" title="3.3 使用全加器来构造加法机"></a>3.3 使用全加器来构造加法机</h4><p>为了表明这个电路的用途，我们在图的中间加了一个符号“∑”。在数学中，这个符号用来表示“加”，它的读音是“西格马”。</p><h4 id="4-5-爱迪生大战交流电"><a href="#4-5-爱迪生大战交流电" class="headerlink" title="4.5 爱迪生大战交流电"></a>4.5 爱迪生大战交流电</h4><p>与直流电不同，交流电的方向和大小都是不断变化的。要想了解直流电和交流电之间有哪些不同，使用图形可能是最直观的方法，也是工程上常用的方法。</p><h4 id="7-2-反馈和振荡器"><a href="#7-2-反馈和振荡器" class="headerlink" title="7.2 反馈和振荡器"></a>7.2 反馈和振荡器</h4><p>把一个非门的输出取出一部分来，同时又作为它的输入，这样就形成了一个反馈。</p><p>一个非门，再加上反馈之后，就能产生一连串交替变化的输出，使得与之相连的灯泡一亮一灭，很像一把振动的直尺或一个来回游荡的秋千，在两个端点之间来回运动。作为一种类比，像这种东西，在电子技术领域里叫做振荡器。</p><p>如果每秒出现 5 个脉冲，那么频率就是 5Hz，周期为 0.2 秒。</p><h4 id="7-3-电子管时代"><a href="#7-3-电子管时代" class="headerlink" title="7.3 电子管时代"></a>7.3 电子管时代</h4><p>发明振荡器，最早的目的是为了向天空中扬撒电磁波。在 20 世纪之前人们就知道，要想产生电磁波，必须使电流以极高的速度不断变化，而要产生高速变化的电流，振荡器可以做到这一点。</p><p>电子三极管的放大效果不是无端地凭空产生的，这个放大后的能量来自于电源，它只是一个转换器。</p><h4 id="7-4-记忆力非凡的触发器"><a href="#7-4-记忆力非凡的触发器" class="headerlink" title="7.4 记忆力非凡的触发器"></a>7.4 记忆力非凡的触发器</h4><p>我做了一件事，写了一些东西，加上了读者的反馈之后，触发了一连串的事情，产生了完全不同的结果。也正是因为这样，我们刚刚讲的这个电路，称为触发器。</p><h4 id="8-1-能保存一个比特的触发器"><a href="#8-1-能保存一个比特的触发器" class="headerlink" title="8.1 能保存一个比特的触发器"></a>8.1 能保存一个比特的触发器</h4><p>普通的电路，以及常规的逻辑门都有一个共性，那就是输出直接依赖于输入，当输入消失的时候，输出也跟着不存在了。触发器不同，当它触发的时候，输出会发生变化。但是，当输入撤销之后，输出依然能够维持。</p><h4 id="8-3-揭开走马灯之谜"><a href="#8-3-揭开走马灯之谜" class="headerlink" title="8.3 揭开走马灯之谜"></a>8.3 揭开走马灯之谜</h4><p>不把振荡器和灯泡算在内，一个走马灯电路通常称为循环移位寄存器。所谓“寄存”的意思是临时存放，就像火车站旁边的物品寄存处。俗话说“铁打的营盘流水的兵”，触发器随时会根据需要而保存新的比特（如果你希望得到一个不变的 0 和 1，干吗还要使用触发器），仿佛这些比特都是临时寄存在触发器里。当若干个触发器组合在一起，可以同时保存许多比特时，就称为寄存器。</p><h4 id="9-2-晶体管时代"><a href="#9-2-晶体管时代" class="headerlink" title="9.2 晶体管时代"></a>9.2 晶体管时代</h4><p>因为硅和锗是晶体，所以这个具有单向导电性的装置就叫晶体二极管。</p><p>在发明晶体二极管没多久，人们就发现如果在半导体中掺入砷、镓等原子，制作出来的晶体二极管就会发光，称为发光二极管（LED）</p><p>也就是说，这个新的半导体材料像电子三极管一样，具有放大作用。相应的，它被称为晶体三极管。</p><h4 id="10-1-把一大堆数加起来"><a href="#10-1-把一大堆数加起来" class="headerlink" title="10.1 把一大堆数加起来"></a>10.1 把一大堆数加起来</h4><p>在逻辑电路里，大家共用的公共线路称为总线。</p><h4 id="11-1-咸鸭蛋坛子和存储器"><a href="#11-1-咸鸭蛋坛子和存储器" class="headerlink" title="11.1 咸鸭蛋坛子和存储器"></a>11.1 咸鸭蛋坛子和存储器</h4><p>我们这个存储器，你可以随机地、任意地决定访问哪个存储单元，不管访问哪个存储单元，所花的时间都一样，和地址没有关系。正是因为这样，我们通常称之为“随机访问存储器”，或者“自由存取存储器”，用英文来说就是 Random Access Memory，简称 RAM。由于组成它的细胞是触发器，而这种东西就怕断电，不管它记下的是什么，只要一断电就全完蛋了，因此属于易失性存储器。</p><h4 id="11-5-全自动计算"><a href="#11-5-全自动计算" class="headerlink" title="11.5 全自动计算"></a>11.5 全自动计算</h4><p>计算机要想可靠地工作，指令的正确性至关重要。在存储器里，指令和普通的二进制数没有区别，但它们却有着独特的含义和用途。指令的数量是有限的，所以并非任意一个二进制比特串都代表一条指令。比如，1000100100 可能是某台计算机的一条指令，但 1000011110 则可能不是。如果计算机执行了并非指令的“指令”，指令译码器将不能输出正确的信号给控制器，整个计算机也就瘫痪了。</p><h4 id="12-1-更多的计算机指令"><a href="#12-1-更多的计算机指令" class="headerlink" title="12.1 更多的计算机指令"></a>12.1 更多的计算机指令</h4><p>从程序员的角度来看，这台机器的内部构造是次要的。在他们眼里，这台机器只有三样东西有价值。第一样，是存储器，因为他们需要在这里编程；第二样，是加法器，因为它是数学计算实际进行的地方，是扑克牌里的皇后。最后一样对程序员来说尤其重要，它就是寄存器 RA。原因很简单，他们可以不知道指令是怎么执行的，但绝对要知道机器把执行的结果放到哪里了。</p><h4 id="12-3-现代计算机的大体特征"><a href="#12-3-现代计算机的大体特征" class="headerlink" title="12.3 现代计算机的大体特征"></a>12.3 现代计算机的大体特征</h4><p>字长表示一台计算机在一次操作中可以处理的二进制比特数。换句话说，就是每个寄存器可以保存的二进制数是几个比特，或者加法器每次计算的二进制数是几个比特。原则上，对计算机的字长没有任何规定和限制，4 比特、6 比特、20 比特，等等，都是可以的。</p><p>任意两个寄存器之间，或者寄存器和存储单元之间，都可以互相装载数据。</p><p>现代计算机还会根据一条指令的执行情况产生各种标志，比如我们已经熟悉的进位标志。其他的标志还包括计算结果为 0、结果中 1 的个数为奇数&#x2F;偶数，等等。这些标志可以用于跳转指令，或者其他想要参考这些标志的指令。</p><p>对于任何一种类型的计算机来说，它的指令在种类和数量上都是有限的，但是不管有多少，它所能执行的所有指令，称为这种计算机的指令集。</p><h4 id="13-3-流水线和高速缓存技术"><a href="#13-3-流水线和高速缓存技术" class="headerlink" title="13.3 流水线和高速缓存技术"></a>13.3 流水线和高速缓存技术</h4><p>为了加以区分，和中央处理器最近的存储器通常称为主存储器，或者内存储器，简称内存。</p><p>除了流水线，另一个被用来平衡处理器和内存速度的手段是使用高速缓存技术，字面上的意思是速度很快的缓冲存储器。类似于蓄水池，这种技术基于计算机运行的一个特点——局部性。通俗地说，局部性的意思是，程序在被执行的过程中常常会访问最近刚刚访问过的数据，或者该位置附近的数据。</p><h4 id="13-4-掌上游戏机和手机就是计算机"><a href="#13-4-掌上游戏机和手机就是计算机" class="headerlink" title="13.4 掌上游戏机和手机就是计算机"></a>13.4 掌上游戏机和手机就是计算机</h4><p>不管任何东西，只要稍微有一点智能的——从录音笔、微波炉调温装置、电冰箱，再到电子表、手机和游戏机，都需要用到微处理器和一小块内存储器，也需要一些编排精巧的指令。你能说，那些大家伙叫计算机，而这些东西就不叫计算机吗？</p><h4 id="14-1-计算机同外部的接口"><a href="#14-1-计算机同外部的接口" class="headerlink" title="14.1 计算机同外部的接口"></a>14.1 计算机同外部的接口</h4><p>为了在外部设备和计算机核心之间传送数据，需要在这两者之间连线，并构造逻辑电路。在逻辑电路里，有一些寄存器，通常称之为 I&#x2F;O 端口，或直接称为端口。当中央处理器有话要对外部设备说时，就把它放在端口上，由后者取走；当外部设备也有话要跟中央处理器说时，也照此办理。从形式上看，端口类似于企事业单位门口的传达室。</p><h4 id="15-1-打开电源并启动计算机"><a href="#15-1-打开电源并启动计算机" class="headerlink" title="15.1 打开电源并启动计算机"></a>15.1 打开电源并启动计算机</h4><p>除了加电自检指令，ROM 中还包含一些访问外部设备的指令，我们可以用这些指令来访问设备而不必亲自编写，因为我们可能不熟悉如何与这些设备打交道。传统上，这就是设备驱动程序。</p><p>同时，这些设备驱动程序仅仅提供最基本的功能，以保守的方式使用对应的外部设备。正因为如此，该 ROM 更多地被称为基本输入&#x2F;输出系统 BIOS（Basic Input&#x2F;Output System）。</p><h4 id="15-4-操作系统的功能"><a href="#15-4-操作系统的功能" class="headerlink" title="15.4 操作系统的功能"></a>15.4 操作系统的功能</h4><p>多用户和多任务是依靠处理器和操作系统共同完成的，前者提供像中断这样的硬件支持；后者则在软件上予以配合和扩展。</p><h4 id="16-3-图像、音乐和视频"><a href="#16-3-图像、音乐和视频" class="headerlink" title="16.3 图像、音乐和视频"></a>16.3 图像、音乐和视频</h4><p>经过 MPEG 压缩后，组成视频的帧不再是传统意义上的静止图像那么简单。事实上，这些帧分为三种。第一种是参考帧，它是独立的，理论上包含完整的画面信息；后面两种类型的帧是不完整的，不能独立存在，要依赖于前面的帧、后面的帧，或者参考帧。最后，MPEG 的压缩比可以达到 150:1。一般来说，能达到 90:1 已经算是不错。</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category>
      
      
      
      <comments>https://kinneyyan.github.io/2017-06-22/%E3%80%8A%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《图解HTTP》读书笔记</title>
      <link>https://kinneyyan.github.io/2017-04-03/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <guid>https://kinneyyan.github.io/2017-04-03/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 03 Apr 2017 02:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;1-3-网络基础-TCP-x2F-IP&quot;&gt;&lt;a href=&quot;#1-3-网络基础-TCP-x2F-IP&quot; class=&quot;headerlink&quot; title=&quot;1.3 网络基础 TCP&amp;#x2F;IP&quot;&gt;&lt;/a&gt;1.3 网络基础 TCP&amp;#x2F;IP&lt;/h4&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="1-3-网络基础-TCP-x2F-IP"><a href="#1-3-网络基础-TCP-x2F-IP" class="headerlink" title="1.3 网络基础 TCP&#x2F;IP"></a>1.3 网络基础 TCP&#x2F;IP</h4><p>通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。</p><p>TCP&#x2F;IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。</p><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装（encapsulate）。</p><h4 id="1-4-与-HTTP-关系密切的协议-IP、TCP-和-DNS"><a href="#1-4-与-HTTP-关系密切的协议-IP、TCP-和-DNS" class="headerlink" title="1.4 与 HTTP 关系密切的协议 : IP、TCP 和 DNS"></a>1.4 与 HTTP 关系密切的协议 : IP、TCP 和 DNS</h4><p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略</p><h4 id="1-7-URI-和-URL"><a href="#1-7-URI-和-URL" class="headerlink" title="1.7 URI 和 URL"></a>1.7 URI 和 URL</h4><p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。</p><h4 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2 通过请求和响应的交换达成通信"></a>2.2 通过请求和响应的交换达成通信</h4><p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p><p>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p><h4 id="2-3-HTTP-是不保存状态的协议"><a href="#2-3-HTTP-是不保存状态的协议" class="headerlink" title="2.3 HTTP 是不保存状态的协议"></a>2.3 HTTP 是不保存状态的协议</h4><p>HTTP&#x2F;1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h4 id="2-7-持久连接节省通信量"><a href="#2-7-持久连接节省通信量" class="headerlink" title="2.7 持久连接节省通信量"></a>2.7 持久连接节省通信量</h4><p>为解决上述 TCP 连接的问题，HTTP&#x2F;1.1 和一部分的 HTTP&#x2F;1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><h4 id="2-8-使用-Cookie-的状态管理"><a href="#2-8-使用-Cookie-的状态管理" class="headerlink" title="2.8 使用 Cookie 的状态管理"></a>2.8 使用 Cookie 的状态管理</h4><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><h4 id="5-2-通信数据转发程序-：代理、网关、隧道"><a href="#5-2-通信数据转发程序-：代理、网关、隧道" class="headerlink" title="5.2 通信数据转发程序 ：代理、网关、隧道"></a>5.2 通信数据转发程序 ：代理、网关、隧道</h4><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</p><p>隧道的目的是确保客户端能与服务器进行安全的通信。</p><h4 id="6-2-HTTP-首部字段"><a href="#6-2-HTTP-首部字段" class="headerlink" title="6.2 HTTP 首部字段"></a>6.2 HTTP 首部字段</h4><p>若 HTTP 首部字段重复了会如何<br>当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。</p><h4 id="6-3-HTTP-x2F-1-1-通用首部字段"><a href="#6-3-HTTP-x2F-1-1-通用首部字段" class="headerlink" title="6.3 HTTP&#x2F;1.1 通用首部字段"></a>6.3 HTTP&#x2F;1.1 通用首部字段</h4><p>应用 HTTP&#x2F;1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP&#x2F;1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。</p><p>Connection 首部字段具备如下两个作用。<br>控制不再转发给代理的首部字段<br>管理持久连接</p><p>控制不再转发给代理的首部字段</p><p>所有的中间服务器如果都能以 HTTP&#x2F;1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段</p><p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP&#x2F;1.1 版本分块传输编码时。</p><h4 id="6-4-请求首部字段"><a href="#6-4-请求首部字段" class="headerlink" title="6.4 请求首部字段"></a>6.4 请求首部字段</h4><p>Host 首部字段在 HTTP&#x2F;1.1 规范内是唯一一个必须被包含在请求内的首部字段。</p><h4 id="6-6-实体首部字段"><a href="#6-6-实体首部字段" class="headerlink" title="6.6 实体首部字段"></a>6.6 实体首部字段</h4><p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段</p><p>当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。</p><h4 id="7-1-HTTP-的缺点"><a href="#7-1-HTTP-的缺点" class="headerlink" title="7.1 HTTP 的缺点"></a>7.1 HTTP 的缺点</h4><p>一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。<br>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p><h4 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP+ 加密 + 认证 + 完整性保护 &#x3D;HTTPS"></a>7.2 HTTP+ 加密 + 认证 + 完整性保护 &#x3D;HTTPS</h4><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p><h4 id="8-3-DIGEST-认证"><a href="#8-3-DIGEST-认证" class="headerlink" title="8.3 DIGEST 认证"></a>8.3 DIGEST 认证</h4><p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p><h4 id="8-4-SSL-客户端认证"><a href="#8-4-SSL-客户端认证" class="headerlink" title="8.4 SSL 客户端认证"></a>8.4 SSL 客户端认证</h4><p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p><h4 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h4><p>基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话）。</p><h4 id="9-2-消除-HTTP-瓶颈的-SPDY"><a href="#9-2-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="9.2 消除 HTTP 瓶颈的 SPDY"></a>9.2 消除 HTTP 瓶颈的 SPDY</h4><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><h4 id="9-3-使用浏览器进行全双工通信的-WebSocket"><a href="#9-3-使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="9.3 使用浏览器进行全双工通信的 WebSocket"></a>9.3 使用浏览器进行全双工通信的 WebSocket</h4><p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。</p><h4 id="10-2-动态-HTML"><a href="#10-2-动态-HTML" class="headerlink" title="10.2 动态 HTML"></a>10.2 动态 HTML</h4><p>动态 HTML 技术是通过调用客户端脚本语言 JavaScript，实现对 HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。</p><p>DOM 是用以操作 HTML 文档和 XML 文档的 API（Application Programming Interface，应用编程接口）。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。</p><h4 id="11-1-针对-Web-的攻击技术"><a href="#11-1-针对-Web-的攻击技术" class="headerlink" title="11.1 针对 Web 的攻击技术"></a>11.1 针对 Web 的攻击技术</h4><p>主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。</p><p>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p><h4 id="11-2-因输出值转义不完全引发的安全漏洞"><a href="#11-2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="11.2 因输出值转义不完全引发的安全漏洞"></a>11.2 因输出值转义不完全引发的安全漏洞</h4><p>跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。</p><p>OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。</p><p>HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p><h4 id="11-5-其他安全漏洞"><a href="#11-5-其他安全漏洞" class="headerlink" title="11.5 其他安全漏洞"></a>11.5 其他安全漏洞</h4><p>彩虹表（Rainbow Table）是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法 • 字典攻击等实际破解过程中缩短消耗时间的技巧。</p>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category>
      
      
      
      <comments>https://kinneyyan.github.io/2017-04-03/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于Android Library需要注意的细节</title>
      <link>https://kinneyyan.github.io/2016-11-07/%E5%85%B3%E4%BA%8EAndroid%20Library%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</link>
      <guid>https://kinneyyan.github.io/2016-11-07/%E5%85%B3%E4%BA%8EAndroid%20Library%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</guid>
      <pubDate>Mon, 07 Nov 2016 03:59:50 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1-设置库的资源为私有&quot;&gt;&lt;a href=&quot;#1-设置库的资源为私有&quot; class=&quot;headerlink&quot; title=&quot;1. 设置库的资源为私有&quot;&gt;&lt;/a&gt;1. 设置库的资源为私有&lt;/h2&gt;&lt;p&gt;我们都知道，库中的所有资源（res&amp;#x2F;目录的所有文件）在</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-设置库的资源为私有"><a href="#1-设置库的资源为私有" class="headerlink" title="1. 设置库的资源为私有"></a>1. 设置库的资源为私有</h2><p>我们都知道，库中的所有资源（res&#x2F;目录的所有文件）在默认情况下均处于公开状态。如果不希望库的使用者访问这些资源，我们必须通过<strong>声明一个或多个公开资源的方式来</strong>使用这种自动私有标识机制。</p><p>具体做法：</p><p>在库的 <code>res/value/</code> 目录下创建 <code>public.xml</code> 文件，添加 <code>mylib_app_name</code> 和 <code>mylib_public_string</code> 为公开字符串资源。使用库的模块如果尝试引用库中的其他资源时，Lint 会显示警告信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">&quot;mylib_app_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">&quot;mylib_public_string&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时，我们可以参考 v7 appcompat 库中的 <code>res-public/values/public_layouts.xml</code> ，就声明了 <code>support_simple_spinner_dropdown_item.layout</code> 是允许库使用者去访问的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Definitions of layouts to be exposed as public --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">type</span>=<span class="string">&quot;layout&quot;</span> <span class="attr">name</span>=<span class="string">&quot;support_simple_spinner_dropdown_item&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-app-模块的-minSdkVersion-必须大于或等于库定义的版本"><a href="#2-app-模块的-minSdkVersion-必须大于或等于库定义的版本" class="headerlink" title="2. app 模块的 minSdkVersion 必须大于或等于库定义的版本"></a>2. app 模块的 <code>minSdkVersion</code> 必须大于或等于库定义的版本</h2><p>库作为相关应用模块的一部分编译，因此，库模块中使用的 API 必须与应用模块支持的平台版本兼容。</p><h2 id="3-库模块如何使用自己的混淆配置文件"><a href="#3-库模块如何使用自己的混淆配置文件" class="headerlink" title="3. 库模块如何使用自己的混淆配置文件"></a>3. 库模块如何使用自己的混淆配置文件</h2><p>这个也算是我们平时开发过程当中的一直没搞明白的问题。因为之前库模块的混淆配置想当然的以为和 app 模块相同，实则不然，当时也没有找到解决办法，导致目前我们项目所有的混淆配置都写在 app 模块下的 <code>proguard-rules.pro</code> 。</p><p>其实我们是可以分别针对库做混淆配置的，在将库添加到 app 模块时，库的 ProGuard 文件是会附加至 app 模块的 ProGuard 配置文件 (proguard.txt)。</p><p>首先，以下配置<strong>只在 app 模块下有效</strong>，在库模块中是<strong>没有用的</strong>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="literal">true</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要指定库的混淆配置文件名称，例如，以下代码段会将 <code>lib-proguard-rules.txt</code> 设置为库的 ProGuard 配置文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        consumerProguardFiles <span class="string">&#x27;lib-proguard-rules.txt&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此这般，我们就不需要再将库中的混淆配置写到 app 模块的 <code>proguard-rules.pro</code> 了！</p><h2 id="4-app-模块无论-debug、release-构建下，默认都是使用库的-release-构建类型"><a href="#4-app-模块无论-debug、release-构建下，默认都是使用库的-release-构建类型" class="headerlink" title="4. app 模块无论 debug、release 构建下，默认都是使用库的 release 构建类型"></a>4. app 模块无论 debug、release 构建下，默认都是使用库的 release 构建类型</h2><p>如果要让 app 模块使用库中不同的构建类型咋办？</p><p>1）首先在库的<code>build.gradle</code>的<code>android</code>块内添加以下代码，将此库的非发布配置展示给使用它的项目：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    publishNonDefault <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在 app 模块的<code>build.gradle</code>中添加以下代码段使应用在 debug 构建时使用库的 debug 构建类型，release 构建时使用库的 release 构建类型：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    debugCompile project(<span class="attr">path:</span> <span class="string">&#x27;:library&#x27;</span>, <span class="attr">configuration:</span> <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    releaseCompile project(<span class="attr">path:</span> <span class="string">&#x27;:library&#x27;</span>, <span class="attr">configuration:</span> <span class="string">&#x27;release&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文章<br><a href="https://developer.android.google.cn/studio/projects/android-library.html">https://developer.android.google.cn/studio/projects/android-library.html</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://kinneyyan.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://kinneyyan.github.io/tags/Android/">Android</category>
      
      
      <comments>https://kinneyyan.github.io/2016-11-07/%E5%85%B3%E4%BA%8EAndroid%20Library%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
