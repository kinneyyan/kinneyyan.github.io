<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="a personal blog by Kinney Yan"><title>Java 内存区&amp;GC_《深入理解Java虚拟机》读书笔记 | Kinney's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/rss+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=G-LRSZVEG77Q" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-LRSZVEG77Q');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 内存区&amp;GC_《深入理解Java虚拟机》读书笔记</h1><a id="logo" href="/.">Kinney's blog</a><p class="description">stay hungry, stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/read/"><i class="fa fa-book"> 读书</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 内存区&amp;GC_《深入理解Java虚拟机》读书笔记</h1><div class="post-meta">2018-08-28<span> | </span><span class="category"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><a class="disqus-comment-count" href="/2018-08-28/Java%20%E5%86%85%E5%AD%98%E5%8C%BA&amp;GC_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#vcomment"><span class="waline-comment-count" id="/2018-08-28/Java%20%E5%86%85%E5%AD%98%E5%8C%BA&amp;GC_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8-2"><span class="toc-number">1.</span> <span class="toc-text">Java 内存区域与内存溢出异常 (#2)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F-2-2"><span class="toc-number">1.1.</span> <span class="toc-text">运行时数据区域 (#2.2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-2-2-1"><span class="toc-number">1.2.</span> <span class="toc-text">程序计数器 (#2.2.1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-2-2-2"><span class="toc-number">1.3.</span> <span class="toc-text">Java 虚拟机栈 (#2.2.2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%A0%86-2-2-4"><span class="toc-number">1.4.</span> <span class="toc-text">Java 堆 (#2.2.4)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-2-2-5"><span class="toc-number">1.5.</span> <span class="toc-text">方法区 (# 2.2.5)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-2-2-6"><span class="toc-number">1.6.</span> <span class="toc-text">运行时常量池 (#2.2.6)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HotSpot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98-2-3"><span class="toc-number">1.7.</span> <span class="toc-text">HotSpot 虚拟机对象探秘 (#2.3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-2-3-1"><span class="toc-number">1.8.</span> <span class="toc-text">对象的创建 (#2.3.1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-2-3-2"><span class="toc-number">1.9.</span> <span class="toc-text">对象的内存布局 (#2.3.2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-2-3-3"><span class="toc-number">1.10.</span> <span class="toc-text">对象的访问定位 (#2.3.3)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-3"><span class="toc-number">2.</span> <span class="toc-text">垃圾收集器与内存分配策略 (#3)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95-3-2-1"><span class="toc-number">2.1.</span> <span class="toc-text">引用计数算法 (#3.2.1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-3-2-2"><span class="toc-number">2.2.</span> <span class="toc-text">可达性分析算法 (#3.2.2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8-3-2-3"><span class="toc-number">2.3.</span> <span class="toc-text">再谈引用 (#3.2.3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1-3-2-4"><span class="toc-number">2.4.</span> <span class="toc-text">生存还是死亡 (#3.2.4)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA-3-2-5"><span class="toc-number">2.5.</span> <span class="toc-text">回收方法区 (#3.2.5)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-3-3"><span class="toc-number">2.6.</span> <span class="toc-text">垃圾收集算法 (#3.3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95-3-3-1"><span class="toc-number">2.7.</span> <span class="toc-text">标记-清除算法 (#3.3.1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95-3-3-2"><span class="toc-number">2.8.</span> <span class="toc-text">复制算法 (#3.3.2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95-3-3-3"><span class="toc-number">2.9.</span> <span class="toc-text">标记-整理算法 (#3.3.3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-3-3-4"><span class="toc-number">2.10.</span> <span class="toc-text">分代收集算法 (#3.3.4)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5-3-6"><span class="toc-number">2.11.</span> <span class="toc-text">内存分配与回收策略 (#3.6)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%88%86%E9%85%8D-3-6-1"><span class="toc-number">2.12.</span> <span class="toc-text">对象优先在 Eden 分配 (#3.6.1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3-3-6-2"><span class="toc-number">2.13.</span> <span class="toc-text">大对象直接进入老年代 (#3.6.2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3-3-6-3"><span class="toc-number">2.14.</span> <span class="toc-text">长期存活的对象将进入老年代 (#3.6.3 　)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A-3-6-4"><span class="toc-number">2.15.</span> <span class="toc-text">动态对象年龄判定 (#3.6.4)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D-3-6-5"><span class="toc-number">2.16.</span> <span class="toc-text">空间分配担保 (#3.6.5)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-4"><span class="toc-number">3.</span> <span class="toc-text">虚拟机性能监控与故障处理工具 (#4)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7-4-3"><span class="toc-number">3.1.</span> <span class="toc-text">JDK 的可视化工具 (#4.3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VisualVM%EF%BC%9A%E5%A4%9A%E5%90%88%E4%B8%80%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-4-3-2"><span class="toc-number">3.2.</span> <span class="toc-text">VisualVM：多合一故障处理工具 (#4.3.2)</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="Java-内存区域与内存溢出异常-2"><a href="#Java-内存区域与内存溢出异常-2" class="headerlink" title="Java 内存区域与内存溢出异常 (#2)"></a>Java 内存区域与内存溢出异常 (#2)</h3><h4 id="运行时数据区域-2-2"><a href="#运行时数据区域-2-2" class="headerlink" title="运行时数据区域 (#2.2)"></a>运行时数据区域 (#2.2)</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java 虚拟机规范（Java SE 7 版）》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示：<img src="https://guolei1130.github.io/images/jvm/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="Java内存区域"></p>
<h4 id="程序计数器-2-2-1"><a href="#程序计数器-2-2-1" class="headerlink" title="程序计数器 (#2.2.1)"></a>程序计数器 (#2.2.1)</h4><p><strong>程序计数器</strong>（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<strong>“线程私有”的内存</strong>。</p>
<h4 id="Java-虚拟机栈-2-2-2"><a href="#Java-虚拟机栈-2-2-2" class="headerlink" title="Java 虚拟机栈 (#2.2.2)"></a>Java 虚拟机栈 (#2.2.2)</h4><p><strong>Java 虚拟机栈</strong>（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p><strong>局部变量表所需的内存空间</strong>在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h4 id="Java-堆-2-2-4"><a href="#Java-堆-2-2-4" class="headerlink" title="Java 堆 (#2.2.4)"></a>Java 堆 (#2.2.4)</h4><p><strong>Java 堆</strong>（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域。</p>
<p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，<u>栈上分配</u>、<u>标量替换</u>优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<h4 id="方法区-2-2-5"><a href="#方法区-2-2-5" class="headerlink" title="方法区 (# 2.2.5)"></a>方法区 (# 2.2.5)</h4><p><strong>方法区</strong>（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p>
<h4 id="运行时常量池-2-2-6"><a href="#运行时常量池-2-2-6" class="headerlink" title="运行时常量池 (#2.2.6)"></a>运行时常量池 (#2.2.6)</h4><p><strong>运行时常量池</strong>（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h4 id="HotSpot-虚拟机对象探秘-2-3"><a href="#HotSpot-虚拟机对象探秘-2-3" class="headerlink" title="HotSpot 虚拟机对象探秘 (#2.3)"></a>HotSpot 虚拟机对象探秘 (#2.3)</h4><h4 id="对象的创建-2-3-1"><a href="#对象的创建-2-3-1" class="headerlink" title="对象的创建 (#2.3.1)"></a>对象的创建 (#2.3.1)</h4><p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。</p>
<p>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。</p>
<h4 id="对象的内存布局-2-3-2"><a href="#对象的内存布局-2-3-2" class="headerlink" title="对象的内存布局 (#2.3.2)"></a>对象的内存布局 (#2.3.2)</h4><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<h4 id="对象的访问定位-2-3-3"><a href="#对象的访问定位-2-3-3" class="headerlink" title="对象的访问定位 (#2.3.3)"></a>对象的访问定位 (#2.3.3)</h4><p>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p>
<ol>
<li>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
<li>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</li>
</ol>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
<h3 id="垃圾收集器与内存分配策略-3"><a href="#垃圾收集器与内存分配策略-3" class="headerlink" title="垃圾收集器与内存分配策略 (#3)"></a>垃圾收集器与内存分配策略 (#3)</h3><h4 id="引用计数算法-3-2-1"><a href="#引用计数算法-3-2-1" class="headerlink" title="引用计数算法 (#3.2.1)"></a>引用计数算法 (#3.2.1)</h4><ul>
<li><p>定义：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。</p>
</li>
<li><p>缺点：很难解决对象之间相互循环引用的问题。</p>
</li>
</ul>
<h4 id="可达性分析算法-3-2-2"><a href="#可达性分析算法-3-2-2" class="headerlink" title="可达性分析算法 (#3.2.2)"></a>可达性分析算法 (#3.2.2)</h4><ul>
<li>定义：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。</li>
</ul>
<p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</p>
<h4 id="再谈引用-3-2-3"><a href="#再谈引用-3-2-3" class="headerlink" title="再谈引用 (#3.2.3)"></a>再谈引用 (#3.2.3)</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。</p>
<p><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似“Object obj&#x3D;new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<p><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。</p>
<p><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</p>
<p><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</p>
<h4 id="生存还是死亡-3-2-4"><a href="#生存还是死亡-3-2-4" class="headerlink" title="生存还是死亡 (#3.2.4)"></a>生存还是死亡 (#3.2.4)</h4><p>关于对象死亡时<strong>finalize（）</strong>方法建议尽量避免使用它，因为它不是 C&#x2F;C++中的析构函数，而是 Java 刚诞生时为了使 C&#x2F;C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize（）能做的所有工作，使用 try-finally 或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉 Java 语言中有这个方法的存在。</p>
<h4 id="回收方法区-3-2-5"><a href="#回收方法区-3-2-5" class="headerlink" title="回收方法区 (#3.2.5)"></a>回收方法区 (#3.2.5)</h4><p>很多人认为方法区（或者 HotSpot 虚拟机中的永久代）是没有垃圾收集的，Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收 70%～ 95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>
<h4 id="垃圾收集算法-3-3"><a href="#垃圾收集算法-3-3" class="headerlink" title="垃圾收集算法 (#3.3)"></a>垃圾收集算法 (#3.3)</h4><h4 id="标记-清除算法-3-3-1"><a href="#标记-清除算法-3-3-1" class="headerlink" title="标记-清除算法 (#3.3.1)"></a>标记-清除算法 (#3.3.1)</h4><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p>
<h4 id="复制算法-3-3-2"><a href="#复制算法-3-3-2" class="headerlink" title="复制算法 (#3.3.2)"></a>复制算法 (#3.3.2)</h4><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<h4 id="标记-整理算法-3-3-3"><a href="#标记-整理算法-3-3-3" class="headerlink" title="标记-整理算法 (#3.3.3)"></a>标记-整理算法 (#3.3.3)</h4><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法-3-3-4"><a href="#分代收集算法-3-3-4" class="headerlink" title="分代收集算法 (#3.3.4)"></a>分代收集算法 (#3.3.4)</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<u>复制算法</u>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“<u>标记—清理</u>”或者“<u>标记—整理</u>”算法来进行回收。</p>
<h4 id="内存分配与回收策略-3-6"><a href="#内存分配与回收策略-3-6" class="headerlink" title="内存分配与回收策略 (#3.6)"></a>内存分配与回收策略 (#3.6)</h4><h4 id="对象优先在-Eden-分配-3-6-1"><a href="#对象优先在-Eden-分配-3-6-1" class="headerlink" title="对象优先在 Eden 分配 (#3.6.1)"></a>对象优先在 Eden 分配 (#3.6.1)</h4><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<p><em>Minor GC 和 Full GC 有什么不一样吗？</em></p>
<p><strong>新生代 GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p>
<p><strong>老年代 GC（Major GC&#x2F;Full GC）</strong>：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</p>
<h4 id="大对象直接进入老年代-3-6-2"><a href="#大对象直接进入老年代-3-6-2" class="headerlink" title="大对象直接进入老年代 (#3.6.2)"></a>大对象直接进入老年代 (#3.6.2)</h4><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。</p>
<h4 id="长期存活的对象将进入老年代-3-6-3"><a href="#长期存活的对象将进入老年代-3-6-3" class="headerlink" title="长期存活的对象将进入老年代 (#3.6.3 　)"></a>长期存活的对象将进入老年代 (#3.6.3 　)</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold 设置。</p>
<h4 id="动态对象年龄判定-3-6-4"><a href="#动态对象年龄判定-3-6-4" class="headerlink" title="动态对象年龄判定 (#3.6.4)"></a>动态对象年龄判定 (#3.6.4)</h4><p>虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p>
<h4 id="空间分配担保-3-6-5"><a href="#空间分配担保-3-6-5" class="headerlink" title="空间分配担保 (#3.6.5)"></a>空间分配担保 (#3.6.5)</h4><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。</p>
<h3 id="虚拟机性能监控与故障处理工具-4"><a href="#虚拟机性能监控与故障处理工具-4" class="headerlink" title="虚拟机性能监控与故障处理工具 (#4)"></a>虚拟机性能监控与故障处理工具 (#4)</h3><h4 id="JDK-的可视化工具-4-3"><a href="#JDK-的可视化工具-4-3" class="headerlink" title="JDK 的可视化工具 (#4.3)"></a>JDK 的可视化工具 (#4.3)</h4><p>JDK 中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole 和 VisualVM。</p>
<h4 id="VisualVM：多合一故障处理工具-4-3-2"><a href="#VisualVM：多合一故障处理工具-4-3-2" class="headerlink" title="VisualVM：多合一故障处理工具 (#4.3.2)"></a>VisualVM：多合一故障处理工具 (#4.3.2)</h4><p>VisualVM 可以做到： 显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。 监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。 dump 以及分析堆转储快照（jmap、jhat）。 方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。 离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。 其他 plugins 的无限的可能性……</p>
</div><div class="tags"><a href="/tags/Java"><i class="fa fa-tag">Java</i></a></div><div class="post-nav"><a class="pre" href="/2018-08-29/Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&amp;%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4_%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Class 文件结构&amp;字节码指令-《深入理解Java虚拟机》读书笔记</a><a class="next" href="/2017-12-26/Git%20submodule%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Git submodule 学习笔记</a></div><div id="waline"></div><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script>let metaInfo = ['nick', 'mail', 'link']
let requiredMeta = 'nick,mail'.split(',').filter(item => {
  return metaInfo.indexOf(item) > -1
})
Waline.init({
  el: '#waline',
  comment: true,
  serverURL: 'https://waline-blog-swart.vercel.app',
  pageSize: '30',
  wordLimit: '500',
  requiredMeta,
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/avatar.jpg"/></a><p>一个平凡的前端开发</p><a class="info-icon" href="https://twitter.com/kinney_yan" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:yanshi.ars@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/kinneyyan" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/ssh/" style="font-size: 15px;">ssh</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 15px;">树莓派</a> <a href="/tags/RSS/" style="font-size: 15px;">RSS</a> <a href="/tags/aria2/" style="font-size: 15px;">aria2</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022-09-27/%E6%88%91%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%EF%BC%882022%EF%BC%89/">我的树莓派使用小结（2022）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-26/%E4%BD%BF%E7%94%A8%20Tiny%20Tiny%20RSS%20%E8%A6%81%E7%82%B9%E5%8F%8A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">使用 Tiny Tiny RSS 要点及踩坑记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-17/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E6%A0%91%E8%8E%93%E6%B4%BE4B%20+%20KodExplorer%EF%BC%89/">低成本搭建私有云（树莓派4B + KodExplorer）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-11/%20Linux%20%E4%B8%8B%20ZeroTier%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">Linux 下 ZeroTier 的安装和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-11-10/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%88%E8%80%81%E6%AF%9B%E5%AD%90%20+%20KodExplorer%EF%BC%89/">低成本搭建私有云（老毛子 + KodExplorer）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-04-15/tmux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">tmux 常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-04-08/SSH%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">SSH 常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-01-29/find,%20grep%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/">find, grep 命令速查</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-01-16/git-rebase%20%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/">git rebase 交互模式的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-01-07/React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%BD%AC/">React 的生命周期(转)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverURL="https://waline-blog-swart.vercel.app" count="5" src="/js/recent-comments.js?v=1.0.0" async="async"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Kinney's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div>
<!-- Cloudflare Web Analytics -->
<script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "ee133de067eb464093931c3a365a2bb5"}'></script>
<!-- End Cloudflare Web Analytics -->
</body></html>